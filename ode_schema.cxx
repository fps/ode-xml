// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ode_schema.hxx"

// RSObject
// 

const RSObject::Name_optional& RSObject::
Name () const
{
  return this->Name_;
}

RSObject::Name_optional& RSObject::
Name ()
{
  return this->Name_;
}

void RSObject::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void RSObject::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void RSObject::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// Sim
// 

const Sim::World_sequence& Sim::
World () const
{
  return this->World_;
}

Sim::World_sequence& Sim::
World ()
{
  return this->World_;
}

void Sim::
World (const World_sequence& s)
{
  this->World_ = s;
}

const Sim::Space_sequence& Sim::
Space () const
{
  return this->Space_;
}

Sim::Space_sequence& Sim::
Space ()
{
  return this->Space_;
}

void Sim::
Space (const Space_sequence& s)
{
  this->Space_ = s;
}

const Sim::Body_sequence& Sim::
Body () const
{
  return this->Body_;
}

Sim::Body_sequence& Sim::
Body ()
{
  return this->Body_;
}

void Sim::
Body (const Body_sequence& s)
{
  this->Body_ = s;
}

const Sim::Geom_sequence& Sim::
Geom () const
{
  return this->Geom_;
}

Sim::Geom_sequence& Sim::
Geom ()
{
  return this->Geom_;
}

void Sim::
Geom (const Geom_sequence& s)
{
  this->Geom_ = s;
}


// World
// 

const World::AutoDisableAngularThreshold_optional& World::
AutoDisableAngularThreshold () const
{
  return this->AutoDisableAngularThreshold_;
}

World::AutoDisableAngularThreshold_optional& World::
AutoDisableAngularThreshold ()
{
  return this->AutoDisableAngularThreshold_;
}

void World::
AutoDisableAngularThreshold (const AutoDisableAngularThreshold_type& x)
{
  this->AutoDisableAngularThreshold_.set (x);
}

void World::
AutoDisableAngularThreshold (const AutoDisableAngularThreshold_optional& x)
{
  this->AutoDisableAngularThreshold_ = x;
}

const World::AutoDisableFlag_optional& World::
AutoDisableFlag () const
{
  return this->AutoDisableFlag_;
}

World::AutoDisableFlag_optional& World::
AutoDisableFlag ()
{
  return this->AutoDisableFlag_;
}

void World::
AutoDisableFlag (const AutoDisableFlag_type& x)
{
  this->AutoDisableFlag_.set (x);
}

void World::
AutoDisableFlag (const AutoDisableFlag_optional& x)
{
  this->AutoDisableFlag_ = x;
}

const World::AutoDisableSteps_optional& World::
AutoDisableSteps () const
{
  return this->AutoDisableSteps_;
}

World::AutoDisableSteps_optional& World::
AutoDisableSteps ()
{
  return this->AutoDisableSteps_;
}

void World::
AutoDisableSteps (const AutoDisableSteps_type& x)
{
  this->AutoDisableSteps_.set (x);
}

void World::
AutoDisableSteps (const AutoDisableSteps_optional& x)
{
  this->AutoDisableSteps_ = x;
}

const World::AutoDisableTime_optional& World::
AutoDisableTime () const
{
  return this->AutoDisableTime_;
}

World::AutoDisableTime_optional& World::
AutoDisableTime ()
{
  return this->AutoDisableTime_;
}

void World::
AutoDisableTime (const AutoDisableTime_type& x)
{
  this->AutoDisableTime_.set (x);
}

void World::
AutoDisableTime (const AutoDisableTime_optional& x)
{
  this->AutoDisableTime_ = x;
}

const World::CFM_optional& World::
CFM () const
{
  return this->CFM_;
}

World::CFM_optional& World::
CFM ()
{
  return this->CFM_;
}

void World::
CFM (const CFM_type& x)
{
  this->CFM_.set (x);
}

void World::
CFM (const CFM_optional& x)
{
  this->CFM_ = x;
}

const World::ContactMaxCorrectingVel_optional& World::
ContactMaxCorrectingVel () const
{
  return this->ContactMaxCorrectingVel_;
}

World::ContactMaxCorrectingVel_optional& World::
ContactMaxCorrectingVel ()
{
  return this->ContactMaxCorrectingVel_;
}

void World::
ContactMaxCorrectingVel (const ContactMaxCorrectingVel_type& x)
{
  this->ContactMaxCorrectingVel_.set (x);
}

void World::
ContactMaxCorrectingVel (const ContactMaxCorrectingVel_optional& x)
{
  this->ContactMaxCorrectingVel_ = x;
}

const World::ContactSurfaceLayer_optional& World::
ContactSurfaceLayer () const
{
  return this->ContactSurfaceLayer_;
}

World::ContactSurfaceLayer_optional& World::
ContactSurfaceLayer ()
{
  return this->ContactSurfaceLayer_;
}

void World::
ContactSurfaceLayer (const ContactSurfaceLayer_type& x)
{
  this->ContactSurfaceLayer_.set (x);
}

void World::
ContactSurfaceLayer (const ContactSurfaceLayer_optional& x)
{
  this->ContactSurfaceLayer_ = x;
}

const World::ERP_optional& World::
ERP () const
{
  return this->ERP_;
}

World::ERP_optional& World::
ERP ()
{
  return this->ERP_;
}

void World::
ERP (const ERP_type& x)
{
  this->ERP_.set (x);
}

void World::
ERP (const ERP_optional& x)
{
  this->ERP_ = x;
}

const World::Gravity_optional& World::
Gravity () const
{
  return this->Gravity_;
}

World::Gravity_optional& World::
Gravity ()
{
  return this->Gravity_;
}

void World::
Gravity (const Gravity_type& x)
{
  this->Gravity_.set (x);
}

void World::
Gravity (const Gravity_optional& x)
{
  this->Gravity_ = x;
}

void World::
Gravity (::std::auto_ptr< Gravity_type > x)
{
  this->Gravity_.set (x);
}

const World::QuickStepNumIterations_optional& World::
QuickStepNumIterations () const
{
  return this->QuickStepNumIterations_;
}

World::QuickStepNumIterations_optional& World::
QuickStepNumIterations ()
{
  return this->QuickStepNumIterations_;
}

void World::
QuickStepNumIterations (const QuickStepNumIterations_type& x)
{
  this->QuickStepNumIterations_.set (x);
}

void World::
QuickStepNumIterations (const QuickStepNumIterations_optional& x)
{
  this->QuickStepNumIterations_ = x;
}

const World::Body_sequence& World::
Body () const
{
  return this->Body_;
}

World::Body_sequence& World::
Body ()
{
  return this->Body_;
}

void World::
Body (const Body_sequence& s)
{
  this->Body_ = s;
}


// GeomObject
// 

const GeomObject::Enable_optional& GeomObject::
Enable () const
{
  return this->Enable_;
}

GeomObject::Enable_optional& GeomObject::
Enable ()
{
  return this->Enable_;
}

void GeomObject::
Enable (const Enable_type& x)
{
  this->Enable_.set (x);
}

void GeomObject::
Enable (const Enable_optional& x)
{
  this->Enable_ = x;
}

const GeomObject::CategoryBits_optional& GeomObject::
CategoryBits () const
{
  return this->CategoryBits_;
}

GeomObject::CategoryBits_optional& GeomObject::
CategoryBits ()
{
  return this->CategoryBits_;
}

void GeomObject::
CategoryBits (const CategoryBits_type& x)
{
  this->CategoryBits_.set (x);
}

void GeomObject::
CategoryBits (const CategoryBits_optional& x)
{
  this->CategoryBits_ = x;
}

const GeomObject::CollideBits_optional& GeomObject::
CollideBits () const
{
  return this->CollideBits_;
}

GeomObject::CollideBits_optional& GeomObject::
CollideBits ()
{
  return this->CollideBits_;
}

void GeomObject::
CollideBits (const CollideBits_type& x)
{
  this->CollideBits_.set (x);
}

void GeomObject::
CollideBits (const CollideBits_optional& x)
{
  this->CollideBits_ = x;
}

const GeomObject::Position_optional& GeomObject::
Position () const
{
  return this->Position_;
}

GeomObject::Position_optional& GeomObject::
Position ()
{
  return this->Position_;
}

void GeomObject::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void GeomObject::
Position (const Position_optional& x)
{
  this->Position_ = x;
}

void GeomObject::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const GeomObject::Quaternion_optional& GeomObject::
Quaternion () const
{
  return this->Quaternion_;
}

GeomObject::Quaternion_optional& GeomObject::
Quaternion ()
{
  return this->Quaternion_;
}

void GeomObject::
Quaternion (const Quaternion_type& x)
{
  this->Quaternion_.set (x);
}

void GeomObject::
Quaternion (const Quaternion_optional& x)
{
  this->Quaternion_ = x;
}

void GeomObject::
Quaternion (::std::auto_ptr< Quaternion_type > x)
{
  this->Quaternion_.set (x);
}

const GeomObject::Rotation_optional& GeomObject::
Rotation () const
{
  return this->Rotation_;
}

GeomObject::Rotation_optional& GeomObject::
Rotation ()
{
  return this->Rotation_;
}

void GeomObject::
Rotation (const Rotation_type& x)
{
  this->Rotation_.set (x);
}

void GeomObject::
Rotation (const Rotation_optional& x)
{
  this->Rotation_ = x;
}

void GeomObject::
Rotation (::std::auto_ptr< Rotation_type > x)
{
  this->Rotation_.set (x);
}


// SpaceBase
// 

const SpaceBase::Geom_sequence& SpaceBase::
Geom () const
{
  return this->Geom_;
}

SpaceBase::Geom_sequence& SpaceBase::
Geom ()
{
  return this->Geom_;
}

void SpaceBase::
Geom (const Geom_sequence& s)
{
  this->Geom_ = s;
}


// SimpleSpace
// 


// Body
// 

const Body::Space_optional& Body::
Space () const
{
  return this->Space_;
}

Body::Space_optional& Body::
Space ()
{
  return this->Space_;
}

void Body::
Space (const Space_type& x)
{
  this->Space_.set (x);
}

void Body::
Space (const Space_optional& x)
{
  this->Space_ = x;
}

void Body::
Space (::std::auto_ptr< Space_type > x)
{
  this->Space_.set (x);
}

const Body::World_optional& Body::
World () const
{
  return this->World_;
}

Body::World_optional& Body::
World ()
{
  return this->World_;
}

void Body::
World (const World_type& x)
{
  this->World_.set (x);
}

void Body::
World (const World_optional& x)
{
  this->World_ = x;
}

void Body::
World (::std::auto_ptr< World_type > x)
{
  this->World_.set (x);
}

const Body::Enabled_optional& Body::
Enabled () const
{
  return this->Enabled_;
}

Body::Enabled_optional& Body::
Enabled ()
{
  return this->Enabled_;
}

void Body::
Enabled (const Enabled_type& x)
{
  this->Enabled_.set (x);
}

void Body::
Enabled (const Enabled_optional& x)
{
  this->Enabled_ = x;
}

const Body::AngularVel_optional& Body::
AngularVel () const
{
  return this->AngularVel_;
}

Body::AngularVel_optional& Body::
AngularVel ()
{
  return this->AngularVel_;
}

void Body::
AngularVel (const AngularVel_type& x)
{
  this->AngularVel_.set (x);
}

void Body::
AngularVel (const AngularVel_optional& x)
{
  this->AngularVel_ = x;
}

void Body::
AngularVel (::std::auto_ptr< AngularVel_type > x)
{
  this->AngularVel_.set (x);
}

const Body::FiniteRotationAxis_optional& Body::
FiniteRotationAxis () const
{
  return this->FiniteRotationAxis_;
}

Body::FiniteRotationAxis_optional& Body::
FiniteRotationAxis ()
{
  return this->FiniteRotationAxis_;
}

void Body::
FiniteRotationAxis (const FiniteRotationAxis_type& x)
{
  this->FiniteRotationAxis_.set (x);
}

void Body::
FiniteRotationAxis (const FiniteRotationAxis_optional& x)
{
  this->FiniteRotationAxis_ = x;
}

void Body::
FiniteRotationAxis (::std::auto_ptr< FiniteRotationAxis_type > x)
{
  this->FiniteRotationAxis_.set (x);
}

const Body::FiniteRotationMode_optional& Body::
FiniteRotationMode () const
{
  return this->FiniteRotationMode_;
}

Body::FiniteRotationMode_optional& Body::
FiniteRotationMode ()
{
  return this->FiniteRotationMode_;
}

void Body::
FiniteRotationMode (const FiniteRotationMode_type& x)
{
  this->FiniteRotationMode_.set (x);
}

void Body::
FiniteRotationMode (const FiniteRotationMode_optional& x)
{
  this->FiniteRotationMode_ = x;
}

const Body::Force_optional& Body::
Force () const
{
  return this->Force_;
}

Body::Force_optional& Body::
Force ()
{
  return this->Force_;
}

void Body::
Force (const Force_type& x)
{
  this->Force_.set (x);
}

void Body::
Force (const Force_optional& x)
{
  this->Force_ = x;
}

void Body::
Force (::std::auto_ptr< Force_type > x)
{
  this->Force_.set (x);
}

const Body::GravityMode_optional& Body::
GravityMode () const
{
  return this->GravityMode_;
}

Body::GravityMode_optional& Body::
GravityMode ()
{
  return this->GravityMode_;
}

void Body::
GravityMode (const GravityMode_type& x)
{
  this->GravityMode_.set (x);
}

void Body::
GravityMode (const GravityMode_optional& x)
{
  this->GravityMode_ = x;
}

const Body::LinearVel_optional& Body::
LinearVel () const
{
  return this->LinearVel_;
}

Body::LinearVel_optional& Body::
LinearVel ()
{
  return this->LinearVel_;
}

void Body::
LinearVel (const LinearVel_type& x)
{
  this->LinearVel_.set (x);
}

void Body::
LinearVel (const LinearVel_optional& x)
{
  this->LinearVel_ = x;
}

void Body::
LinearVel (::std::auto_ptr< LinearVel_type > x)
{
  this->LinearVel_.set (x);
}

const Body::Mass_optional& Body::
Mass () const
{
  return this->Mass_;
}

Body::Mass_optional& Body::
Mass ()
{
  return this->Mass_;
}

void Body::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}

void Body::
Mass (const Mass_optional& x)
{
  this->Mass_ = x;
}

void Body::
Mass (::std::auto_ptr< Mass_type > x)
{
  this->Mass_.set (x);
}

const Body::Torque_optional& Body::
Torque () const
{
  return this->Torque_;
}

Body::Torque_optional& Body::
Torque ()
{
  return this->Torque_;
}

void Body::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void Body::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}

void Body::
Torque (::std::auto_ptr< Torque_type > x)
{
  this->Torque_.set (x);
}

const Body::Position_optional& Body::
Position () const
{
  return this->Position_;
}

Body::Position_optional& Body::
Position ()
{
  return this->Position_;
}

void Body::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void Body::
Position (const Position_optional& x)
{
  this->Position_ = x;
}

void Body::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const Body::Quaternion_optional& Body::
Quaternion () const
{
  return this->Quaternion_;
}

Body::Quaternion_optional& Body::
Quaternion ()
{
  return this->Quaternion_;
}

void Body::
Quaternion (const Quaternion_type& x)
{
  this->Quaternion_.set (x);
}

void Body::
Quaternion (const Quaternion_optional& x)
{
  this->Quaternion_ = x;
}

void Body::
Quaternion (::std::auto_ptr< Quaternion_type > x)
{
  this->Quaternion_.set (x);
}

const Body::Rotation_optional& Body::
Rotation () const
{
  return this->Rotation_;
}

Body::Rotation_optional& Body::
Rotation ()
{
  return this->Rotation_;
}

void Body::
Rotation (const Rotation_type& x)
{
  this->Rotation_.set (x);
}

void Body::
Rotation (const Rotation_optional& x)
{
  this->Rotation_ = x;
}

void Body::
Rotation (::std::auto_ptr< Rotation_type > x)
{
  this->Rotation_.set (x);
}


// Mass
// 


// BoxTotalMass
// 

const BoxTotalMass::TotalMass_type& BoxTotalMass::
TotalMass () const
{
  return this->TotalMass_.get ();
}

BoxTotalMass::TotalMass_type& BoxTotalMass::
TotalMass ()
{
  return this->TotalMass_.get ();
}

void BoxTotalMass::
TotalMass (const TotalMass_type& x)
{
  this->TotalMass_.set (x);
}

const BoxTotalMass::LX_type& BoxTotalMass::
LX () const
{
  return this->LX_.get ();
}

BoxTotalMass::LX_type& BoxTotalMass::
LX ()
{
  return this->LX_.get ();
}

void BoxTotalMass::
LX (const LX_type& x)
{
  this->LX_.set (x);
}

const BoxTotalMass::LY_type& BoxTotalMass::
LY () const
{
  return this->LY_.get ();
}

BoxTotalMass::LY_type& BoxTotalMass::
LY ()
{
  return this->LY_.get ();
}

void BoxTotalMass::
LY (const LY_type& x)
{
  this->LY_.set (x);
}

const BoxTotalMass::LZ_type& BoxTotalMass::
LZ () const
{
  return this->LZ_.get ();
}

BoxTotalMass::LZ_type& BoxTotalMass::
LZ ()
{
  return this->LZ_.get ();
}

void BoxTotalMass::
LZ (const LZ_type& x)
{
  this->LZ_.set (x);
}


// Joint
// 

const Joint::Feedback_optional& Joint::
Feedback () const
{
  return this->Feedback_;
}

Joint::Feedback_optional& Joint::
Feedback ()
{
  return this->Feedback_;
}

void Joint::
Feedback (const Feedback_type& x)
{
  this->Feedback_.set (x);
}

void Joint::
Feedback (const Feedback_optional& x)
{
  this->Feedback_ = x;
}

const Joint::Body1_optional& Joint::
Body1 () const
{
  return this->Body1_;
}

Joint::Body1_optional& Joint::
Body1 ()
{
  return this->Body1_;
}

void Joint::
Body1 (const Body1_type& x)
{
  this->Body1_.set (x);
}

void Joint::
Body1 (const Body1_optional& x)
{
  this->Body1_ = x;
}

void Joint::
Body1 (::std::auto_ptr< Body1_type > x)
{
  this->Body1_.set (x);
}

const Joint::Body2_optional& Joint::
Body2 () const
{
  return this->Body2_;
}

Joint::Body2_optional& Joint::
Body2 ()
{
  return this->Body2_;
}

void Joint::
Body2 (const Body2_type& x)
{
  this->Body2_.set (x);
}

void Joint::
Body2 (const Body2_optional& x)
{
  this->Body2_ = x;
}

void Joint::
Body2 (::std::auto_ptr< Body2_type > x)
{
  this->Body2_.set (x);
}


// HingeJoint
// 

const HingeJoint::Anchor_optional& HingeJoint::
Anchor () const
{
  return this->Anchor_;
}

HingeJoint::Anchor_optional& HingeJoint::
Anchor ()
{
  return this->Anchor_;
}

void HingeJoint::
Anchor (const Anchor_type& x)
{
  this->Anchor_.set (x);
}

void HingeJoint::
Anchor (const Anchor_optional& x)
{
  this->Anchor_ = x;
}

void HingeJoint::
Anchor (::std::auto_ptr< Anchor_type > x)
{
  this->Anchor_.set (x);
}

const HingeJoint::Axis_optional& HingeJoint::
Axis () const
{
  return this->Axis_;
}

HingeJoint::Axis_optional& HingeJoint::
Axis ()
{
  return this->Axis_;
}

void HingeJoint::
Axis (const Axis_type& x)
{
  this->Axis_.set (x);
}

void HingeJoint::
Axis (const Axis_optional& x)
{
  this->Axis_ = x;
}

void HingeJoint::
Axis (::std::auto_ptr< Axis_type > x)
{
  this->Axis_.set (x);
}

const HingeJoint::Torque_optional& HingeJoint::
Torque () const
{
  return this->Torque_;
}

HingeJoint::Torque_optional& HingeJoint::
Torque ()
{
  return this->Torque_;
}

void HingeJoint::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void HingeJoint::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}


// GeomBox
// 

const GeomBox::Lengths_optional& GeomBox::
Lengths () const
{
  return this->Lengths_;
}

GeomBox::Lengths_optional& GeomBox::
Lengths ()
{
  return this->Lengths_;
}

void GeomBox::
Lengths (const Lengths_type& x)
{
  this->Lengths_.set (x);
}

void GeomBox::
Lengths (const Lengths_optional& x)
{
  this->Lengths_ = x;
}

void GeomBox::
Lengths (::std::auto_ptr< Lengths_type > x)
{
  this->Lengths_.set (x);
}


// GeomCylinder
// 

const GeomCylinder::Length_optional& GeomCylinder::
Length () const
{
  return this->Length_;
}

GeomCylinder::Length_optional& GeomCylinder::
Length ()
{
  return this->Length_;
}

void GeomCylinder::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void GeomCylinder::
Length (const Length_optional& x)
{
  this->Length_ = x;
}

const GeomCylinder::Radius_optional& GeomCylinder::
Radius () const
{
  return this->Radius_;
}

GeomCylinder::Radius_optional& GeomCylinder::
Radius ()
{
  return this->Radius_;
}

void GeomCylinder::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomCylinder::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomCapsule
// 

const GeomCapsule::Length_optional& GeomCapsule::
Length () const
{
  return this->Length_;
}

GeomCapsule::Length_optional& GeomCapsule::
Length ()
{
  return this->Length_;
}

void GeomCapsule::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void GeomCapsule::
Length (const Length_optional& x)
{
  this->Length_ = x;
}

const GeomCapsule::Radius_optional& GeomCapsule::
Radius () const
{
  return this->Radius_;
}

GeomCapsule::Radius_optional& GeomCapsule::
Radius ()
{
  return this->Radius_;
}

void GeomCapsule::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomCapsule::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomSphere
// 

const GeomSphere::Radius_optional& GeomSphere::
Radius () const
{
  return this->Radius_;
}

GeomSphere::Radius_optional& GeomSphere::
Radius ()
{
  return this->Radius_;
}

void GeomSphere::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomSphere::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomPlane
// 

const GeomPlane::Space_optional& GeomPlane::
Space () const
{
  return this->Space_;
}

GeomPlane::Space_optional& GeomPlane::
Space ()
{
  return this->Space_;
}

void GeomPlane::
Space (const Space_type& x)
{
  this->Space_.set (x);
}

void GeomPlane::
Space (const Space_optional& x)
{
  this->Space_ = x;
}

void GeomPlane::
Space (::std::auto_ptr< Space_type > x)
{
  this->Space_.set (x);
}

const GeomPlane::Body_optional& GeomPlane::
Body () const
{
  return this->Body_;
}

GeomPlane::Body_optional& GeomPlane::
Body ()
{
  return this->Body_;
}

void GeomPlane::
Body (const Body_type& x)
{
  this->Body_.set (x);
}

void GeomPlane::
Body (const Body_optional& x)
{
  this->Body_ = x;
}

void GeomPlane::
Body (::std::auto_ptr< Body_type > x)
{
  this->Body_.set (x);
}

const GeomPlane::Enabled_optional& GeomPlane::
Enabled () const
{
  return this->Enabled_;
}

GeomPlane::Enabled_optional& GeomPlane::
Enabled ()
{
  return this->Enabled_;
}

void GeomPlane::
Enabled (const Enabled_type& x)
{
  this->Enabled_.set (x);
}

void GeomPlane::
Enabled (const Enabled_optional& x)
{
  this->Enabled_ = x;
}


// Rotation
// 

const Rotation::Column1_type& Rotation::
Column1 () const
{
  return this->Column1_.get ();
}

Rotation::Column1_type& Rotation::
Column1 ()
{
  return this->Column1_.get ();
}

void Rotation::
Column1 (const Column1_type& x)
{
  this->Column1_.set (x);
}

void Rotation::
Column1 (::std::auto_ptr< Column1_type > x)
{
  this->Column1_.set (x);
}

const Rotation::Column2_type& Rotation::
Column2 () const
{
  return this->Column2_.get ();
}

Rotation::Column2_type& Rotation::
Column2 ()
{
  return this->Column2_.get ();
}

void Rotation::
Column2 (const Column2_type& x)
{
  this->Column2_.set (x);
}

void Rotation::
Column2 (::std::auto_ptr< Column2_type > x)
{
  this->Column2_.set (x);
}

const Rotation::Column3_type& Rotation::
Column3 () const
{
  return this->Column3_.get ();
}

Rotation::Column3_type& Rotation::
Column3 ()
{
  return this->Column3_.get ();
}

void Rotation::
Column3 (const Column3_type& x)
{
  this->Column3_.set (x);
}

void Rotation::
Column3 (::std::auto_ptr< Column3_type > x)
{
  this->Column3_.set (x);
}


// Vector
// 

const Vector::X_optional& Vector::
X () const
{
  return this->X_;
}

Vector::X_optional& Vector::
X ()
{
  return this->X_;
}

void Vector::
X (const X_type& x)
{
  this->X_.set (x);
}

void Vector::
X (const X_optional& x)
{
  this->X_ = x;
}

const Vector::Y_optional& Vector::
Y () const
{
  return this->Y_;
}

Vector::Y_optional& Vector::
Y ()
{
  return this->Y_;
}

void Vector::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void Vector::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

const Vector::Z_optional& Vector::
Z () const
{
  return this->Z_;
}

Vector::Z_optional& Vector::
Z ()
{
  return this->Z_;
}

void Vector::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void Vector::
Z (const Z_optional& x)
{
  this->Z_ = x;
}


// Quaternion
// 

const Quaternion::W_optional& Quaternion::
W () const
{
  return this->W_;
}

Quaternion::W_optional& Quaternion::
W ()
{
  return this->W_;
}

void Quaternion::
W (const W_type& x)
{
  this->W_.set (x);
}

void Quaternion::
W (const W_optional& x)
{
  this->W_ = x;
}

const Quaternion::I_optional& Quaternion::
I () const
{
  return this->I_;
}

Quaternion::I_optional& Quaternion::
I ()
{
  return this->I_;
}

void Quaternion::
I (const I_type& x)
{
  this->I_.set (x);
}

void Quaternion::
I (const I_optional& x)
{
  this->I_ = x;
}

const Quaternion::J_optional& Quaternion::
J () const
{
  return this->J_;
}

Quaternion::J_optional& Quaternion::
J ()
{
  return this->J_;
}

void Quaternion::
J (const J_type& x)
{
  this->J_.set (x);
}

void Quaternion::
J (const J_optional& x)
{
  this->J_ = x;
}

const Quaternion::K_optional& Quaternion::
K () const
{
  return this->K_;
}

Quaternion::K_optional& Quaternion::
K ()
{
  return this->K_;
}

void Quaternion::
K (const K_type& x)
{
  this->K_.set (x);
}

void Quaternion::
K (const K_optional& x)
{
  this->K_ = x;
}


// Foo
// 


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// RSObject
//

RSObject::
RSObject ()
: ::xml_schema::type (),
  Name_ (::xml_schema::flags (), this)
{
}

RSObject::
RSObject (const RSObject& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

RSObject::
RSObject (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RSObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Name",
          "",
          &::xsd::cxx::tree::factory_impl< Name_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Name_)
        {
          ::std::auto_ptr< Name_type > r (
            dynamic_cast< Name_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Name_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

RSObject* RSObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RSObject (*this, f, c);
}

RSObject::
~RSObject ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RSObject >
_xsd_RSObject_type_factory_init (
  "RSObject",
  "");

// Sim
//

Sim::
Sim ()
: ::RSObject (),
  World_ (::xml_schema::flags (), this),
  Space_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this),
  Geom_ (::xml_schema::flags (), this)
{
}

Sim::
Sim (const Sim& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (x, f, c),
  World_ (x.World_, f, this),
  Space_ (x.Space_, f, this),
  Body_ (x.Body_, f, this),
  Geom_ (x.Geom_, f, this)
{
}

Sim::
Sim (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  World_ (f, this),
  Space_ (f, this),
  Body_ (f, this),
  Geom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Sim::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // World
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "World",
          "",
          &::xsd::cxx::tree::factory_impl< World_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< World_type > r (
          dynamic_cast< World_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->World_.push_back (r);
        continue;
      }
    }

    // Space
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Space",
          "",
          &::xsd::cxx::tree::factory_impl< Space_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Space_type > r (
          dynamic_cast< Space_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Space_.push_back (r);
        continue;
      }
    }

    // Body
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body",
          "",
          &::xsd::cxx::tree::factory_impl< Body_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Body_type > r (
          dynamic_cast< Body_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Body_.push_back (r);
        continue;
      }
    }

    // Geom
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Geom",
          "",
          &::xsd::cxx::tree::factory_impl< Geom_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Geom_type > r (
          dynamic_cast< Geom_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Geom_.push_back (r);
        continue;
      }
    }

    break;
  }
}

Sim* Sim::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sim (*this, f, c);
}

Sim::
~Sim ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Sim >
_xsd_Sim_type_factory_init (
  "Sim",
  "");

// World
//

World::
World ()
: ::RSObject (),
  AutoDisableAngularThreshold_ (::xml_schema::flags (), this),
  AutoDisableFlag_ (::xml_schema::flags (), this),
  AutoDisableSteps_ (::xml_schema::flags (), this),
  AutoDisableTime_ (::xml_schema::flags (), this),
  CFM_ (::xml_schema::flags (), this),
  ContactMaxCorrectingVel_ (::xml_schema::flags (), this),
  ContactSurfaceLayer_ (::xml_schema::flags (), this),
  ERP_ (::xml_schema::flags (), this),
  Gravity_ (::xml_schema::flags (), this),
  QuickStepNumIterations_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this)
{
}

World::
World (const World& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (x, f, c),
  AutoDisableAngularThreshold_ (x.AutoDisableAngularThreshold_, f, this),
  AutoDisableFlag_ (x.AutoDisableFlag_, f, this),
  AutoDisableSteps_ (x.AutoDisableSteps_, f, this),
  AutoDisableTime_ (x.AutoDisableTime_, f, this),
  CFM_ (x.CFM_, f, this),
  ContactMaxCorrectingVel_ (x.ContactMaxCorrectingVel_, f, this),
  ContactSurfaceLayer_ (x.ContactSurfaceLayer_, f, this),
  ERP_ (x.ERP_, f, this),
  Gravity_ (x.Gravity_, f, this),
  QuickStepNumIterations_ (x.QuickStepNumIterations_, f, this),
  Body_ (x.Body_, f, this)
{
}

World::
World (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  AutoDisableAngularThreshold_ (f, this),
  AutoDisableFlag_ (f, this),
  AutoDisableSteps_ (f, this),
  AutoDisableTime_ (f, this),
  CFM_ (f, this),
  ContactMaxCorrectingVel_ (f, this),
  ContactSurfaceLayer_ (f, this),
  ERP_ (f, this),
  Gravity_ (f, this),
  QuickStepNumIterations_ (f, this),
  Body_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void World::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AutoDisableAngularThreshold
    //
    if (n.name () == "AutoDisableAngularThreshold" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableAngularThreshold_)
      {
        this->AutoDisableAngularThreshold_.set (AutoDisableAngularThreshold_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableFlag
    //
    if (n.name () == "AutoDisableFlag" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableFlag_)
      {
        this->AutoDisableFlag_.set (AutoDisableFlag_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableSteps
    //
    if (n.name () == "AutoDisableSteps" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableSteps_)
      {
        this->AutoDisableSteps_.set (AutoDisableSteps_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableTime
    //
    if (n.name () == "AutoDisableTime" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableTime_)
      {
        this->AutoDisableTime_.set (AutoDisableTime_traits::create (i, f, this));
        continue;
      }
    }

    // CFM
    //
    if (n.name () == "CFM" && n.namespace_ ().empty ())
    {
      if (!this->CFM_)
      {
        this->CFM_.set (CFM_traits::create (i, f, this));
        continue;
      }
    }

    // ContactMaxCorrectingVel
    //
    if (n.name () == "ContactMaxCorrectingVel" && n.namespace_ ().empty ())
    {
      if (!this->ContactMaxCorrectingVel_)
      {
        this->ContactMaxCorrectingVel_.set (ContactMaxCorrectingVel_traits::create (i, f, this));
        continue;
      }
    }

    // ContactSurfaceLayer
    //
    if (n.name () == "ContactSurfaceLayer" && n.namespace_ ().empty ())
    {
      if (!this->ContactSurfaceLayer_)
      {
        this->ContactSurfaceLayer_.set (ContactSurfaceLayer_traits::create (i, f, this));
        continue;
      }
    }

    // ERP
    //
    if (n.name () == "ERP" && n.namespace_ ().empty ())
    {
      if (!this->ERP_)
      {
        this->ERP_.set (ERP_traits::create (i, f, this));
        continue;
      }
    }

    // Gravity
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Gravity",
          "",
          &::xsd::cxx::tree::factory_impl< Gravity_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Gravity_)
        {
          ::std::auto_ptr< Gravity_type > r (
            dynamic_cast< Gravity_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Gravity_.set (r);
          continue;
        }
      }
    }

    // QuickStepNumIterations
    //
    if (n.name () == "QuickStepNumIterations" && n.namespace_ ().empty ())
    {
      if (!this->QuickStepNumIterations_)
      {
        this->QuickStepNumIterations_.set (QuickStepNumIterations_traits::create (i, f, this));
        continue;
      }
    }

    // Body
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body",
          "",
          &::xsd::cxx::tree::factory_impl< Body_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Body_type > r (
          dynamic_cast< Body_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Body_.push_back (r);
        continue;
      }
    }

    break;
  }
}

World* World::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class World (*this, f, c);
}

World::
~World ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, World >
_xsd_World_type_factory_init (
  "World",
  "");

// GeomObject
//

GeomObject::
GeomObject ()
: ::RSObject (),
  Enable_ (::xml_schema::flags (), this),
  CategoryBits_ (::xml_schema::flags (), this),
  CollideBits_ (::xml_schema::flags (), this),
  Position_ (::xml_schema::flags (), this),
  Quaternion_ (::xml_schema::flags (), this),
  Rotation_ (::xml_schema::flags (), this)
{
}

GeomObject::
GeomObject (const GeomObject& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Enable_ (x.Enable_, f, this),
  CategoryBits_ (x.CategoryBits_, f, this),
  CollideBits_ (x.CollideBits_, f, this),
  Position_ (x.Position_, f, this),
  Quaternion_ (x.Quaternion_, f, this),
  Rotation_ (x.Rotation_, f, this)
{
}

GeomObject::
GeomObject (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Enable_ (f, this),
  CategoryBits_ (f, this),
  CollideBits_ (f, this),
  Position_ (f, this),
  Quaternion_ (f, this),
  Rotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Enable
    //
    if (n.name () == "Enable" && n.namespace_ ().empty ())
    {
      if (!this->Enable_)
      {
        this->Enable_.set (Enable_traits::create (i, f, this));
        continue;
      }
    }

    // CategoryBits
    //
    if (n.name () == "CategoryBits" && n.namespace_ ().empty ())
    {
      if (!this->CategoryBits_)
      {
        this->CategoryBits_.set (CategoryBits_traits::create (i, f, this));
        continue;
      }
    }

    // CollideBits
    //
    if (n.name () == "CollideBits" && n.namespace_ ().empty ())
    {
      if (!this->CollideBits_)
      {
        this->CollideBits_.set (CollideBits_traits::create (i, f, this));
        continue;
      }
    }

    // Position
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Position",
          "",
          &::xsd::cxx::tree::factory_impl< Position_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Position_)
        {
          ::std::auto_ptr< Position_type > r (
            dynamic_cast< Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Position_.set (r);
          continue;
        }
      }
    }

    // Quaternion
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Quaternion",
          "",
          &::xsd::cxx::tree::factory_impl< Quaternion_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Quaternion_)
        {
          ::std::auto_ptr< Quaternion_type > r (
            dynamic_cast< Quaternion_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Quaternion_.set (r);
          continue;
        }
      }
    }

    // Rotation
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Rotation",
          "",
          &::xsd::cxx::tree::factory_impl< Rotation_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Rotation_)
        {
          ::std::auto_ptr< Rotation_type > r (
            dynamic_cast< Rotation_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Rotation_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

GeomObject* GeomObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomObject (*this, f, c);
}

GeomObject::
~GeomObject ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomObject >
_xsd_GeomObject_type_factory_init (
  "GeomObject",
  "");

// SpaceBase
//

SpaceBase::
SpaceBase ()
: ::GeomObject (),
  Geom_ (::xml_schema::flags (), this)
{
}

SpaceBase::
SpaceBase (const SpaceBase& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Geom_ (x.Geom_, f, this)
{
}

SpaceBase::
SpaceBase (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Geom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void SpaceBase::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Geom
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Geom",
          "",
          &::xsd::cxx::tree::factory_impl< Geom_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Geom_type > r (
          dynamic_cast< Geom_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Geom_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SpaceBase* SpaceBase::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SpaceBase (*this, f, c);
}

SpaceBase::
~SpaceBase ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SpaceBase >
_xsd_SpaceBase_type_factory_init (
  "SpaceBase",
  "");

// SimpleSpace
//

SimpleSpace::
SimpleSpace ()
: ::SpaceBase ()
{
}

SimpleSpace::
SimpleSpace (const SimpleSpace& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SpaceBase (x, f, c)
{
}

SimpleSpace::
SimpleSpace (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SpaceBase (e, f, c)
{
}

SimpleSpace* SimpleSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimpleSpace (*this, f, c);
}

SimpleSpace::
~SimpleSpace ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SimpleSpace >
_xsd_SimpleSpace_type_factory_init (
  "SimpleSpace",
  "");

// Body
//

Body::
Body ()
: ::RSObject (),
  Space_ (::xml_schema::flags (), this),
  World_ (::xml_schema::flags (), this),
  Enabled_ (::xml_schema::flags (), this),
  AngularVel_ (::xml_schema::flags (), this),
  FiniteRotationAxis_ (::xml_schema::flags (), this),
  FiniteRotationMode_ (::xml_schema::flags (), this),
  Force_ (::xml_schema::flags (), this),
  GravityMode_ (::xml_schema::flags (), this),
  LinearVel_ (::xml_schema::flags (), this),
  Mass_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this),
  Position_ (::xml_schema::flags (), this),
  Quaternion_ (::xml_schema::flags (), this),
  Rotation_ (::xml_schema::flags (), this)
{
}

Body::
Body (const Body& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Space_ (x.Space_, f, this),
  World_ (x.World_, f, this),
  Enabled_ (x.Enabled_, f, this),
  AngularVel_ (x.AngularVel_, f, this),
  FiniteRotationAxis_ (x.FiniteRotationAxis_, f, this),
  FiniteRotationMode_ (x.FiniteRotationMode_, f, this),
  Force_ (x.Force_, f, this),
  GravityMode_ (x.GravityMode_, f, this),
  LinearVel_ (x.LinearVel_, f, this),
  Mass_ (x.Mass_, f, this),
  Torque_ (x.Torque_, f, this),
  Position_ (x.Position_, f, this),
  Quaternion_ (x.Quaternion_, f, this),
  Rotation_ (x.Rotation_, f, this)
{
}

Body::
Body (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Space_ (f, this),
  World_ (f, this),
  Enabled_ (f, this),
  AngularVel_ (f, this),
  FiniteRotationAxis_ (f, this),
  FiniteRotationMode_ (f, this),
  Force_ (f, this),
  GravityMode_ (f, this),
  LinearVel_ (f, this),
  Mass_ (f, this),
  Torque_ (f, this),
  Position_ (f, this),
  Quaternion_ (f, this),
  Rotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Space
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Space",
          "",
          &::xsd::cxx::tree::factory_impl< Space_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Space_)
        {
          ::std::auto_ptr< Space_type > r (
            dynamic_cast< Space_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Space_.set (r);
          continue;
        }
      }
    }

    // World
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "World",
          "",
          &::xsd::cxx::tree::factory_impl< World_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->World_)
        {
          ::std::auto_ptr< World_type > r (
            dynamic_cast< World_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->World_.set (r);
          continue;
        }
      }
    }

    // Enabled
    //
    if (n.name () == "Enabled" && n.namespace_ ().empty ())
    {
      if (!this->Enabled_)
      {
        this->Enabled_.set (Enabled_traits::create (i, f, this));
        continue;
      }
    }

    // AngularVel
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "AngularVel",
          "",
          &::xsd::cxx::tree::factory_impl< AngularVel_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->AngularVel_)
        {
          ::std::auto_ptr< AngularVel_type > r (
            dynamic_cast< AngularVel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AngularVel_.set (r);
          continue;
        }
      }
    }

    // FiniteRotationAxis
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "FiniteRotationAxis",
          "",
          &::xsd::cxx::tree::factory_impl< FiniteRotationAxis_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->FiniteRotationAxis_)
        {
          ::std::auto_ptr< FiniteRotationAxis_type > r (
            dynamic_cast< FiniteRotationAxis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->FiniteRotationAxis_.set (r);
          continue;
        }
      }
    }

    // FiniteRotationMode
    //
    if (n.name () == "FiniteRotationMode" && n.namespace_ ().empty ())
    {
      if (!this->FiniteRotationMode_)
      {
        this->FiniteRotationMode_.set (FiniteRotationMode_traits::create (i, f, this));
        continue;
      }
    }

    // Force
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Force",
          "",
          &::xsd::cxx::tree::factory_impl< Force_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Force_)
        {
          ::std::auto_ptr< Force_type > r (
            dynamic_cast< Force_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Force_.set (r);
          continue;
        }
      }
    }

    // GravityMode
    //
    if (n.name () == "GravityMode" && n.namespace_ ().empty ())
    {
      if (!this->GravityMode_)
      {
        this->GravityMode_.set (GravityMode_traits::create (i, f, this));
        continue;
      }
    }

    // LinearVel
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "LinearVel",
          "",
          &::xsd::cxx::tree::factory_impl< LinearVel_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->LinearVel_)
        {
          ::std::auto_ptr< LinearVel_type > r (
            dynamic_cast< LinearVel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->LinearVel_.set (r);
          continue;
        }
      }
    }

    // Mass
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Mass",
          "",
          &::xsd::cxx::tree::factory_impl< Mass_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Mass_)
        {
          ::std::auto_ptr< Mass_type > r (
            dynamic_cast< Mass_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Mass_.set (r);
          continue;
        }
      }
    }

    // Torque
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Torque",
          "",
          &::xsd::cxx::tree::factory_impl< Torque_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Torque_)
        {
          ::std::auto_ptr< Torque_type > r (
            dynamic_cast< Torque_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Torque_.set (r);
          continue;
        }
      }
    }

    // Position
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Position",
          "",
          &::xsd::cxx::tree::factory_impl< Position_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Position_)
        {
          ::std::auto_ptr< Position_type > r (
            dynamic_cast< Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Position_.set (r);
          continue;
        }
      }
    }

    // Quaternion
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Quaternion",
          "",
          &::xsd::cxx::tree::factory_impl< Quaternion_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Quaternion_)
        {
          ::std::auto_ptr< Quaternion_type > r (
            dynamic_cast< Quaternion_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Quaternion_.set (r);
          continue;
        }
      }
    }

    // Rotation
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Rotation",
          "",
          &::xsd::cxx::tree::factory_impl< Rotation_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Rotation_)
        {
          ::std::auto_ptr< Rotation_type > r (
            dynamic_cast< Rotation_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Rotation_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

Body* Body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Body (*this, f, c);
}

Body::
~Body ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Body >
_xsd_Body_type_factory_init (
  "Body",
  "");

// Mass
//

Mass::
Mass ()
: ::RSObject ()
{
}

Mass::
Mass (const Mass& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (x, f, c)
{
}

Mass::
Mass (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (e, f, c)
{
}

Mass* Mass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Mass (*this, f, c);
}

Mass::
~Mass ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Mass >
_xsd_Mass_type_factory_init (
  "Mass",
  "");

// BoxTotalMass
//

BoxTotalMass::
BoxTotalMass (const TotalMass_type& TotalMass,
              const LX_type& LX,
              const LY_type& LY,
              const LZ_type& LZ)
: ::Mass (),
  TotalMass_ (TotalMass, ::xml_schema::flags (), this),
  LX_ (LX, ::xml_schema::flags (), this),
  LY_ (LY, ::xml_schema::flags (), this),
  LZ_ (LZ, ::xml_schema::flags (), this)
{
}

BoxTotalMass::
BoxTotalMass (const BoxTotalMass& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Mass (x, f, c),
  TotalMass_ (x.TotalMass_, f, this),
  LX_ (x.LX_, f, this),
  LY_ (x.LY_, f, this),
  LZ_ (x.LZ_, f, this)
{
}

BoxTotalMass::
BoxTotalMass (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Mass (e, f | ::xml_schema::flags::base, c),
  TotalMass_ (f, this),
  LX_ (f, this),
  LY_ (f, this),
  LZ_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void BoxTotalMass::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Mass::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TotalMass
    //
    if (n.name () == "TotalMass" && n.namespace_ ().empty ())
    {
      if (!TotalMass_.present ())
      {
        this->TotalMass_.set (TotalMass_traits::create (i, f, this));
        continue;
      }
    }

    // LX
    //
    if (n.name () == "LX" && n.namespace_ ().empty ())
    {
      if (!LX_.present ())
      {
        this->LX_.set (LX_traits::create (i, f, this));
        continue;
      }
    }

    // LY
    //
    if (n.name () == "LY" && n.namespace_ ().empty ())
    {
      if (!LY_.present ())
      {
        this->LY_.set (LY_traits::create (i, f, this));
        continue;
      }
    }

    // LZ
    //
    if (n.name () == "LZ" && n.namespace_ ().empty ())
    {
      if (!LZ_.present ())
      {
        this->LZ_.set (LZ_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!TotalMass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TotalMass",
      "");
  }

  if (!LX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LX",
      "");
  }

  if (!LY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LY",
      "");
  }

  if (!LZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LZ",
      "");
  }
}

BoxTotalMass* BoxTotalMass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoxTotalMass (*this, f, c);
}

BoxTotalMass::
~BoxTotalMass ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, BoxTotalMass >
_xsd_BoxTotalMass_type_factory_init (
  "BoxTotalMass",
  "");

// Joint
//

Joint::
Joint ()
: ::RSObject (),
  Feedback_ (::xml_schema::flags (), this),
  Body1_ (::xml_schema::flags (), this),
  Body2_ (::xml_schema::flags (), this)
{
}

Joint::
Joint (const Joint& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Feedback_ (x.Feedback_, f, this),
  Body1_ (x.Body1_, f, this),
  Body2_ (x.Body2_, f, this)
{
}

Joint::
Joint (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Feedback_ (f, this),
  Body1_ (f, this),
  Body2_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Joint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Feedback
    //
    if (n.name () == "Feedback" && n.namespace_ ().empty ())
    {
      if (!this->Feedback_)
      {
        this->Feedback_.set (Feedback_traits::create (i, f, this));
        continue;
      }
    }

    // Body1
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body1",
          "",
          &::xsd::cxx::tree::factory_impl< Body1_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Body1_)
        {
          ::std::auto_ptr< Body1_type > r (
            dynamic_cast< Body1_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Body1_.set (r);
          continue;
        }
      }
    }

    // Body2
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body2",
          "",
          &::xsd::cxx::tree::factory_impl< Body2_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Body2_)
        {
          ::std::auto_ptr< Body2_type > r (
            dynamic_cast< Body2_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Body2_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

Joint* Joint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Joint (*this, f, c);
}

Joint::
~Joint ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Joint >
_xsd_Joint_type_factory_init (
  "Joint",
  "");

// HingeJoint
//

HingeJoint::
HingeJoint ()
: ::Joint (),
  Anchor_ (::xml_schema::flags (), this),
  Axis_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this)
{
}

HingeJoint::
HingeJoint (const HingeJoint& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Joint (x, f, c),
  Anchor_ (x.Anchor_, f, this),
  Axis_ (x.Axis_, f, this),
  Torque_ (x.Torque_, f, this)
{
}

HingeJoint::
HingeJoint (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Joint (e, f | ::xml_schema::flags::base, c),
  Anchor_ (f, this),
  Axis_ (f, this),
  Torque_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void HingeJoint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Joint::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Anchor
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Anchor",
          "",
          &::xsd::cxx::tree::factory_impl< Anchor_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Anchor_)
        {
          ::std::auto_ptr< Anchor_type > r (
            dynamic_cast< Anchor_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Anchor_.set (r);
          continue;
        }
      }
    }

    // Axis
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Axis",
          "",
          &::xsd::cxx::tree::factory_impl< Axis_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Axis_)
        {
          ::std::auto_ptr< Axis_type > r (
            dynamic_cast< Axis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Axis_.set (r);
          continue;
        }
      }
    }

    // Torque
    //
    if (n.name () == "Torque" && n.namespace_ ().empty ())
    {
      if (!this->Torque_)
      {
        this->Torque_.set (Torque_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

HingeJoint* HingeJoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HingeJoint (*this, f, c);
}

HingeJoint::
~HingeJoint ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, HingeJoint >
_xsd_HingeJoint_type_factory_init (
  "HingeJoint",
  "");

// GeomBox
//

GeomBox::
GeomBox ()
: ::GeomObject (),
  Lengths_ (::xml_schema::flags (), this)
{
}

GeomBox::
GeomBox (const GeomBox& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Lengths_ (x.Lengths_, f, this)
{
}

GeomBox::
GeomBox (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Lengths_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomBox::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Lengths
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Lengths",
          "",
          &::xsd::cxx::tree::factory_impl< Lengths_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Lengths_)
        {
          ::std::auto_ptr< Lengths_type > r (
            dynamic_cast< Lengths_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Lengths_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

GeomBox* GeomBox::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomBox (*this, f, c);
}

GeomBox::
~GeomBox ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomBox >
_xsd_GeomBox_type_factory_init (
  "GeomBox",
  "");

// GeomCylinder
//

GeomCylinder::
GeomCylinder ()
: ::GeomObject (),
  Length_ (::xml_schema::flags (), this),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomCylinder::
GeomCylinder (const GeomCylinder& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Length_ (x.Length_, f, this),
  Radius_ (x.Radius_, f, this)
{
}

GeomCylinder::
GeomCylinder (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Length_ (f, this),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomCylinder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Length
    //
    if (n.name () == "Length" && n.namespace_ ().empty ())
    {
      if (!this->Length_)
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }
    }

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomCylinder* GeomCylinder::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomCylinder (*this, f, c);
}

GeomCylinder::
~GeomCylinder ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomCylinder >
_xsd_GeomCylinder_type_factory_init (
  "GeomCylinder",
  "");

// GeomCapsule
//

GeomCapsule::
GeomCapsule ()
: ::GeomObject (),
  Length_ (::xml_schema::flags (), this),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomCapsule::
GeomCapsule (const GeomCapsule& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Length_ (x.Length_, f, this),
  Radius_ (x.Radius_, f, this)
{
}

GeomCapsule::
GeomCapsule (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Length_ (f, this),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomCapsule::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Length
    //
    if (n.name () == "Length" && n.namespace_ ().empty ())
    {
      if (!this->Length_)
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }
    }

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomCapsule* GeomCapsule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomCapsule (*this, f, c);
}

GeomCapsule::
~GeomCapsule ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomCapsule >
_xsd_GeomCapsule_type_factory_init (
  "GeomCapsule",
  "");

// GeomSphere
//

GeomSphere::
GeomSphere ()
: ::GeomObject (),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomSphere::
GeomSphere (const GeomSphere& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Radius_ (x.Radius_, f, this)
{
}

GeomSphere::
GeomSphere (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomSphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomSphere* GeomSphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomSphere (*this, f, c);
}

GeomSphere::
~GeomSphere ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomSphere >
_xsd_GeomSphere_type_factory_init (
  "GeomSphere",
  "");

// GeomPlane
//

GeomPlane::
GeomPlane ()
: ::GeomObject (),
  Space_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this),
  Enabled_ (::xml_schema::flags (), this)
{
}

GeomPlane::
GeomPlane (const GeomPlane& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Space_ (x.Space_, f, this),
  Body_ (x.Body_, f, this),
  Enabled_ (x.Enabled_, f, this)
{
}

GeomPlane::
GeomPlane (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Space_ (f, this),
  Body_ (f, this),
  Enabled_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomPlane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Space
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Space",
          "",
          &::xsd::cxx::tree::factory_impl< Space_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Space_)
        {
          ::std::auto_ptr< Space_type > r (
            dynamic_cast< Space_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Space_.set (r);
          continue;
        }
      }
    }

    // Body
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body",
          "",
          &::xsd::cxx::tree::factory_impl< Body_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Body_)
        {
          ::std::auto_ptr< Body_type > r (
            dynamic_cast< Body_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Body_.set (r);
          continue;
        }
      }
    }

    // Enabled
    //
    if (n.name () == "Enabled" && n.namespace_ ().empty ())
    {
      if (!this->Enabled_)
      {
        this->Enabled_.set (Enabled_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomPlane* GeomPlane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomPlane (*this, f, c);
}

GeomPlane::
~GeomPlane ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomPlane >
_xsd_GeomPlane_type_factory_init (
  "GeomPlane",
  "");

// Rotation
//

Rotation::
Rotation (const Column1_type& Column1,
          const Column2_type& Column2,
          const Column3_type& Column3)
: ::RSObject (),
  Column1_ (Column1, ::xml_schema::flags (), this),
  Column2_ (Column2, ::xml_schema::flags (), this),
  Column3_ (Column3, ::xml_schema::flags (), this)
{
}

Rotation::
Rotation (::std::auto_ptr< Column1_type >& Column1,
          ::std::auto_ptr< Column2_type >& Column2,
          ::std::auto_ptr< Column3_type >& Column3)
: ::RSObject (),
  Column1_ (Column1, ::xml_schema::flags (), this),
  Column2_ (Column2, ::xml_schema::flags (), this),
  Column3_ (Column3, ::xml_schema::flags (), this)
{
}

Rotation::
Rotation (const Rotation& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Column1_ (x.Column1_, f, this),
  Column2_ (x.Column2_, f, this),
  Column3_ (x.Column3_, f, this)
{
}

Rotation::
Rotation (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Column1_ (f, this),
  Column2_ (f, this),
  Column3_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Rotation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Column1
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Column1",
          "",
          &::xsd::cxx::tree::factory_impl< Column1_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Column1_.present ())
        {
          ::std::auto_ptr< Column1_type > r (
            dynamic_cast< Column1_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Column1_.set (r);
          continue;
        }
      }
    }

    // Column2
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Column2",
          "",
          &::xsd::cxx::tree::factory_impl< Column2_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Column2_.present ())
        {
          ::std::auto_ptr< Column2_type > r (
            dynamic_cast< Column2_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Column2_.set (r);
          continue;
        }
      }
    }

    // Column3
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Column3",
          "",
          &::xsd::cxx::tree::factory_impl< Column3_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Column3_.present ())
        {
          ::std::auto_ptr< Column3_type > r (
            dynamic_cast< Column3_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Column3_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Column1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column1",
      "");
  }

  if (!Column2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column2",
      "");
  }

  if (!Column3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column3",
      "");
  }
}

Rotation* Rotation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Rotation (*this, f, c);
}

Rotation::
~Rotation ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Rotation >
_xsd_Rotation_type_factory_init (
  "Rotation",
  "");

// Vector
//

Vector::
Vector ()
: ::xml_schema::type (),
  X_ (::xml_schema::flags (), this),
  Y_ (::xml_schema::flags (), this),
  Z_ (::xml_schema::flags (), this)
{
}

Vector::
Vector (const Vector& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

Vector::
Vector (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (f, this),
  Y_ (f, this),
  Z_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }
  }
}

Vector* Vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vector (*this, f, c);
}

Vector::
~Vector ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Vector >
_xsd_Vector_type_factory_init (
  "Vector",
  "");

// Quaternion
//

Quaternion::
Quaternion ()
: ::xml_schema::type (),
  W_ (::xml_schema::flags (), this),
  I_ (::xml_schema::flags (), this),
  J_ (::xml_schema::flags (), this),
  K_ (::xml_schema::flags (), this)
{
}

Quaternion::
Quaternion (const Quaternion& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  W_ (x.W_, f, this),
  I_ (x.I_, f, this),
  J_ (x.J_, f, this),
  K_ (x.K_, f, this)
{
}

Quaternion::
Quaternion (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  W_ (f, this),
  I_ (f, this),
  J_ (f, this),
  K_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Quaternion::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "W" && n.namespace_ ().empty ())
    {
      this->W_.set (W_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "I" && n.namespace_ ().empty ())
    {
      this->I_.set (I_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "J" && n.namespace_ ().empty ())
    {
      this->J_.set (J_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "K" && n.namespace_ ().empty ())
    {
      this->K_.set (K_traits::create (i, f, this));
      continue;
    }
  }
}

Quaternion* Quaternion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Quaternion (*this, f, c);
}

Quaternion::
~Quaternion ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Quaternion >
_xsd_Quaternion_type_factory_init (
  "Quaternion",
  "");

// Foo
//

Foo::
Foo ()
: ::RSObject ()
{
}

Foo::
Foo (const Foo& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (x, f, c)
{
}

Foo::
Foo (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (e, f, c)
{
}

Foo* Foo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Foo (*this, f, c);
}

Foo::
~Foo ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Foo >
_xsd_Foo_type_factory_init (
  "Foo",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Sim > r (
      ::Sim_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Sim",
      "",
      &::xsd::cxx::tree::factory_impl< ::Sim >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Sim > r (
      dynamic_cast< ::Sim* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Sim",
    "");
}

::std::auto_ptr< ::Sim >
Sim_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Sim",
      "",
      &::xsd::cxx::tree::factory_impl< ::Sim >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Sim > r (
      dynamic_cast< ::Sim* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Sim",
    "");
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::World > r (
      ::World_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "World",
      "",
      &::xsd::cxx::tree::factory_impl< ::World >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::World > r (
      dynamic_cast< ::World* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "World",
    "");
}

::std::auto_ptr< ::World >
World_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "World",
      "",
      &::xsd::cxx::tree::factory_impl< ::World >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::World > r (
      dynamic_cast< ::World* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "World",
    "");
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Body > r (
      ::Body_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Body",
      "",
      &::xsd::cxx::tree::factory_impl< ::Body >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Body > r (
      dynamic_cast< ::Body* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Body",
    "");
}

::std::auto_ptr< ::Body >
Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Body",
      "",
      &::xsd::cxx::tree::factory_impl< ::Body >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Body > r (
      dynamic_cast< ::Body* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Body",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const RSObject& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Name ())
    {
      const RSObject::Name_type& x (*i.Name ());
      if (typeid (RSObject::Name_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Name",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RSObject >
_xsd_RSObject_type_serializer_init (
  "RSObject",
  "");


void
operator<< (::xercesc::DOMElement& e, const Sim& i)
{
  e << static_cast< const ::RSObject& > (i);

  // World
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::World_const_iterator
         b (i.World ().begin ()), n (i.World ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::World_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "World",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "World",
          "",
          false, false, e, *b);
    }
  }

  // Space
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::Space_const_iterator
         b (i.Space ().begin ()), n (i.Space ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::Space_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Space",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Space",
          "",
          false, false, e, *b);
    }
  }

  // Body
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::Body_const_iterator
         b (i.Body ().begin ()), n (i.Body ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::Body_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Body",
          "",
          false, false, e, *b);
    }
  }

  // Geom
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::Geom_const_iterator
         b (i.Geom ().begin ()), n (i.Geom ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::Geom_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Geom",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Geom",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Sim >
_xsd_Sim_type_serializer_init (
  "Sim",
  "");


void
Sim_ (::std::ostream& o,
      const ::Sim& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Sim_ (::std::ostream& o,
      const ::Sim& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::std::ostream& o,
      const ::Sim& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::xercesc::XMLFormatTarget& t,
      const ::Sim& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Sim_ (::xercesc::XMLFormatTarget& t,
      const ::Sim& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::xercesc::XMLFormatTarget& t,
      const ::Sim& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::xercesc::DOMDocument& d,
      const ::Sim& s,
      ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Sim) == typeid (s))
  {
    if (n.name () == "Sim" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sim",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Sim",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Sim_ (const ::Sim& s,
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Sim) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Sim",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Sim",
        "",
        m, s, f));
    d = r;
  }

  ::Sim_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const World& i)
{
  e << static_cast< const ::RSObject& > (i);

  // AutoDisableAngularThreshold
  //
  if (i.AutoDisableAngularThreshold ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableAngularThreshold",
        e));

    s << *i.AutoDisableAngularThreshold ();
  }

  // AutoDisableFlag
  //
  if (i.AutoDisableFlag ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableFlag",
        e));

    s << *i.AutoDisableFlag ();
  }

  // AutoDisableSteps
  //
  if (i.AutoDisableSteps ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableSteps",
        e));

    s << *i.AutoDisableSteps ();
  }

  // AutoDisableTime
  //
  if (i.AutoDisableTime ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableTime",
        e));

    s << *i.AutoDisableTime ();
  }

  // CFM
  //
  if (i.CFM ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFM",
        e));

    s << *i.CFM ();
  }

  // ContactMaxCorrectingVel
  //
  if (i.ContactMaxCorrectingVel ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContactMaxCorrectingVel",
        e));

    s << *i.ContactMaxCorrectingVel ();
  }

  // ContactSurfaceLayer
  //
  if (i.ContactSurfaceLayer ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContactSurfaceLayer",
        e));

    s << *i.ContactSurfaceLayer ();
  }

  // ERP
  //
  if (i.ERP ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ERP",
        e));

    s << *i.ERP ();
  }

  // Gravity
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Gravity ())
    {
      const World::Gravity_type& x (*i.Gravity ());
      if (typeid (World::Gravity_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Gravity",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Gravity",
          "",
          false, false, e, x);
    }
  }

  // QuickStepNumIterations
  //
  if (i.QuickStepNumIterations ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "QuickStepNumIterations",
        e));

    s << *i.QuickStepNumIterations ();
  }

  // Body
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (World::Body_const_iterator
         b (i.Body ().begin ()), n (i.Body ().end ());
         b != n; ++b)
    {
      if (typeid (World::Body_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Body",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, World >
_xsd_World_type_serializer_init (
  "World",
  "");


void
World_ (::std::ostream& o,
        const ::World& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
World_ (::std::ostream& o,
        const ::World& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::std::ostream& o,
        const ::World& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::xercesc::XMLFormatTarget& t,
        const ::World& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
World_ (::xercesc::XMLFormatTarget& t,
        const ::World& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::xercesc::XMLFormatTarget& t,
        const ::World& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::xercesc::DOMDocument& d,
        const ::World& s,
        ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::World) == typeid (s))
  {
    if (n.name () == "World" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "World",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "World",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
World_ (const ::World& s,
        const ::xml_schema::namespace_infomap& m,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::World) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "World",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "World",
        "",
        m, s, f));
    d = r;
  }

  ::World_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const GeomObject& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Enable
  //
  if (i.Enable ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Enable",
        e));

    s << *i.Enable ();
  }

  // CategoryBits
  //
  if (i.CategoryBits ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CategoryBits",
        e));

    s << *i.CategoryBits ();
  }

  // CollideBits
  //
  if (i.CollideBits ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CollideBits",
        e));

    s << *i.CollideBits ();
  }

  // Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Position ())
    {
      const GeomObject::Position_type& x (*i.Position ());
      if (typeid (GeomObject::Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Position",
          "",
          false, false, e, x);
    }
  }

  // Quaternion
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Quaternion ())
    {
      const GeomObject::Quaternion_type& x (*i.Quaternion ());
      if (typeid (GeomObject::Quaternion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Quaternion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Quaternion",
          "",
          false, false, e, x);
    }
  }

  // Rotation
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Rotation ())
    {
      const GeomObject::Rotation_type& x (*i.Rotation ());
      if (typeid (GeomObject::Rotation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Rotation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Rotation",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomObject >
_xsd_GeomObject_type_serializer_init (
  "GeomObject",
  "");


void
operator<< (::xercesc::DOMElement& e, const SpaceBase& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Geom
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SpaceBase::Geom_const_iterator
         b (i.Geom ().begin ()), n (i.Geom ().end ());
         b != n; ++b)
    {
      if (typeid (SpaceBase::Geom_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Geom",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Geom",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SpaceBase >
_xsd_SpaceBase_type_serializer_init (
  "SpaceBase",
  "");


void
operator<< (::xercesc::DOMElement& e, const SimpleSpace& i)
{
  e << static_cast< const ::SpaceBase& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SimpleSpace >
_xsd_SimpleSpace_type_serializer_init (
  "SimpleSpace",
  "");


void
operator<< (::xercesc::DOMElement& e, const Body& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Space
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Space ())
    {
      const Body::Space_type& x (*i.Space ());
      if (typeid (Body::Space_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Space",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Space",
          "",
          false, false, e, x);
    }
  }

  // World
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.World ())
    {
      const Body::World_type& x (*i.World ());
      if (typeid (Body::World_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "World",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "World",
          "",
          false, false, e, x);
    }
  }

  // Enabled
  //
  if (i.Enabled ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Enabled",
        e));

    s << *i.Enabled ();
  }

  // AngularVel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.AngularVel ())
    {
      const Body::AngularVel_type& x (*i.AngularVel ());
      if (typeid (Body::AngularVel_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AngularVel",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AngularVel",
          "",
          false, false, e, x);
    }
  }

  // FiniteRotationAxis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.FiniteRotationAxis ())
    {
      const Body::FiniteRotationAxis_type& x (*i.FiniteRotationAxis ());
      if (typeid (Body::FiniteRotationAxis_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FiniteRotationAxis",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "FiniteRotationAxis",
          "",
          false, false, e, x);
    }
  }

  // FiniteRotationMode
  //
  if (i.FiniteRotationMode ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FiniteRotationMode",
        e));

    s << *i.FiniteRotationMode ();
  }

  // Force
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Force ())
    {
      const Body::Force_type& x (*i.Force ());
      if (typeid (Body::Force_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Force",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Force",
          "",
          false, false, e, x);
    }
  }

  // GravityMode
  //
  if (i.GravityMode ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "GravityMode",
        e));

    s << *i.GravityMode ();
  }

  // LinearVel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.LinearVel ())
    {
      const Body::LinearVel_type& x (*i.LinearVel ());
      if (typeid (Body::LinearVel_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearVel",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "LinearVel",
          "",
          false, false, e, x);
    }
  }

  // Mass
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Mass ())
    {
      const Body::Mass_type& x (*i.Mass ());
      if (typeid (Body::Mass_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Mass",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Mass",
          "",
          false, false, e, x);
    }
  }

  // Torque
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Torque ())
    {
      const Body::Torque_type& x (*i.Torque ());
      if (typeid (Body::Torque_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Torque",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Torque",
          "",
          false, false, e, x);
    }
  }

  // Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Position ())
    {
      const Body::Position_type& x (*i.Position ());
      if (typeid (Body::Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Position",
          "",
          false, false, e, x);
    }
  }

  // Quaternion
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Quaternion ())
    {
      const Body::Quaternion_type& x (*i.Quaternion ());
      if (typeid (Body::Quaternion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Quaternion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Quaternion",
          "",
          false, false, e, x);
    }
  }

  // Rotation
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Rotation ())
    {
      const Body::Rotation_type& x (*i.Rotation ());
      if (typeid (Body::Rotation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Rotation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Rotation",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Body >
_xsd_Body_type_serializer_init (
  "Body",
  "");


void
Body_ (::std::ostream& o,
       const ::Body& s,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Body_ (::std::ostream& o,
       const ::Body& s,
       ::xml_schema::error_handler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::std::ostream& o,
       const ::Body& s,
       ::xercesc::DOMErrorHandler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::xercesc::XMLFormatTarget& t,
       const ::Body& s,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Body_ (::xercesc::XMLFormatTarget& t,
       const ::Body& s,
       ::xml_schema::error_handler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::xercesc::XMLFormatTarget& t,
       const ::Body& s,
       ::xercesc::DOMErrorHandler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::xercesc::DOMDocument& d,
       const ::Body& s,
       ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Body) == typeid (s))
  {
    if (n.name () == "Body" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Body",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Body",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Body_ (const ::Body& s,
       const ::xml_schema::namespace_infomap& m,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Body) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Body",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Body",
        "",
        m, s, f));
    d = r;
  }

  ::Body_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Mass& i)
{
  e << static_cast< const ::RSObject& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Mass >
_xsd_Mass_type_serializer_init (
  "Mass",
  "");


void
operator<< (::xercesc::DOMElement& e, const BoxTotalMass& i)
{
  e << static_cast< const ::Mass& > (i);

  // TotalMass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TotalMass",
        e));

    s << i.TotalMass ();
  }

  // LX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LX",
        e));

    s << i.LX ();
  }

  // LY
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LY",
        e));

    s << i.LY ();
  }

  // LZ
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LZ",
        e));

    s << i.LZ ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BoxTotalMass >
_xsd_BoxTotalMass_type_serializer_init (
  "BoxTotalMass",
  "");


void
operator<< (::xercesc::DOMElement& e, const Joint& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Feedback
  //
  if (i.Feedback ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Feedback",
        e));

    s << *i.Feedback ();
  }

  // Body1
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Body1 ())
    {
      const Joint::Body1_type& x (*i.Body1 ());
      if (typeid (Joint::Body1_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body1",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Body1",
          "",
          false, false, e, x);
    }
  }

  // Body2
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Body2 ())
    {
      const Joint::Body2_type& x (*i.Body2 ());
      if (typeid (Joint::Body2_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body2",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Body2",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Joint >
_xsd_Joint_type_serializer_init (
  "Joint",
  "");


void
operator<< (::xercesc::DOMElement& e, const HingeJoint& i)
{
  e << static_cast< const ::Joint& > (i);

  // Anchor
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Anchor ())
    {
      const HingeJoint::Anchor_type& x (*i.Anchor ());
      if (typeid (HingeJoint::Anchor_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Anchor",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Anchor",
          "",
          false, false, e, x);
    }
  }

  // Axis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Axis ())
    {
      const HingeJoint::Axis_type& x (*i.Axis ());
      if (typeid (HingeJoint::Axis_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Axis",
          "",
          false, false, e, x);
    }
  }

  // Torque
  //
  if (i.Torque ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Torque",
        e));

    s << *i.Torque ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HingeJoint >
_xsd_HingeJoint_type_serializer_init (
  "HingeJoint",
  "");


void
operator<< (::xercesc::DOMElement& e, const GeomBox& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Lengths
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Lengths ())
    {
      const GeomBox::Lengths_type& x (*i.Lengths ());
      if (typeid (GeomBox::Lengths_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Lengths",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Lengths",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomBox >
_xsd_GeomBox_type_serializer_init (
  "GeomBox",
  "");


void
operator<< (::xercesc::DOMElement& e, const GeomCylinder& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Length
  //
  if (i.Length ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Length",
        e));

    s << *i.Length ();
  }

  // Radius
  //
  if (i.Radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Radius",
        e));

    s << *i.Radius ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomCylinder >
_xsd_GeomCylinder_type_serializer_init (
  "GeomCylinder",
  "");


void
operator<< (::xercesc::DOMElement& e, const GeomCapsule& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Length
  //
  if (i.Length ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Length",
        e));

    s << *i.Length ();
  }

  // Radius
  //
  if (i.Radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Radius",
        e));

    s << *i.Radius ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomCapsule >
_xsd_GeomCapsule_type_serializer_init (
  "GeomCapsule",
  "");


void
operator<< (::xercesc::DOMElement& e, const GeomSphere& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Radius
  //
  if (i.Radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Radius",
        e));

    s << *i.Radius ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomSphere >
_xsd_GeomSphere_type_serializer_init (
  "GeomSphere",
  "");


void
operator<< (::xercesc::DOMElement& e, const GeomPlane& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Space
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Space ())
    {
      const GeomPlane::Space_type& x (*i.Space ());
      if (typeid (GeomPlane::Space_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Space",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Space",
          "",
          false, false, e, x);
    }
  }

  // Body
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Body ())
    {
      const GeomPlane::Body_type& x (*i.Body ());
      if (typeid (GeomPlane::Body_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Body",
          "",
          false, false, e, x);
    }
  }

  // Enabled
  //
  if (i.Enabled ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Enabled",
        e));

    s << *i.Enabled ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomPlane >
_xsd_GeomPlane_type_serializer_init (
  "GeomPlane",
  "");


void
operator<< (::xercesc::DOMElement& e, const Rotation& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Column1
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const Rotation::Column1_type& x (i.Column1 ());
    if (typeid (Rotation::Column1_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Column1",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Column1",
        "",
        false, false, e, x);
  }

  // Column2
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const Rotation::Column2_type& x (i.Column2 ());
    if (typeid (Rotation::Column2_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Column2",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Column2",
        "",
        false, false, e, x);
  }

  // Column3
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const Rotation::Column3_type& x (i.Column3 ());
    if (typeid (Rotation::Column3_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Column3",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Column3",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Rotation >
_xsd_Rotation_type_serializer_init (
  "Rotation",
  "");


void
operator<< (::xercesc::DOMElement& e, const Vector& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  if (i.X ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "X",
        e));

    a << *i.X ();
  }

  // Y
  //
  if (i.Y ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Y",
        e));

    a << *i.Y ();
  }

  // Z
  //
  if (i.Z ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Z",
        e));

    a << *i.Z ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Vector >
_xsd_Vector_type_serializer_init (
  "Vector",
  "");


void
operator<< (::xercesc::DOMElement& e, const Quaternion& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // W
  //
  if (i.W ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "W",
        e));

    a << *i.W ();
  }

  // I
  //
  if (i.I ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "I",
        e));

    a << *i.I ();
  }

  // J
  //
  if (i.J ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "J",
        e));

    a << *i.J ();
  }

  // K
  //
  if (i.K ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "K",
        e));

    a << *i.K ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Quaternion >
_xsd_Quaternion_type_serializer_init (
  "Quaternion",
  "");


void
operator<< (::xercesc::DOMElement& e, const Foo& i)
{
  e << static_cast< const ::RSObject& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Foo >
_xsd_Foo_type_serializer_init (
  "Foo",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

