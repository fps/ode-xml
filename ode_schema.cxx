// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ode_schema.hxx"

// RSObject
// 

const RSObject::Name_optional& RSObject::
Name () const
{
  return this->Name_;
}

RSObject::Name_optional& RSObject::
Name ()
{
  return this->Name_;
}

void RSObject::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void RSObject::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void RSObject::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// Sim
// 

const Sim::World_sequence& Sim::
World () const
{
  return this->World_;
}

Sim::World_sequence& Sim::
World ()
{
  return this->World_;
}

void Sim::
World (const World_sequence& s)
{
  this->World_ = s;
}

const Sim::Space_sequence& Sim::
Space () const
{
  return this->Space_;
}

Sim::Space_sequence& Sim::
Space ()
{
  return this->Space_;
}

void Sim::
Space (const Space_sequence& s)
{
  this->Space_ = s;
}

const Sim::Body_sequence& Sim::
Body () const
{
  return this->Body_;
}

Sim::Body_sequence& Sim::
Body ()
{
  return this->Body_;
}

void Sim::
Body (const Body_sequence& s)
{
  this->Body_ = s;
}

const Sim::Geom_sequence& Sim::
Geom () const
{
  return this->Geom_;
}

Sim::Geom_sequence& Sim::
Geom ()
{
  return this->Geom_;
}

void Sim::
Geom (const Geom_sequence& s)
{
  this->Geom_ = s;
}


// World
// 

const World::AutoDisableAngularThreshold_optional& World::
AutoDisableAngularThreshold () const
{
  return this->AutoDisableAngularThreshold_;
}

World::AutoDisableAngularThreshold_optional& World::
AutoDisableAngularThreshold ()
{
  return this->AutoDisableAngularThreshold_;
}

void World::
AutoDisableAngularThreshold (const AutoDisableAngularThreshold_type& x)
{
  this->AutoDisableAngularThreshold_.set (x);
}

void World::
AutoDisableAngularThreshold (const AutoDisableAngularThreshold_optional& x)
{
  this->AutoDisableAngularThreshold_ = x;
}

const World::AutoDisableFlag_optional& World::
AutoDisableFlag () const
{
  return this->AutoDisableFlag_;
}

World::AutoDisableFlag_optional& World::
AutoDisableFlag ()
{
  return this->AutoDisableFlag_;
}

void World::
AutoDisableFlag (const AutoDisableFlag_type& x)
{
  this->AutoDisableFlag_.set (x);
}

void World::
AutoDisableFlag (const AutoDisableFlag_optional& x)
{
  this->AutoDisableFlag_ = x;
}

const World::AutoDisableSteps_optional& World::
AutoDisableSteps () const
{
  return this->AutoDisableSteps_;
}

World::AutoDisableSteps_optional& World::
AutoDisableSteps ()
{
  return this->AutoDisableSteps_;
}

void World::
AutoDisableSteps (const AutoDisableSteps_type& x)
{
  this->AutoDisableSteps_.set (x);
}

void World::
AutoDisableSteps (const AutoDisableSteps_optional& x)
{
  this->AutoDisableSteps_ = x;
}

const World::AutoDisableTime_optional& World::
AutoDisableTime () const
{
  return this->AutoDisableTime_;
}

World::AutoDisableTime_optional& World::
AutoDisableTime ()
{
  return this->AutoDisableTime_;
}

void World::
AutoDisableTime (const AutoDisableTime_type& x)
{
  this->AutoDisableTime_.set (x);
}

void World::
AutoDisableTime (const AutoDisableTime_optional& x)
{
  this->AutoDisableTime_ = x;
}

const World::CFM_optional& World::
CFM () const
{
  return this->CFM_;
}

World::CFM_optional& World::
CFM ()
{
  return this->CFM_;
}

void World::
CFM (const CFM_type& x)
{
  this->CFM_.set (x);
}

void World::
CFM (const CFM_optional& x)
{
  this->CFM_ = x;
}

const World::ContactMaxCorrectingVel_optional& World::
ContactMaxCorrectingVel () const
{
  return this->ContactMaxCorrectingVel_;
}

World::ContactMaxCorrectingVel_optional& World::
ContactMaxCorrectingVel ()
{
  return this->ContactMaxCorrectingVel_;
}

void World::
ContactMaxCorrectingVel (const ContactMaxCorrectingVel_type& x)
{
  this->ContactMaxCorrectingVel_.set (x);
}

void World::
ContactMaxCorrectingVel (const ContactMaxCorrectingVel_optional& x)
{
  this->ContactMaxCorrectingVel_ = x;
}

const World::ContactSurfaceLayer_optional& World::
ContactSurfaceLayer () const
{
  return this->ContactSurfaceLayer_;
}

World::ContactSurfaceLayer_optional& World::
ContactSurfaceLayer ()
{
  return this->ContactSurfaceLayer_;
}

void World::
ContactSurfaceLayer (const ContactSurfaceLayer_type& x)
{
  this->ContactSurfaceLayer_.set (x);
}

void World::
ContactSurfaceLayer (const ContactSurfaceLayer_optional& x)
{
  this->ContactSurfaceLayer_ = x;
}

const World::ERP_optional& World::
ERP () const
{
  return this->ERP_;
}

World::ERP_optional& World::
ERP ()
{
  return this->ERP_;
}

void World::
ERP (const ERP_type& x)
{
  this->ERP_.set (x);
}

void World::
ERP (const ERP_optional& x)
{
  this->ERP_ = x;
}

const World::Gravity_optional& World::
Gravity () const
{
  return this->Gravity_;
}

World::Gravity_optional& World::
Gravity ()
{
  return this->Gravity_;
}

void World::
Gravity (const Gravity_type& x)
{
  this->Gravity_.set (x);
}

void World::
Gravity (const Gravity_optional& x)
{
  this->Gravity_ = x;
}

void World::
Gravity (::std::auto_ptr< Gravity_type > x)
{
  this->Gravity_.set (x);
}

const World::QuickStepNumIterations_optional& World::
QuickStepNumIterations () const
{
  return this->QuickStepNumIterations_;
}

World::QuickStepNumIterations_optional& World::
QuickStepNumIterations ()
{
  return this->QuickStepNumIterations_;
}

void World::
QuickStepNumIterations (const QuickStepNumIterations_type& x)
{
  this->QuickStepNumIterations_.set (x);
}

void World::
QuickStepNumIterations (const QuickStepNumIterations_optional& x)
{
  this->QuickStepNumIterations_ = x;
}

const World::Body_sequence& World::
Body () const
{
  return this->Body_;
}

World::Body_sequence& World::
Body ()
{
  return this->Body_;
}

void World::
Body (const Body_sequence& s)
{
  this->Body_ = s;
}


// GeomObject
// 

const GeomObject::Enable_optional& GeomObject::
Enable () const
{
  return this->Enable_;
}

GeomObject::Enable_optional& GeomObject::
Enable ()
{
  return this->Enable_;
}

void GeomObject::
Enable (const Enable_type& x)
{
  this->Enable_.set (x);
}

void GeomObject::
Enable (const Enable_optional& x)
{
  this->Enable_ = x;
}

const GeomObject::CategoryBits_optional& GeomObject::
CategoryBits () const
{
  return this->CategoryBits_;
}

GeomObject::CategoryBits_optional& GeomObject::
CategoryBits ()
{
  return this->CategoryBits_;
}

void GeomObject::
CategoryBits (const CategoryBits_type& x)
{
  this->CategoryBits_.set (x);
}

void GeomObject::
CategoryBits (const CategoryBits_optional& x)
{
  this->CategoryBits_ = x;
}

const GeomObject::CollideBits_optional& GeomObject::
CollideBits () const
{
  return this->CollideBits_;
}

GeomObject::CollideBits_optional& GeomObject::
CollideBits ()
{
  return this->CollideBits_;
}

void GeomObject::
CollideBits (const CollideBits_type& x)
{
  this->CollideBits_.set (x);
}

void GeomObject::
CollideBits (const CollideBits_optional& x)
{
  this->CollideBits_ = x;
}

const GeomObject::Position_optional& GeomObject::
Position () const
{
  return this->Position_;
}

GeomObject::Position_optional& GeomObject::
Position ()
{
  return this->Position_;
}

void GeomObject::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void GeomObject::
Position (const Position_optional& x)
{
  this->Position_ = x;
}

void GeomObject::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const GeomObject::Quaternion_optional& GeomObject::
Quaternion () const
{
  return this->Quaternion_;
}

GeomObject::Quaternion_optional& GeomObject::
Quaternion ()
{
  return this->Quaternion_;
}

void GeomObject::
Quaternion (const Quaternion_type& x)
{
  this->Quaternion_.set (x);
}

void GeomObject::
Quaternion (const Quaternion_optional& x)
{
  this->Quaternion_ = x;
}

void GeomObject::
Quaternion (::std::auto_ptr< Quaternion_type > x)
{
  this->Quaternion_.set (x);
}

const GeomObject::Rotation_optional& GeomObject::
Rotation () const
{
  return this->Rotation_;
}

GeomObject::Rotation_optional& GeomObject::
Rotation ()
{
  return this->Rotation_;
}

void GeomObject::
Rotation (const Rotation_type& x)
{
  this->Rotation_.set (x);
}

void GeomObject::
Rotation (const Rotation_optional& x)
{
  this->Rotation_ = x;
}

void GeomObject::
Rotation (::std::auto_ptr< Rotation_type > x)
{
  this->Rotation_.set (x);
}


// SpaceBase
// 

const SpaceBase::Geom_sequence& SpaceBase::
Geom () const
{
  return this->Geom_;
}

SpaceBase::Geom_sequence& SpaceBase::
Geom ()
{
  return this->Geom_;
}

void SpaceBase::
Geom (const Geom_sequence& s)
{
  this->Geom_ = s;
}


// SimpleSpace
// 


// Body
// 

const Body::Space_optional& Body::
Space () const
{
  return this->Space_;
}

Body::Space_optional& Body::
Space ()
{
  return this->Space_;
}

void Body::
Space (const Space_type& x)
{
  this->Space_.set (x);
}

void Body::
Space (const Space_optional& x)
{
  this->Space_ = x;
}

void Body::
Space (::std::auto_ptr< Space_type > x)
{
  this->Space_.set (x);
}

const Body::World_optional& Body::
World () const
{
  return this->World_;
}

Body::World_optional& Body::
World ()
{
  return this->World_;
}

void Body::
World (const World_type& x)
{
  this->World_.set (x);
}

void Body::
World (const World_optional& x)
{
  this->World_ = x;
}

void Body::
World (::std::auto_ptr< World_type > x)
{
  this->World_.set (x);
}

const Body::Enabled_optional& Body::
Enabled () const
{
  return this->Enabled_;
}

Body::Enabled_optional& Body::
Enabled ()
{
  return this->Enabled_;
}

void Body::
Enabled (const Enabled_type& x)
{
  this->Enabled_.set (x);
}

void Body::
Enabled (const Enabled_optional& x)
{
  this->Enabled_ = x;
}

const Body::AngularVel_optional& Body::
AngularVel () const
{
  return this->AngularVel_;
}

Body::AngularVel_optional& Body::
AngularVel ()
{
  return this->AngularVel_;
}

void Body::
AngularVel (const AngularVel_type& x)
{
  this->AngularVel_.set (x);
}

void Body::
AngularVel (const AngularVel_optional& x)
{
  this->AngularVel_ = x;
}

void Body::
AngularVel (::std::auto_ptr< AngularVel_type > x)
{
  this->AngularVel_.set (x);
}

const Body::FiniteRotationAxis_optional& Body::
FiniteRotationAxis () const
{
  return this->FiniteRotationAxis_;
}

Body::FiniteRotationAxis_optional& Body::
FiniteRotationAxis ()
{
  return this->FiniteRotationAxis_;
}

void Body::
FiniteRotationAxis (const FiniteRotationAxis_type& x)
{
  this->FiniteRotationAxis_.set (x);
}

void Body::
FiniteRotationAxis (const FiniteRotationAxis_optional& x)
{
  this->FiniteRotationAxis_ = x;
}

void Body::
FiniteRotationAxis (::std::auto_ptr< FiniteRotationAxis_type > x)
{
  this->FiniteRotationAxis_.set (x);
}

const Body::FiniteRotationMode_optional& Body::
FiniteRotationMode () const
{
  return this->FiniteRotationMode_;
}

Body::FiniteRotationMode_optional& Body::
FiniteRotationMode ()
{
  return this->FiniteRotationMode_;
}

void Body::
FiniteRotationMode (const FiniteRotationMode_type& x)
{
  this->FiniteRotationMode_.set (x);
}

void Body::
FiniteRotationMode (const FiniteRotationMode_optional& x)
{
  this->FiniteRotationMode_ = x;
}

const Body::Force_optional& Body::
Force () const
{
  return this->Force_;
}

Body::Force_optional& Body::
Force ()
{
  return this->Force_;
}

void Body::
Force (const Force_type& x)
{
  this->Force_.set (x);
}

void Body::
Force (const Force_optional& x)
{
  this->Force_ = x;
}

void Body::
Force (::std::auto_ptr< Force_type > x)
{
  this->Force_.set (x);
}

const Body::GravityMode_optional& Body::
GravityMode () const
{
  return this->GravityMode_;
}

Body::GravityMode_optional& Body::
GravityMode ()
{
  return this->GravityMode_;
}

void Body::
GravityMode (const GravityMode_type& x)
{
  this->GravityMode_.set (x);
}

void Body::
GravityMode (const GravityMode_optional& x)
{
  this->GravityMode_ = x;
}

const Body::LinearVel_optional& Body::
LinearVel () const
{
  return this->LinearVel_;
}

Body::LinearVel_optional& Body::
LinearVel ()
{
  return this->LinearVel_;
}

void Body::
LinearVel (const LinearVel_type& x)
{
  this->LinearVel_.set (x);
}

void Body::
LinearVel (const LinearVel_optional& x)
{
  this->LinearVel_ = x;
}

void Body::
LinearVel (::std::auto_ptr< LinearVel_type > x)
{
  this->LinearVel_.set (x);
}

const Body::Mass_optional& Body::
Mass () const
{
  return this->Mass_;
}

Body::Mass_optional& Body::
Mass ()
{
  return this->Mass_;
}

void Body::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}

void Body::
Mass (const Mass_optional& x)
{
  this->Mass_ = x;
}

void Body::
Mass (::std::auto_ptr< Mass_type > x)
{
  this->Mass_.set (x);
}

const Body::Torque_optional& Body::
Torque () const
{
  return this->Torque_;
}

Body::Torque_optional& Body::
Torque ()
{
  return this->Torque_;
}

void Body::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void Body::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}

void Body::
Torque (::std::auto_ptr< Torque_type > x)
{
  this->Torque_.set (x);
}

const Body::Position_optional& Body::
Position () const
{
  return this->Position_;
}

Body::Position_optional& Body::
Position ()
{
  return this->Position_;
}

void Body::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void Body::
Position (const Position_optional& x)
{
  this->Position_ = x;
}

void Body::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const Body::Quaternion_optional& Body::
Quaternion () const
{
  return this->Quaternion_;
}

Body::Quaternion_optional& Body::
Quaternion ()
{
  return this->Quaternion_;
}

void Body::
Quaternion (const Quaternion_type& x)
{
  this->Quaternion_.set (x);
}

void Body::
Quaternion (const Quaternion_optional& x)
{
  this->Quaternion_ = x;
}

void Body::
Quaternion (::std::auto_ptr< Quaternion_type > x)
{
  this->Quaternion_.set (x);
}

const Body::Rotation_optional& Body::
Rotation () const
{
  return this->Rotation_;
}

Body::Rotation_optional& Body::
Rotation ()
{
  return this->Rotation_;
}

void Body::
Rotation (const Rotation_type& x)
{
  this->Rotation_.set (x);
}

void Body::
Rotation (const Rotation_optional& x)
{
  this->Rotation_ = x;
}

void Body::
Rotation (::std::auto_ptr< Rotation_type > x)
{
  this->Rotation_.set (x);
}


// Mass
// 


// BoxTotalMass
// 

const BoxTotalMass::M_optional& BoxTotalMass::
M () const
{
  return this->M_;
}

BoxTotalMass::M_optional& BoxTotalMass::
M ()
{
  return this->M_;
}

void BoxTotalMass::
M (const M_type& x)
{
  this->M_.set (x);
}

void BoxTotalMass::
M (const M_optional& x)
{
  this->M_ = x;
}

const BoxTotalMass::LX_optional& BoxTotalMass::
LX () const
{
  return this->LX_;
}

BoxTotalMass::LX_optional& BoxTotalMass::
LX ()
{
  return this->LX_;
}

void BoxTotalMass::
LX (const LX_type& x)
{
  this->LX_.set (x);
}

void BoxTotalMass::
LX (const LX_optional& x)
{
  this->LX_ = x;
}

const BoxTotalMass::LY_optional& BoxTotalMass::
LY () const
{
  return this->LY_;
}

BoxTotalMass::LY_optional& BoxTotalMass::
LY ()
{
  return this->LY_;
}

void BoxTotalMass::
LY (const LY_type& x)
{
  this->LY_.set (x);
}

void BoxTotalMass::
LY (const LY_optional& x)
{
  this->LY_ = x;
}

const BoxTotalMass::LZ_optional& BoxTotalMass::
LZ () const
{
  return this->LZ_;
}

BoxTotalMass::LZ_optional& BoxTotalMass::
LZ ()
{
  return this->LZ_;
}

void BoxTotalMass::
LZ (const LZ_type& x)
{
  this->LZ_.set (x);
}

void BoxTotalMass::
LZ (const LZ_optional& x)
{
  this->LZ_ = x;
}


// Joint
// 

const Joint::Feedback_optional& Joint::
Feedback () const
{
  return this->Feedback_;
}

Joint::Feedback_optional& Joint::
Feedback ()
{
  return this->Feedback_;
}

void Joint::
Feedback (const Feedback_type& x)
{
  this->Feedback_.set (x);
}

void Joint::
Feedback (const Feedback_optional& x)
{
  this->Feedback_ = x;
}

const Joint::Body1_optional& Joint::
Body1 () const
{
  return this->Body1_;
}

Joint::Body1_optional& Joint::
Body1 ()
{
  return this->Body1_;
}

void Joint::
Body1 (const Body1_type& x)
{
  this->Body1_.set (x);
}

void Joint::
Body1 (const Body1_optional& x)
{
  this->Body1_ = x;
}

void Joint::
Body1 (::std::auto_ptr< Body1_type > x)
{
  this->Body1_.set (x);
}

const Joint::Body2_optional& Joint::
Body2 () const
{
  return this->Body2_;
}

Joint::Body2_optional& Joint::
Body2 ()
{
  return this->Body2_;
}

void Joint::
Body2 (const Body2_type& x)
{
  this->Body2_.set (x);
}

void Joint::
Body2 (const Body2_optional& x)
{
  this->Body2_ = x;
}

void Joint::
Body2 (::std::auto_ptr< Body2_type > x)
{
  this->Body2_.set (x);
}

const Joint::Param_sequence& Joint::
Param () const
{
  return this->Param_;
}

Joint::Param_sequence& Joint::
Param ()
{
  return this->Param_;
}

void Joint::
Param (const Param_sequence& s)
{
  this->Param_ = s;
}


// HingeJoint
// 

const HingeJoint::Anchor_optional& HingeJoint::
Anchor () const
{
  return this->Anchor_;
}

HingeJoint::Anchor_optional& HingeJoint::
Anchor ()
{
  return this->Anchor_;
}

void HingeJoint::
Anchor (const Anchor_type& x)
{
  this->Anchor_.set (x);
}

void HingeJoint::
Anchor (const Anchor_optional& x)
{
  this->Anchor_ = x;
}

void HingeJoint::
Anchor (::std::auto_ptr< Anchor_type > x)
{
  this->Anchor_.set (x);
}

const HingeJoint::Axis_optional& HingeJoint::
Axis () const
{
  return this->Axis_;
}

HingeJoint::Axis_optional& HingeJoint::
Axis ()
{
  return this->Axis_;
}

void HingeJoint::
Axis (const Axis_type& x)
{
  this->Axis_.set (x);
}

void HingeJoint::
Axis (const Axis_optional& x)
{
  this->Axis_ = x;
}

void HingeJoint::
Axis (::std::auto_ptr< Axis_type > x)
{
  this->Axis_.set (x);
}

const HingeJoint::Torque_optional& HingeJoint::
Torque () const
{
  return this->Torque_;
}

HingeJoint::Torque_optional& HingeJoint::
Torque ()
{
  return this->Torque_;
}

void HingeJoint::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void HingeJoint::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}


// HingeJoint2
// 

const HingeJoint2::Anchor_optional& HingeJoint2::
Anchor () const
{
  return this->Anchor_;
}

HingeJoint2::Anchor_optional& HingeJoint2::
Anchor ()
{
  return this->Anchor_;
}

void HingeJoint2::
Anchor (const Anchor_type& x)
{
  this->Anchor_.set (x);
}

void HingeJoint2::
Anchor (const Anchor_optional& x)
{
  this->Anchor_ = x;
}

void HingeJoint2::
Anchor (::std::auto_ptr< Anchor_type > x)
{
  this->Anchor_.set (x);
}

const HingeJoint2::Axis1_optional& HingeJoint2::
Axis1 () const
{
  return this->Axis1_;
}

HingeJoint2::Axis1_optional& HingeJoint2::
Axis1 ()
{
  return this->Axis1_;
}

void HingeJoint2::
Axis1 (const Axis1_type& x)
{
  this->Axis1_.set (x);
}

void HingeJoint2::
Axis1 (const Axis1_optional& x)
{
  this->Axis1_ = x;
}

void HingeJoint2::
Axis1 (::std::auto_ptr< Axis1_type > x)
{
  this->Axis1_.set (x);
}

const HingeJoint2::Axis2_optional& HingeJoint2::
Axis2 () const
{
  return this->Axis2_;
}

HingeJoint2::Axis2_optional& HingeJoint2::
Axis2 ()
{
  return this->Axis2_;
}

void HingeJoint2::
Axis2 (const Axis2_type& x)
{
  this->Axis2_.set (x);
}

void HingeJoint2::
Axis2 (const Axis2_optional& x)
{
  this->Axis2_ = x;
}

void HingeJoint2::
Axis2 (::std::auto_ptr< Axis2_type > x)
{
  this->Axis2_.set (x);
}

const HingeJoint2::Torque_optional& HingeJoint2::
Torque () const
{
  return this->Torque_;
}

HingeJoint2::Torque_optional& HingeJoint2::
Torque ()
{
  return this->Torque_;
}

void HingeJoint2::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void HingeJoint2::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}


// GeomBox
// 

const GeomBox::Lengths_optional& GeomBox::
Lengths () const
{
  return this->Lengths_;
}

GeomBox::Lengths_optional& GeomBox::
Lengths ()
{
  return this->Lengths_;
}

void GeomBox::
Lengths (const Lengths_type& x)
{
  this->Lengths_.set (x);
}

void GeomBox::
Lengths (const Lengths_optional& x)
{
  this->Lengths_ = x;
}

void GeomBox::
Lengths (::std::auto_ptr< Lengths_type > x)
{
  this->Lengths_.set (x);
}


// GeomCylinder
// 

const GeomCylinder::Length_optional& GeomCylinder::
Length () const
{
  return this->Length_;
}

GeomCylinder::Length_optional& GeomCylinder::
Length ()
{
  return this->Length_;
}

void GeomCylinder::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void GeomCylinder::
Length (const Length_optional& x)
{
  this->Length_ = x;
}

const GeomCylinder::Radius_optional& GeomCylinder::
Radius () const
{
  return this->Radius_;
}

GeomCylinder::Radius_optional& GeomCylinder::
Radius ()
{
  return this->Radius_;
}

void GeomCylinder::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomCylinder::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomCapsule
// 

const GeomCapsule::Length_optional& GeomCapsule::
Length () const
{
  return this->Length_;
}

GeomCapsule::Length_optional& GeomCapsule::
Length ()
{
  return this->Length_;
}

void GeomCapsule::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void GeomCapsule::
Length (const Length_optional& x)
{
  this->Length_ = x;
}

const GeomCapsule::Radius_optional& GeomCapsule::
Radius () const
{
  return this->Radius_;
}

GeomCapsule::Radius_optional& GeomCapsule::
Radius ()
{
  return this->Radius_;
}

void GeomCapsule::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomCapsule::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomSphere
// 

const GeomSphere::Radius_optional& GeomSphere::
Radius () const
{
  return this->Radius_;
}

GeomSphere::Radius_optional& GeomSphere::
Radius ()
{
  return this->Radius_;
}

void GeomSphere::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomSphere::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomPlane
// 

const GeomPlane::Space_optional& GeomPlane::
Space () const
{
  return this->Space_;
}

GeomPlane::Space_optional& GeomPlane::
Space ()
{
  return this->Space_;
}

void GeomPlane::
Space (const Space_type& x)
{
  this->Space_.set (x);
}

void GeomPlane::
Space (const Space_optional& x)
{
  this->Space_ = x;
}

void GeomPlane::
Space (::std::auto_ptr< Space_type > x)
{
  this->Space_.set (x);
}

const GeomPlane::Body_optional& GeomPlane::
Body () const
{
  return this->Body_;
}

GeomPlane::Body_optional& GeomPlane::
Body ()
{
  return this->Body_;
}

void GeomPlane::
Body (const Body_type& x)
{
  this->Body_.set (x);
}

void GeomPlane::
Body (const Body_optional& x)
{
  this->Body_ = x;
}

void GeomPlane::
Body (::std::auto_ptr< Body_type > x)
{
  this->Body_.set (x);
}

const GeomPlane::Enabled_optional& GeomPlane::
Enabled () const
{
  return this->Enabled_;
}

GeomPlane::Enabled_optional& GeomPlane::
Enabled ()
{
  return this->Enabled_;
}

void GeomPlane::
Enabled (const Enabled_type& x)
{
  this->Enabled_.set (x);
}

void GeomPlane::
Enabled (const Enabled_optional& x)
{
  this->Enabled_ = x;
}


// Rotation
// 

const Rotation::Column1_type& Rotation::
Column1 () const
{
  return this->Column1_.get ();
}

Rotation::Column1_type& Rotation::
Column1 ()
{
  return this->Column1_.get ();
}

void Rotation::
Column1 (const Column1_type& x)
{
  this->Column1_.set (x);
}

void Rotation::
Column1 (::std::auto_ptr< Column1_type > x)
{
  this->Column1_.set (x);
}

const Rotation::Column2_type& Rotation::
Column2 () const
{
  return this->Column2_.get ();
}

Rotation::Column2_type& Rotation::
Column2 ()
{
  return this->Column2_.get ();
}

void Rotation::
Column2 (const Column2_type& x)
{
  this->Column2_.set (x);
}

void Rotation::
Column2 (::std::auto_ptr< Column2_type > x)
{
  this->Column2_.set (x);
}

const Rotation::Column3_type& Rotation::
Column3 () const
{
  return this->Column3_.get ();
}

Rotation::Column3_type& Rotation::
Column3 ()
{
  return this->Column3_.get ();
}

void Rotation::
Column3 (const Column3_type& x)
{
  this->Column3_.set (x);
}

void Rotation::
Column3 (::std::auto_ptr< Column3_type > x)
{
  this->Column3_.set (x);
}


// Vector
// 

const Vector::X_optional& Vector::
X () const
{
  return this->X_;
}

Vector::X_optional& Vector::
X ()
{
  return this->X_;
}

void Vector::
X (const X_type& x)
{
  this->X_.set (x);
}

void Vector::
X (const X_optional& x)
{
  this->X_ = x;
}

const Vector::Y_optional& Vector::
Y () const
{
  return this->Y_;
}

Vector::Y_optional& Vector::
Y ()
{
  return this->Y_;
}

void Vector::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void Vector::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

const Vector::Z_optional& Vector::
Z () const
{
  return this->Z_;
}

Vector::Z_optional& Vector::
Z ()
{
  return this->Z_;
}

void Vector::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void Vector::
Z (const Z_optional& x)
{
  this->Z_ = x;
}


// Quaternion
// 

const Quaternion::W_optional& Quaternion::
W () const
{
  return this->W_;
}

Quaternion::W_optional& Quaternion::
W ()
{
  return this->W_;
}

void Quaternion::
W (const W_type& x)
{
  this->W_.set (x);
}

void Quaternion::
W (const W_optional& x)
{
  this->W_ = x;
}

const Quaternion::I_optional& Quaternion::
I () const
{
  return this->I_;
}

Quaternion::I_optional& Quaternion::
I ()
{
  return this->I_;
}

void Quaternion::
I (const I_type& x)
{
  this->I_.set (x);
}

void Quaternion::
I (const I_optional& x)
{
  this->I_ = x;
}

const Quaternion::J_optional& Quaternion::
J () const
{
  return this->J_;
}

Quaternion::J_optional& Quaternion::
J ()
{
  return this->J_;
}

void Quaternion::
J (const J_type& x)
{
  this->J_.set (x);
}

void Quaternion::
J (const J_optional& x)
{
  this->J_ = x;
}

const Quaternion::K_optional& Quaternion::
K () const
{
  return this->K_;
}

Quaternion::K_optional& Quaternion::
K ()
{
  return this->K_;
}

void Quaternion::
K (const K_type& x)
{
  this->K_.set (x);
}

void Quaternion::
K (const K_optional& x)
{
  this->K_ = x;
}


// Foo
// 


// Param
// 


// paramBounce
// 

const paramBounce::Value_type& paramBounce::
Value () const
{
  return this->Value_.get ();
}

paramBounce::Value_type& paramBounce::
Value ()
{
  return this->Value_.get ();
}

void paramBounce::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramBounce::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamBounce
// 

const ParamBounce::Value_optional& ParamBounce::
Value () const
{
  return this->Value_;
}

ParamBounce::Value_optional& ParamBounce::
Value ()
{
  return this->Value_;
}

void ParamBounce::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamBounce::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamBounce2
// 

const ParamBounce2::Value_optional& ParamBounce2::
Value () const
{
  return this->Value_;
}

ParamBounce2::Value_optional& ParamBounce2::
Value ()
{
  return this->Value_;
}

void ParamBounce2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamBounce2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamBounce3
// 

const ParamBounce3::Value_optional& ParamBounce3::
Value () const
{
  return this->Value_;
}

ParamBounce3::Value_optional& ParamBounce3::
Value ()
{
  return this->Value_;
}

void ParamBounce3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamBounce3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramCFM
// 

const paramCFM::Value_type& paramCFM::
Value () const
{
  return this->Value_.get ();
}

paramCFM::Value_type& paramCFM::
Value ()
{
  return this->Value_.get ();
}

void paramCFM::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramCFM::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamCFM
// 

const ParamCFM::Value_optional& ParamCFM::
Value () const
{
  return this->Value_;
}

ParamCFM::Value_optional& ParamCFM::
Value ()
{
  return this->Value_;
}

void ParamCFM::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamCFM::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamCFM2
// 

const ParamCFM2::Value_optional& ParamCFM2::
Value () const
{
  return this->Value_;
}

ParamCFM2::Value_optional& ParamCFM2::
Value ()
{
  return this->Value_;
}

void ParamCFM2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamCFM2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamCFM3
// 

const ParamCFM3::Value_optional& ParamCFM3::
Value () const
{
  return this->Value_;
}

ParamCFM3::Value_optional& ParamCFM3::
Value ()
{
  return this->Value_;
}

void ParamCFM3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamCFM3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramFMax
// 

const paramFMax::Value_type& paramFMax::
Value () const
{
  return this->Value_.get ();
}

paramFMax::Value_type& paramFMax::
Value ()
{
  return this->Value_.get ();
}

void paramFMax::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramFMax::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamFMax
// 

const ParamFMax::Value_optional& ParamFMax::
Value () const
{
  return this->Value_;
}

ParamFMax::Value_optional& ParamFMax::
Value ()
{
  return this->Value_;
}

void ParamFMax::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamFMax::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamFMax2
// 

const ParamFMax2::Value_optional& ParamFMax2::
Value () const
{
  return this->Value_;
}

ParamFMax2::Value_optional& ParamFMax2::
Value ()
{
  return this->Value_;
}

void ParamFMax2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamFMax2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamFMax3
// 

const ParamFMax3::Value_optional& ParamFMax3::
Value () const
{
  return this->Value_;
}

ParamFMax3::Value_optional& ParamFMax3::
Value ()
{
  return this->Value_;
}

void ParamFMax3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamFMax3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramFudgeFactor
// 

const paramFudgeFactor::Value_type& paramFudgeFactor::
Value () const
{
  return this->Value_.get ();
}

paramFudgeFactor::Value_type& paramFudgeFactor::
Value ()
{
  return this->Value_.get ();
}

void paramFudgeFactor::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramFudgeFactor::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamFudgeFactor
// 

const ParamFudgeFactor::Value_optional& ParamFudgeFactor::
Value () const
{
  return this->Value_;
}

ParamFudgeFactor::Value_optional& ParamFudgeFactor::
Value ()
{
  return this->Value_;
}

void ParamFudgeFactor::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamFudgeFactor::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamFudgeFactor2
// 

const ParamFudgeFactor2::Value_optional& ParamFudgeFactor2::
Value () const
{
  return this->Value_;
}

ParamFudgeFactor2::Value_optional& ParamFudgeFactor2::
Value ()
{
  return this->Value_;
}

void ParamFudgeFactor2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamFudgeFactor2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamFudgeFactor3
// 

const ParamFudgeFactor3::Value_optional& ParamFudgeFactor3::
Value () const
{
  return this->Value_;
}

ParamFudgeFactor3::Value_optional& ParamFudgeFactor3::
Value ()
{
  return this->Value_;
}

void ParamFudgeFactor3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamFudgeFactor3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamGroup
// 

const ParamGroup::Value_optional& ParamGroup::
Value () const
{
  return this->Value_;
}

ParamGroup::Value_optional& ParamGroup::
Value ()
{
  return this->Value_;
}

void ParamGroup::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamGroup::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramHiStop
// 

const paramHiStop::Value_type& paramHiStop::
Value () const
{
  return this->Value_.get ();
}

paramHiStop::Value_type& paramHiStop::
Value ()
{
  return this->Value_.get ();
}

void paramHiStop::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramHiStop::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamHiStop
// 

const ParamHiStop::Value_optional& ParamHiStop::
Value () const
{
  return this->Value_;
}

ParamHiStop::Value_optional& ParamHiStop::
Value ()
{
  return this->Value_;
}

void ParamHiStop::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamHiStop::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamHiStop2
// 

const ParamHiStop2::Value_optional& ParamHiStop2::
Value () const
{
  return this->Value_;
}

ParamHiStop2::Value_optional& ParamHiStop2::
Value ()
{
  return this->Value_;
}

void ParamHiStop2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamHiStop2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamHiStop3
// 

const ParamHiStop3::Value_optional& ParamHiStop3::
Value () const
{
  return this->Value_;
}

ParamHiStop3::Value_optional& ParamHiStop3::
Value ()
{
  return this->Value_;
}

void ParamHiStop3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamHiStop3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramLoStop
// 

const paramLoStop::Value_type& paramLoStop::
Value () const
{
  return this->Value_.get ();
}

paramLoStop::Value_type& paramLoStop::
Value ()
{
  return this->Value_.get ();
}

void paramLoStop::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramLoStop::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamLoStop
// 

const ParamLoStop::Value_optional& ParamLoStop::
Value () const
{
  return this->Value_;
}

ParamLoStop::Value_optional& ParamLoStop::
Value ()
{
  return this->Value_;
}

void ParamLoStop::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamLoStop::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamLoStop2
// 

const ParamLoStop2::Value_optional& ParamLoStop2::
Value () const
{
  return this->Value_;
}

ParamLoStop2::Value_optional& ParamLoStop2::
Value ()
{
  return this->Value_;
}

void ParamLoStop2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamLoStop2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamLoStop3
// 

const ParamLoStop3::Value_optional& ParamLoStop3::
Value () const
{
  return this->Value_;
}

ParamLoStop3::Value_optional& ParamLoStop3::
Value ()
{
  return this->Value_;
}

void ParamLoStop3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamLoStop3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramStopCFM
// 

const paramStopCFM::Value_type& paramStopCFM::
Value () const
{
  return this->Value_.get ();
}

paramStopCFM::Value_type& paramStopCFM::
Value ()
{
  return this->Value_.get ();
}

void paramStopCFM::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramStopCFM::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamStopCFM
// 

const ParamStopCFM::Value_optional& ParamStopCFM::
Value () const
{
  return this->Value_;
}

ParamStopCFM::Value_optional& ParamStopCFM::
Value ()
{
  return this->Value_;
}

void ParamStopCFM::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamStopCFM::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamStopCFM2
// 

const ParamStopCFM2::Value_optional& ParamStopCFM2::
Value () const
{
  return this->Value_;
}

ParamStopCFM2::Value_optional& ParamStopCFM2::
Value ()
{
  return this->Value_;
}

void ParamStopCFM2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamStopCFM2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamStopCFM3
// 

const ParamStopCFM3::Value_optional& ParamStopCFM3::
Value () const
{
  return this->Value_;
}

ParamStopCFM3::Value_optional& ParamStopCFM3::
Value ()
{
  return this->Value_;
}

void ParamStopCFM3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamStopCFM3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramStopERP
// 

const paramStopERP::Value_type& paramStopERP::
Value () const
{
  return this->Value_.get ();
}

paramStopERP::Value_type& paramStopERP::
Value ()
{
  return this->Value_.get ();
}

void paramStopERP::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramStopERP::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamStopERP
// 

const ParamStopERP::Value_optional& ParamStopERP::
Value () const
{
  return this->Value_;
}

ParamStopERP::Value_optional& ParamStopERP::
Value ()
{
  return this->Value_;
}

void ParamStopERP::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamStopERP::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamStopERP2
// 

const ParamStopERP2::Value_optional& ParamStopERP2::
Value () const
{
  return this->Value_;
}

ParamStopERP2::Value_optional& ParamStopERP2::
Value ()
{
  return this->Value_;
}

void ParamStopERP2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamStopERP2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamStopERP3
// 

const ParamStopERP3::Value_optional& ParamStopERP3::
Value () const
{
  return this->Value_;
}

ParamStopERP3::Value_optional& ParamStopERP3::
Value ()
{
  return this->Value_;
}

void ParamStopERP3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamStopERP3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramSuspensionCFM
// 

const paramSuspensionCFM::Value_type& paramSuspensionCFM::
Value () const
{
  return this->Value_.get ();
}

paramSuspensionCFM::Value_type& paramSuspensionCFM::
Value ()
{
  return this->Value_.get ();
}

void paramSuspensionCFM::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramSuspensionCFM::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamSuspensionCFM
// 

const ParamSuspensionCFM::Value_optional& ParamSuspensionCFM::
Value () const
{
  return this->Value_;
}

ParamSuspensionCFM::Value_optional& ParamSuspensionCFM::
Value ()
{
  return this->Value_;
}

void ParamSuspensionCFM::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamSuspensionCFM::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamSuspensionCFM2
// 

const ParamSuspensionCFM2::Value_optional& ParamSuspensionCFM2::
Value () const
{
  return this->Value_;
}

ParamSuspensionCFM2::Value_optional& ParamSuspensionCFM2::
Value ()
{
  return this->Value_;
}

void ParamSuspensionCFM2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamSuspensionCFM2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamSuspensionCFM3
// 

const ParamSuspensionCFM3::Value_optional& ParamSuspensionCFM3::
Value () const
{
  return this->Value_;
}

ParamSuspensionCFM3::Value_optional& ParamSuspensionCFM3::
Value ()
{
  return this->Value_;
}

void ParamSuspensionCFM3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamSuspensionCFM3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramSuspensionERP
// 

const paramSuspensionERP::Value_type& paramSuspensionERP::
Value () const
{
  return this->Value_.get ();
}

paramSuspensionERP::Value_type& paramSuspensionERP::
Value ()
{
  return this->Value_.get ();
}

void paramSuspensionERP::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramSuspensionERP::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamSuspensionERP
// 

const ParamSuspensionERP::Value_optional& ParamSuspensionERP::
Value () const
{
  return this->Value_;
}

ParamSuspensionERP::Value_optional& ParamSuspensionERP::
Value ()
{
  return this->Value_;
}

void ParamSuspensionERP::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamSuspensionERP::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamSuspensionERP2
// 

const ParamSuspensionERP2::Value_optional& ParamSuspensionERP2::
Value () const
{
  return this->Value_;
}

ParamSuspensionERP2::Value_optional& ParamSuspensionERP2::
Value ()
{
  return this->Value_;
}

void ParamSuspensionERP2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamSuspensionERP2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamSuspensionERP3
// 

const ParamSuspensionERP3::Value_optional& ParamSuspensionERP3::
Value () const
{
  return this->Value_;
}

ParamSuspensionERP3::Value_optional& ParamSuspensionERP3::
Value ()
{
  return this->Value_;
}

void ParamSuspensionERP3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamSuspensionERP3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// paramVel
// 

const paramVel::Value_type& paramVel::
Value () const
{
  return this->Value_.get ();
}

paramVel::Value_type& paramVel::
Value ()
{
  return this->Value_.get ();
}

void paramVel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void paramVel::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}


// ParamVel
// 

const ParamVel::Value_optional& ParamVel::
Value () const
{
  return this->Value_;
}

ParamVel::Value_optional& ParamVel::
Value ()
{
  return this->Value_;
}

void ParamVel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamVel::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamVel2
// 

const ParamVel2::Value_optional& ParamVel2::
Value () const
{
  return this->Value_;
}

ParamVel2::Value_optional& ParamVel2::
Value ()
{
  return this->Value_;
}

void ParamVel2::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamVel2::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ParamVel3
// 

const ParamVel3::Value_optional& ParamVel3::
Value () const
{
  return this->Value_;
}

ParamVel3::Value_optional& ParamVel3::
Value ()
{
  return this->Value_;
}

void ParamVel3::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ParamVel3::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// RSObject
//

RSObject::
RSObject ()
: ::xml_schema::type (),
  Name_ (::xml_schema::flags (), this)
{
}

RSObject::
RSObject (const RSObject& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

RSObject::
RSObject (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RSObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Name",
          "",
          &::xsd::cxx::tree::factory_impl< Name_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Name_)
        {
          ::std::auto_ptr< Name_type > r (
            dynamic_cast< Name_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Name_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

RSObject* RSObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RSObject (*this, f, c);
}

RSObject::
~RSObject ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RSObject >
_xsd_RSObject_type_factory_init (
  "RSObject",
  "");

// Sim
//

Sim::
Sim ()
: ::RSObject (),
  World_ (::xml_schema::flags (), this),
  Space_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this),
  Geom_ (::xml_schema::flags (), this)
{
}

Sim::
Sim (const Sim& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (x, f, c),
  World_ (x.World_, f, this),
  Space_ (x.Space_, f, this),
  Body_ (x.Body_, f, this),
  Geom_ (x.Geom_, f, this)
{
}

Sim::
Sim (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  World_ (f, this),
  Space_ (f, this),
  Body_ (f, this),
  Geom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Sim::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // World
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "World",
          "",
          &::xsd::cxx::tree::factory_impl< World_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< World_type > r (
          dynamic_cast< World_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->World_.push_back (r);
        continue;
      }
    }

    // Space
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Space",
          "",
          &::xsd::cxx::tree::factory_impl< Space_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Space_type > r (
          dynamic_cast< Space_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Space_.push_back (r);
        continue;
      }
    }

    // Body
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body",
          "",
          &::xsd::cxx::tree::factory_impl< Body_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Body_type > r (
          dynamic_cast< Body_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Body_.push_back (r);
        continue;
      }
    }

    // Geom
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Geom",
          "",
          &::xsd::cxx::tree::factory_impl< Geom_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Geom_type > r (
          dynamic_cast< Geom_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Geom_.push_back (r);
        continue;
      }
    }

    break;
  }
}

Sim* Sim::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sim (*this, f, c);
}

Sim::
~Sim ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Sim >
_xsd_Sim_type_factory_init (
  "Sim",
  "");

// World
//

World::
World ()
: ::RSObject (),
  AutoDisableAngularThreshold_ (::xml_schema::flags (), this),
  AutoDisableFlag_ (::xml_schema::flags (), this),
  AutoDisableSteps_ (::xml_schema::flags (), this),
  AutoDisableTime_ (::xml_schema::flags (), this),
  CFM_ (::xml_schema::flags (), this),
  ContactMaxCorrectingVel_ (::xml_schema::flags (), this),
  ContactSurfaceLayer_ (::xml_schema::flags (), this),
  ERP_ (::xml_schema::flags (), this),
  Gravity_ (::xml_schema::flags (), this),
  QuickStepNumIterations_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this)
{
}

World::
World (const World& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (x, f, c),
  AutoDisableAngularThreshold_ (x.AutoDisableAngularThreshold_, f, this),
  AutoDisableFlag_ (x.AutoDisableFlag_, f, this),
  AutoDisableSteps_ (x.AutoDisableSteps_, f, this),
  AutoDisableTime_ (x.AutoDisableTime_, f, this),
  CFM_ (x.CFM_, f, this),
  ContactMaxCorrectingVel_ (x.ContactMaxCorrectingVel_, f, this),
  ContactSurfaceLayer_ (x.ContactSurfaceLayer_, f, this),
  ERP_ (x.ERP_, f, this),
  Gravity_ (x.Gravity_, f, this),
  QuickStepNumIterations_ (x.QuickStepNumIterations_, f, this),
  Body_ (x.Body_, f, this)
{
}

World::
World (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  AutoDisableAngularThreshold_ (f, this),
  AutoDisableFlag_ (f, this),
  AutoDisableSteps_ (f, this),
  AutoDisableTime_ (f, this),
  CFM_ (f, this),
  ContactMaxCorrectingVel_ (f, this),
  ContactSurfaceLayer_ (f, this),
  ERP_ (f, this),
  Gravity_ (f, this),
  QuickStepNumIterations_ (f, this),
  Body_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void World::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AutoDisableAngularThreshold
    //
    if (n.name () == "AutoDisableAngularThreshold" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableAngularThreshold_)
      {
        this->AutoDisableAngularThreshold_.set (AutoDisableAngularThreshold_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableFlag
    //
    if (n.name () == "AutoDisableFlag" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableFlag_)
      {
        this->AutoDisableFlag_.set (AutoDisableFlag_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableSteps
    //
    if (n.name () == "AutoDisableSteps" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableSteps_)
      {
        this->AutoDisableSteps_.set (AutoDisableSteps_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableTime
    //
    if (n.name () == "AutoDisableTime" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableTime_)
      {
        this->AutoDisableTime_.set (AutoDisableTime_traits::create (i, f, this));
        continue;
      }
    }

    // CFM
    //
    if (n.name () == "CFM" && n.namespace_ ().empty ())
    {
      if (!this->CFM_)
      {
        this->CFM_.set (CFM_traits::create (i, f, this));
        continue;
      }
    }

    // ContactMaxCorrectingVel
    //
    if (n.name () == "ContactMaxCorrectingVel" && n.namespace_ ().empty ())
    {
      if (!this->ContactMaxCorrectingVel_)
      {
        this->ContactMaxCorrectingVel_.set (ContactMaxCorrectingVel_traits::create (i, f, this));
        continue;
      }
    }

    // ContactSurfaceLayer
    //
    if (n.name () == "ContactSurfaceLayer" && n.namespace_ ().empty ())
    {
      if (!this->ContactSurfaceLayer_)
      {
        this->ContactSurfaceLayer_.set (ContactSurfaceLayer_traits::create (i, f, this));
        continue;
      }
    }

    // ERP
    //
    if (n.name () == "ERP" && n.namespace_ ().empty ())
    {
      if (!this->ERP_)
      {
        this->ERP_.set (ERP_traits::create (i, f, this));
        continue;
      }
    }

    // Gravity
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Gravity",
          "",
          &::xsd::cxx::tree::factory_impl< Gravity_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Gravity_)
        {
          ::std::auto_ptr< Gravity_type > r (
            dynamic_cast< Gravity_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Gravity_.set (r);
          continue;
        }
      }
    }

    // QuickStepNumIterations
    //
    if (n.name () == "QuickStepNumIterations" && n.namespace_ ().empty ())
    {
      if (!this->QuickStepNumIterations_)
      {
        this->QuickStepNumIterations_.set (QuickStepNumIterations_traits::create (i, f, this));
        continue;
      }
    }

    // Body
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body",
          "",
          &::xsd::cxx::tree::factory_impl< Body_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Body_type > r (
          dynamic_cast< Body_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Body_.push_back (r);
        continue;
      }
    }

    break;
  }
}

World* World::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class World (*this, f, c);
}

World::
~World ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, World >
_xsd_World_type_factory_init (
  "World",
  "");

// GeomObject
//

GeomObject::
GeomObject ()
: ::RSObject (),
  Enable_ (::xml_schema::flags (), this),
  CategoryBits_ (::xml_schema::flags (), this),
  CollideBits_ (::xml_schema::flags (), this),
  Position_ (::xml_schema::flags (), this),
  Quaternion_ (::xml_schema::flags (), this),
  Rotation_ (::xml_schema::flags (), this)
{
}

GeomObject::
GeomObject (const GeomObject& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Enable_ (x.Enable_, f, this),
  CategoryBits_ (x.CategoryBits_, f, this),
  CollideBits_ (x.CollideBits_, f, this),
  Position_ (x.Position_, f, this),
  Quaternion_ (x.Quaternion_, f, this),
  Rotation_ (x.Rotation_, f, this)
{
}

GeomObject::
GeomObject (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Enable_ (f, this),
  CategoryBits_ (f, this),
  CollideBits_ (f, this),
  Position_ (f, this),
  Quaternion_ (f, this),
  Rotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Enable
    //
    if (n.name () == "Enable" && n.namespace_ ().empty ())
    {
      if (!this->Enable_)
      {
        this->Enable_.set (Enable_traits::create (i, f, this));
        continue;
      }
    }

    // CategoryBits
    //
    if (n.name () == "CategoryBits" && n.namespace_ ().empty ())
    {
      if (!this->CategoryBits_)
      {
        this->CategoryBits_.set (CategoryBits_traits::create (i, f, this));
        continue;
      }
    }

    // CollideBits
    //
    if (n.name () == "CollideBits" && n.namespace_ ().empty ())
    {
      if (!this->CollideBits_)
      {
        this->CollideBits_.set (CollideBits_traits::create (i, f, this));
        continue;
      }
    }

    // Position
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Position",
          "",
          &::xsd::cxx::tree::factory_impl< Position_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Position_)
        {
          ::std::auto_ptr< Position_type > r (
            dynamic_cast< Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Position_.set (r);
          continue;
        }
      }
    }

    // Quaternion
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Quaternion",
          "",
          &::xsd::cxx::tree::factory_impl< Quaternion_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Quaternion_)
        {
          ::std::auto_ptr< Quaternion_type > r (
            dynamic_cast< Quaternion_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Quaternion_.set (r);
          continue;
        }
      }
    }

    // Rotation
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Rotation",
          "",
          &::xsd::cxx::tree::factory_impl< Rotation_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Rotation_)
        {
          ::std::auto_ptr< Rotation_type > r (
            dynamic_cast< Rotation_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Rotation_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

GeomObject* GeomObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomObject (*this, f, c);
}

GeomObject::
~GeomObject ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomObject >
_xsd_GeomObject_type_factory_init (
  "GeomObject",
  "");

// SpaceBase
//

SpaceBase::
SpaceBase ()
: ::GeomObject (),
  Geom_ (::xml_schema::flags (), this)
{
}

SpaceBase::
SpaceBase (const SpaceBase& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Geom_ (x.Geom_, f, this)
{
}

SpaceBase::
SpaceBase (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Geom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void SpaceBase::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Geom
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Geom",
          "",
          &::xsd::cxx::tree::factory_impl< Geom_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Geom_type > r (
          dynamic_cast< Geom_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Geom_.push_back (r);
        continue;
      }
    }

    break;
  }
}

SpaceBase* SpaceBase::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SpaceBase (*this, f, c);
}

SpaceBase::
~SpaceBase ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SpaceBase >
_xsd_SpaceBase_type_factory_init (
  "SpaceBase",
  "");

// SimpleSpace
//

SimpleSpace::
SimpleSpace ()
: ::SpaceBase ()
{
}

SimpleSpace::
SimpleSpace (const SimpleSpace& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SpaceBase (x, f, c)
{
}

SimpleSpace::
SimpleSpace (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SpaceBase (e, f, c)
{
}

SimpleSpace* SimpleSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimpleSpace (*this, f, c);
}

SimpleSpace::
~SimpleSpace ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SimpleSpace >
_xsd_SimpleSpace_type_factory_init (
  "SimpleSpace",
  "");

// Body
//

Body::
Body ()
: ::RSObject (),
  Space_ (::xml_schema::flags (), this),
  World_ (::xml_schema::flags (), this),
  Enabled_ (::xml_schema::flags (), this),
  AngularVel_ (::xml_schema::flags (), this),
  FiniteRotationAxis_ (::xml_schema::flags (), this),
  FiniteRotationMode_ (::xml_schema::flags (), this),
  Force_ (::xml_schema::flags (), this),
  GravityMode_ (::xml_schema::flags (), this),
  LinearVel_ (::xml_schema::flags (), this),
  Mass_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this),
  Position_ (::xml_schema::flags (), this),
  Quaternion_ (::xml_schema::flags (), this),
  Rotation_ (::xml_schema::flags (), this)
{
}

Body::
Body (const Body& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Space_ (x.Space_, f, this),
  World_ (x.World_, f, this),
  Enabled_ (x.Enabled_, f, this),
  AngularVel_ (x.AngularVel_, f, this),
  FiniteRotationAxis_ (x.FiniteRotationAxis_, f, this),
  FiniteRotationMode_ (x.FiniteRotationMode_, f, this),
  Force_ (x.Force_, f, this),
  GravityMode_ (x.GravityMode_, f, this),
  LinearVel_ (x.LinearVel_, f, this),
  Mass_ (x.Mass_, f, this),
  Torque_ (x.Torque_, f, this),
  Position_ (x.Position_, f, this),
  Quaternion_ (x.Quaternion_, f, this),
  Rotation_ (x.Rotation_, f, this)
{
}

Body::
Body (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Space_ (f, this),
  World_ (f, this),
  Enabled_ (f, this),
  AngularVel_ (f, this),
  FiniteRotationAxis_ (f, this),
  FiniteRotationMode_ (f, this),
  Force_ (f, this),
  GravityMode_ (f, this),
  LinearVel_ (f, this),
  Mass_ (f, this),
  Torque_ (f, this),
  Position_ (f, this),
  Quaternion_ (f, this),
  Rotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Space
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Space",
          "",
          &::xsd::cxx::tree::factory_impl< Space_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Space_)
        {
          ::std::auto_ptr< Space_type > r (
            dynamic_cast< Space_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Space_.set (r);
          continue;
        }
      }
    }

    // World
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "World",
          "",
          &::xsd::cxx::tree::factory_impl< World_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->World_)
        {
          ::std::auto_ptr< World_type > r (
            dynamic_cast< World_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->World_.set (r);
          continue;
        }
      }
    }

    // Enabled
    //
    if (n.name () == "Enabled" && n.namespace_ ().empty ())
    {
      if (!this->Enabled_)
      {
        this->Enabled_.set (Enabled_traits::create (i, f, this));
        continue;
      }
    }

    // AngularVel
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "AngularVel",
          "",
          &::xsd::cxx::tree::factory_impl< AngularVel_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->AngularVel_)
        {
          ::std::auto_ptr< AngularVel_type > r (
            dynamic_cast< AngularVel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AngularVel_.set (r);
          continue;
        }
      }
    }

    // FiniteRotationAxis
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "FiniteRotationAxis",
          "",
          &::xsd::cxx::tree::factory_impl< FiniteRotationAxis_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->FiniteRotationAxis_)
        {
          ::std::auto_ptr< FiniteRotationAxis_type > r (
            dynamic_cast< FiniteRotationAxis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->FiniteRotationAxis_.set (r);
          continue;
        }
      }
    }

    // FiniteRotationMode
    //
    if (n.name () == "FiniteRotationMode" && n.namespace_ ().empty ())
    {
      if (!this->FiniteRotationMode_)
      {
        this->FiniteRotationMode_.set (FiniteRotationMode_traits::create (i, f, this));
        continue;
      }
    }

    // Force
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Force",
          "",
          &::xsd::cxx::tree::factory_impl< Force_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Force_)
        {
          ::std::auto_ptr< Force_type > r (
            dynamic_cast< Force_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Force_.set (r);
          continue;
        }
      }
    }

    // GravityMode
    //
    if (n.name () == "GravityMode" && n.namespace_ ().empty ())
    {
      if (!this->GravityMode_)
      {
        this->GravityMode_.set (GravityMode_traits::create (i, f, this));
        continue;
      }
    }

    // LinearVel
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "LinearVel",
          "",
          &::xsd::cxx::tree::factory_impl< LinearVel_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->LinearVel_)
        {
          ::std::auto_ptr< LinearVel_type > r (
            dynamic_cast< LinearVel_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->LinearVel_.set (r);
          continue;
        }
      }
    }

    // Mass
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Mass",
          "",
          &::xsd::cxx::tree::factory_impl< Mass_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Mass_)
        {
          ::std::auto_ptr< Mass_type > r (
            dynamic_cast< Mass_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Mass_.set (r);
          continue;
        }
      }
    }

    // Torque
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Torque",
          "",
          &::xsd::cxx::tree::factory_impl< Torque_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Torque_)
        {
          ::std::auto_ptr< Torque_type > r (
            dynamic_cast< Torque_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Torque_.set (r);
          continue;
        }
      }
    }

    // Position
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Position",
          "",
          &::xsd::cxx::tree::factory_impl< Position_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Position_)
        {
          ::std::auto_ptr< Position_type > r (
            dynamic_cast< Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Position_.set (r);
          continue;
        }
      }
    }

    // Quaternion
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Quaternion",
          "",
          &::xsd::cxx::tree::factory_impl< Quaternion_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Quaternion_)
        {
          ::std::auto_ptr< Quaternion_type > r (
            dynamic_cast< Quaternion_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Quaternion_.set (r);
          continue;
        }
      }
    }

    // Rotation
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Rotation",
          "",
          &::xsd::cxx::tree::factory_impl< Rotation_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Rotation_)
        {
          ::std::auto_ptr< Rotation_type > r (
            dynamic_cast< Rotation_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Rotation_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

Body* Body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Body (*this, f, c);
}

Body::
~Body ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Body >
_xsd_Body_type_factory_init (
  "Body",
  "");

// Mass
//

Mass::
Mass ()
: ::RSObject ()
{
}

Mass::
Mass (const Mass& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (x, f, c)
{
}

Mass::
Mass (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (e, f, c)
{
}

Mass* Mass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Mass (*this, f, c);
}

Mass::
~Mass ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Mass >
_xsd_Mass_type_factory_init (
  "Mass",
  "");

// BoxTotalMass
//

BoxTotalMass::
BoxTotalMass ()
: ::Mass (),
  M_ (::xml_schema::flags (), this),
  LX_ (::xml_schema::flags (), this),
  LY_ (::xml_schema::flags (), this),
  LZ_ (::xml_schema::flags (), this)
{
}

BoxTotalMass::
BoxTotalMass (const BoxTotalMass& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Mass (x, f, c),
  M_ (x.M_, f, this),
  LX_ (x.LX_, f, this),
  LY_ (x.LY_, f, this),
  LZ_ (x.LZ_, f, this)
{
}

BoxTotalMass::
BoxTotalMass (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Mass (e, f | ::xml_schema::flags::base, c),
  M_ (f, this),
  LX_ (f, this),
  LY_ (f, this),
  LZ_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void BoxTotalMass::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Mass::parse (p, f);

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "M" && n.namespace_ ().empty ())
    {
      this->M_.set (M_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "LX" && n.namespace_ ().empty ())
    {
      this->LX_.set (LX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "LY" && n.namespace_ ().empty ())
    {
      this->LY_.set (LY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "LZ" && n.namespace_ ().empty ())
    {
      this->LZ_.set (LZ_traits::create (i, f, this));
      continue;
    }
  }
}

BoxTotalMass* BoxTotalMass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoxTotalMass (*this, f, c);
}

BoxTotalMass::
~BoxTotalMass ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, BoxTotalMass >
_xsd_BoxTotalMass_type_factory_init (
  "BoxTotalMass",
  "");

// Joint
//

Joint::
Joint ()
: ::RSObject (),
  Feedback_ (::xml_schema::flags (), this),
  Body1_ (::xml_schema::flags (), this),
  Body2_ (::xml_schema::flags (), this),
  Param_ (::xml_schema::flags (), this)
{
}

Joint::
Joint (const Joint& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Feedback_ (x.Feedback_, f, this),
  Body1_ (x.Body1_, f, this),
  Body2_ (x.Body2_, f, this),
  Param_ (x.Param_, f, this)
{
}

Joint::
Joint (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Feedback_ (f, this),
  Body1_ (f, this),
  Body2_ (f, this),
  Param_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Joint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Feedback
    //
    if (n.name () == "Feedback" && n.namespace_ ().empty ())
    {
      if (!this->Feedback_)
      {
        this->Feedback_.set (Feedback_traits::create (i, f, this));
        continue;
      }
    }

    // Body1
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body1",
          "",
          &::xsd::cxx::tree::factory_impl< Body1_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Body1_)
        {
          ::std::auto_ptr< Body1_type > r (
            dynamic_cast< Body1_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Body1_.set (r);
          continue;
        }
      }
    }

    // Body2
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body2",
          "",
          &::xsd::cxx::tree::factory_impl< Body2_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Body2_)
        {
          ::std::auto_ptr< Body2_type > r (
            dynamic_cast< Body2_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Body2_.set (r);
          continue;
        }
      }
    }

    // Param
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Param",
          "",
          &::xsd::cxx::tree::factory_impl< Param_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< Param_type > r (
          dynamic_cast< Param_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->Param_.push_back (r);
        continue;
      }
    }

    break;
  }
}

Joint* Joint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Joint (*this, f, c);
}

Joint::
~Joint ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Joint >
_xsd_Joint_type_factory_init (
  "Joint",
  "");

// HingeJoint
//

HingeJoint::
HingeJoint ()
: ::Joint (),
  Anchor_ (::xml_schema::flags (), this),
  Axis_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this)
{
}

HingeJoint::
HingeJoint (const HingeJoint& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Joint (x, f, c),
  Anchor_ (x.Anchor_, f, this),
  Axis_ (x.Axis_, f, this),
  Torque_ (x.Torque_, f, this)
{
}

HingeJoint::
HingeJoint (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Joint (e, f | ::xml_schema::flags::base, c),
  Anchor_ (f, this),
  Axis_ (f, this),
  Torque_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void HingeJoint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Joint::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Anchor
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Anchor",
          "",
          &::xsd::cxx::tree::factory_impl< Anchor_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Anchor_)
        {
          ::std::auto_ptr< Anchor_type > r (
            dynamic_cast< Anchor_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Anchor_.set (r);
          continue;
        }
      }
    }

    // Axis
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Axis",
          "",
          &::xsd::cxx::tree::factory_impl< Axis_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Axis_)
        {
          ::std::auto_ptr< Axis_type > r (
            dynamic_cast< Axis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Axis_.set (r);
          continue;
        }
      }
    }

    // Torque
    //
    if (n.name () == "Torque" && n.namespace_ ().empty ())
    {
      if (!this->Torque_)
      {
        this->Torque_.set (Torque_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

HingeJoint* HingeJoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HingeJoint (*this, f, c);
}

HingeJoint::
~HingeJoint ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, HingeJoint >
_xsd_HingeJoint_type_factory_init (
  "HingeJoint",
  "");

// HingeJoint2
//

HingeJoint2::
HingeJoint2 ()
: ::Joint (),
  Anchor_ (::xml_schema::flags (), this),
  Axis1_ (::xml_schema::flags (), this),
  Axis2_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this)
{
}

HingeJoint2::
HingeJoint2 (const HingeJoint2& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Joint (x, f, c),
  Anchor_ (x.Anchor_, f, this),
  Axis1_ (x.Axis1_, f, this),
  Axis2_ (x.Axis2_, f, this),
  Torque_ (x.Torque_, f, this)
{
}

HingeJoint2::
HingeJoint2 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Joint (e, f | ::xml_schema::flags::base, c),
  Anchor_ (f, this),
  Axis1_ (f, this),
  Axis2_ (f, this),
  Torque_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void HingeJoint2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Joint::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Anchor
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Anchor",
          "",
          &::xsd::cxx::tree::factory_impl< Anchor_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Anchor_)
        {
          ::std::auto_ptr< Anchor_type > r (
            dynamic_cast< Anchor_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Anchor_.set (r);
          continue;
        }
      }
    }

    // Axis1
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Axis1",
          "",
          &::xsd::cxx::tree::factory_impl< Axis1_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Axis1_)
        {
          ::std::auto_ptr< Axis1_type > r (
            dynamic_cast< Axis1_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Axis1_.set (r);
          continue;
        }
      }
    }

    // Axis2
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Axis2",
          "",
          &::xsd::cxx::tree::factory_impl< Axis2_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Axis2_)
        {
          ::std::auto_ptr< Axis2_type > r (
            dynamic_cast< Axis2_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Axis2_.set (r);
          continue;
        }
      }
    }

    // Torque
    //
    if (n.name () == "Torque" && n.namespace_ ().empty ())
    {
      if (!this->Torque_)
      {
        this->Torque_.set (Torque_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

HingeJoint2* HingeJoint2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HingeJoint2 (*this, f, c);
}

HingeJoint2::
~HingeJoint2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, HingeJoint2 >
_xsd_HingeJoint2_type_factory_init (
  "HingeJoint2",
  "");

// GeomBox
//

GeomBox::
GeomBox ()
: ::GeomObject (),
  Lengths_ (::xml_schema::flags (), this)
{
}

GeomBox::
GeomBox (const GeomBox& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Lengths_ (x.Lengths_, f, this)
{
}

GeomBox::
GeomBox (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Lengths_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomBox::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Lengths
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Lengths",
          "",
          &::xsd::cxx::tree::factory_impl< Lengths_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Lengths_)
        {
          ::std::auto_ptr< Lengths_type > r (
            dynamic_cast< Lengths_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Lengths_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

GeomBox* GeomBox::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomBox (*this, f, c);
}

GeomBox::
~GeomBox ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomBox >
_xsd_GeomBox_type_factory_init (
  "GeomBox",
  "");

// GeomCylinder
//

GeomCylinder::
GeomCylinder ()
: ::GeomObject (),
  Length_ (::xml_schema::flags (), this),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomCylinder::
GeomCylinder (const GeomCylinder& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Length_ (x.Length_, f, this),
  Radius_ (x.Radius_, f, this)
{
}

GeomCylinder::
GeomCylinder (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Length_ (f, this),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomCylinder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Length
    //
    if (n.name () == "Length" && n.namespace_ ().empty ())
    {
      if (!this->Length_)
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }
    }

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomCylinder* GeomCylinder::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomCylinder (*this, f, c);
}

GeomCylinder::
~GeomCylinder ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomCylinder >
_xsd_GeomCylinder_type_factory_init (
  "GeomCylinder",
  "");

// GeomCapsule
//

GeomCapsule::
GeomCapsule ()
: ::GeomObject (),
  Length_ (::xml_schema::flags (), this),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomCapsule::
GeomCapsule (const GeomCapsule& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Length_ (x.Length_, f, this),
  Radius_ (x.Radius_, f, this)
{
}

GeomCapsule::
GeomCapsule (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Length_ (f, this),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomCapsule::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Length
    //
    if (n.name () == "Length" && n.namespace_ ().empty ())
    {
      if (!this->Length_)
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }
    }

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomCapsule* GeomCapsule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomCapsule (*this, f, c);
}

GeomCapsule::
~GeomCapsule ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomCapsule >
_xsd_GeomCapsule_type_factory_init (
  "GeomCapsule",
  "");

// GeomSphere
//

GeomSphere::
GeomSphere ()
: ::GeomObject (),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomSphere::
GeomSphere (const GeomSphere& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Radius_ (x.Radius_, f, this)
{
}

GeomSphere::
GeomSphere (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomSphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomSphere* GeomSphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomSphere (*this, f, c);
}

GeomSphere::
~GeomSphere ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomSphere >
_xsd_GeomSphere_type_factory_init (
  "GeomSphere",
  "");

// GeomPlane
//

GeomPlane::
GeomPlane ()
: ::GeomObject (),
  Space_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this),
  Enabled_ (::xml_schema::flags (), this)
{
}

GeomPlane::
GeomPlane (const GeomPlane& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Space_ (x.Space_, f, this),
  Body_ (x.Body_, f, this),
  Enabled_ (x.Enabled_, f, this)
{
}

GeomPlane::
GeomPlane (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Space_ (f, this),
  Body_ (f, this),
  Enabled_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomPlane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Space
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Space",
          "",
          &::xsd::cxx::tree::factory_impl< Space_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Space_)
        {
          ::std::auto_ptr< Space_type > r (
            dynamic_cast< Space_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Space_.set (r);
          continue;
        }
      }
    }

    // Body
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Body",
          "",
          &::xsd::cxx::tree::factory_impl< Body_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Body_)
        {
          ::std::auto_ptr< Body_type > r (
            dynamic_cast< Body_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Body_.set (r);
          continue;
        }
      }
    }

    // Enabled
    //
    if (n.name () == "Enabled" && n.namespace_ ().empty ())
    {
      if (!this->Enabled_)
      {
        this->Enabled_.set (Enabled_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomPlane* GeomPlane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomPlane (*this, f, c);
}

GeomPlane::
~GeomPlane ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GeomPlane >
_xsd_GeomPlane_type_factory_init (
  "GeomPlane",
  "");

// Rotation
//

Rotation::
Rotation (const Column1_type& Column1,
          const Column2_type& Column2,
          const Column3_type& Column3)
: ::RSObject (),
  Column1_ (Column1, ::xml_schema::flags (), this),
  Column2_ (Column2, ::xml_schema::flags (), this),
  Column3_ (Column3, ::xml_schema::flags (), this)
{
}

Rotation::
Rotation (::std::auto_ptr< Column1_type >& Column1,
          ::std::auto_ptr< Column2_type >& Column2,
          ::std::auto_ptr< Column3_type >& Column3)
: ::RSObject (),
  Column1_ (Column1, ::xml_schema::flags (), this),
  Column2_ (Column2, ::xml_schema::flags (), this),
  Column3_ (Column3, ::xml_schema::flags (), this)
{
}

Rotation::
Rotation (const Rotation& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Column1_ (x.Column1_, f, this),
  Column2_ (x.Column2_, f, this),
  Column3_ (x.Column3_, f, this)
{
}

Rotation::
Rotation (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Column1_ (f, this),
  Column2_ (f, this),
  Column3_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Rotation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Column1
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Column1",
          "",
          &::xsd::cxx::tree::factory_impl< Column1_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Column1_.present ())
        {
          ::std::auto_ptr< Column1_type > r (
            dynamic_cast< Column1_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Column1_.set (r);
          continue;
        }
      }
    }

    // Column2
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Column2",
          "",
          &::xsd::cxx::tree::factory_impl< Column2_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Column2_.present ())
        {
          ::std::auto_ptr< Column2_type > r (
            dynamic_cast< Column2_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Column2_.set (r);
          continue;
        }
      }
    }

    // Column3
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Column3",
          "",
          &::xsd::cxx::tree::factory_impl< Column3_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Column3_.present ())
        {
          ::std::auto_ptr< Column3_type > r (
            dynamic_cast< Column3_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Column3_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Column1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column1",
      "");
  }

  if (!Column2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column2",
      "");
  }

  if (!Column3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column3",
      "");
  }
}

Rotation* Rotation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Rotation (*this, f, c);
}

Rotation::
~Rotation ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Rotation >
_xsd_Rotation_type_factory_init (
  "Rotation",
  "");

// Vector
//

Vector::
Vector ()
: ::xml_schema::type (),
  X_ (::xml_schema::flags (), this),
  Y_ (::xml_schema::flags (), this),
  Z_ (::xml_schema::flags (), this)
{
}

Vector::
Vector (const Vector& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

Vector::
Vector (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (f, this),
  Y_ (f, this),
  Z_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }
  }
}

Vector* Vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vector (*this, f, c);
}

Vector::
~Vector ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Vector >
_xsd_Vector_type_factory_init (
  "Vector",
  "");

// Quaternion
//

Quaternion::
Quaternion ()
: ::xml_schema::type (),
  W_ (::xml_schema::flags (), this),
  I_ (::xml_schema::flags (), this),
  J_ (::xml_schema::flags (), this),
  K_ (::xml_schema::flags (), this)
{
}

Quaternion::
Quaternion (const Quaternion& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  W_ (x.W_, f, this),
  I_ (x.I_, f, this),
  J_ (x.J_, f, this),
  K_ (x.K_, f, this)
{
}

Quaternion::
Quaternion (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  W_ (f, this),
  I_ (f, this),
  J_ (f, this),
  K_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Quaternion::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "W" && n.namespace_ ().empty ())
    {
      this->W_.set (W_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "I" && n.namespace_ ().empty ())
    {
      this->I_.set (I_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "J" && n.namespace_ ().empty ())
    {
      this->J_.set (J_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "K" && n.namespace_ ().empty ())
    {
      this->K_.set (K_traits::create (i, f, this));
      continue;
    }
  }
}

Quaternion* Quaternion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Quaternion (*this, f, c);
}

Quaternion::
~Quaternion ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Quaternion >
_xsd_Quaternion_type_factory_init (
  "Quaternion",
  "");

// Foo
//

Foo::
Foo ()
: ::RSObject ()
{
}

Foo::
Foo (const Foo& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (x, f, c)
{
}

Foo::
Foo (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (e, f, c)
{
}

Foo* Foo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Foo (*this, f, c);
}

Foo::
~Foo ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Foo >
_xsd_Foo_type_factory_init (
  "Foo",
  "");

// Param
//

Param::
Param ()
: ::xml_schema::type ()
{
}

Param::
Param (const Param& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

Param::
Param (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

Param::
Param (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

Param::
Param (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

Param* Param::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Param (*this, f, c);
}

Param::
~Param ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, Param >
_xsd_Param_type_factory_init (
  "Param",
  "");

// paramBounce
//

paramBounce::
paramBounce (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramBounce::
paramBounce (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramBounce::
paramBounce (const paramBounce& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramBounce::
paramBounce (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramBounce::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramBounce* paramBounce::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramBounce (*this, f, c);
}

paramBounce::
~paramBounce ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramBounce >
_xsd_paramBounce_type_factory_init (
  "paramBounce",
  "");

// ParamBounce
//

ParamBounce::
ParamBounce ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamBounce::
ParamBounce (const ParamBounce& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamBounce::
ParamBounce (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamBounce::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamBounce* ParamBounce::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamBounce (*this, f, c);
}

ParamBounce::
~ParamBounce ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamBounce >
_xsd_ParamBounce_type_factory_init (
  "ParamBounce",
  "");

// ParamBounce2
//

ParamBounce2::
ParamBounce2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamBounce2::
ParamBounce2 (const ParamBounce2& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamBounce2::
ParamBounce2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamBounce2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamBounce2* ParamBounce2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamBounce2 (*this, f, c);
}

ParamBounce2::
~ParamBounce2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamBounce2 >
_xsd_ParamBounce2_type_factory_init (
  "ParamBounce2",
  "");

// ParamBounce3
//

ParamBounce3::
ParamBounce3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamBounce3::
ParamBounce3 (const ParamBounce3& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamBounce3::
ParamBounce3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamBounce3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamBounce3* ParamBounce3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamBounce3 (*this, f, c);
}

ParamBounce3::
~ParamBounce3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamBounce3 >
_xsd_ParamBounce3_type_factory_init (
  "ParamBounce3",
  "");

// paramCFM
//

paramCFM::
paramCFM (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramCFM::
paramCFM (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramCFM::
paramCFM (const paramCFM& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramCFM::
paramCFM (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramCFM::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramCFM* paramCFM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramCFM (*this, f, c);
}

paramCFM::
~paramCFM ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramCFM >
_xsd_paramCFM_type_factory_init (
  "paramCFM",
  "");

// ParamCFM
//

ParamCFM::
ParamCFM ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamCFM::
ParamCFM (const ParamCFM& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamCFM::
ParamCFM (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamCFM::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamCFM* ParamCFM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamCFM (*this, f, c);
}

ParamCFM::
~ParamCFM ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamCFM >
_xsd_ParamCFM_type_factory_init (
  "ParamCFM",
  "");

// ParamCFM2
//

ParamCFM2::
ParamCFM2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamCFM2::
ParamCFM2 (const ParamCFM2& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamCFM2::
ParamCFM2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamCFM2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamCFM2* ParamCFM2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamCFM2 (*this, f, c);
}

ParamCFM2::
~ParamCFM2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamCFM2 >
_xsd_ParamCFM2_type_factory_init (
  "ParamCFM2",
  "");

// ParamCFM3
//

ParamCFM3::
ParamCFM3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamCFM3::
ParamCFM3 (const ParamCFM3& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamCFM3::
ParamCFM3 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamCFM3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamCFM3* ParamCFM3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamCFM3 (*this, f, c);
}

ParamCFM3::
~ParamCFM3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamCFM3 >
_xsd_ParamCFM3_type_factory_init (
  "ParamCFM3",
  "");

// paramFMax
//

paramFMax::
paramFMax (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramFMax::
paramFMax (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramFMax::
paramFMax (const paramFMax& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramFMax::
paramFMax (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramFMax::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramFMax* paramFMax::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramFMax (*this, f, c);
}

paramFMax::
~paramFMax ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramFMax >
_xsd_paramFMax_type_factory_init (
  "paramFMax",
  "");

// ParamFMax
//

ParamFMax::
ParamFMax ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamFMax::
ParamFMax (const ParamFMax& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamFMax::
ParamFMax (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamFMax::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamFMax* ParamFMax::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamFMax (*this, f, c);
}

ParamFMax::
~ParamFMax ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamFMax >
_xsd_ParamFMax_type_factory_init (
  "ParamFMax",
  "");

// ParamFMax2
//

ParamFMax2::
ParamFMax2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamFMax2::
ParamFMax2 (const ParamFMax2& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamFMax2::
ParamFMax2 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamFMax2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamFMax2* ParamFMax2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamFMax2 (*this, f, c);
}

ParamFMax2::
~ParamFMax2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamFMax2 >
_xsd_ParamFMax2_type_factory_init (
  "ParamFMax2",
  "");

// ParamFMax3
//

ParamFMax3::
ParamFMax3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamFMax3::
ParamFMax3 (const ParamFMax3& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamFMax3::
ParamFMax3 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamFMax3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamFMax3* ParamFMax3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamFMax3 (*this, f, c);
}

ParamFMax3::
~ParamFMax3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamFMax3 >
_xsd_ParamFMax3_type_factory_init (
  "ParamFMax3",
  "");

// paramFudgeFactor
//

paramFudgeFactor::
paramFudgeFactor (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramFudgeFactor::
paramFudgeFactor (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramFudgeFactor::
paramFudgeFactor (const paramFudgeFactor& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramFudgeFactor::
paramFudgeFactor (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramFudgeFactor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramFudgeFactor* paramFudgeFactor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramFudgeFactor (*this, f, c);
}

paramFudgeFactor::
~paramFudgeFactor ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramFudgeFactor >
_xsd_paramFudgeFactor_type_factory_init (
  "paramFudgeFactor",
  "");

// ParamFudgeFactor
//

ParamFudgeFactor::
ParamFudgeFactor ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamFudgeFactor::
ParamFudgeFactor (const ParamFudgeFactor& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamFudgeFactor::
ParamFudgeFactor (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamFudgeFactor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamFudgeFactor* ParamFudgeFactor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamFudgeFactor (*this, f, c);
}

ParamFudgeFactor::
~ParamFudgeFactor ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamFudgeFactor >
_xsd_ParamFudgeFactor_type_factory_init (
  "ParamFudgeFactor",
  "");

// ParamFudgeFactor2
//

ParamFudgeFactor2::
ParamFudgeFactor2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamFudgeFactor2::
ParamFudgeFactor2 (const ParamFudgeFactor2& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamFudgeFactor2::
ParamFudgeFactor2 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamFudgeFactor2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamFudgeFactor2* ParamFudgeFactor2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamFudgeFactor2 (*this, f, c);
}

ParamFudgeFactor2::
~ParamFudgeFactor2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamFudgeFactor2 >
_xsd_ParamFudgeFactor2_type_factory_init (
  "ParamFudgeFactor2",
  "");

// ParamFudgeFactor3
//

ParamFudgeFactor3::
ParamFudgeFactor3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamFudgeFactor3::
ParamFudgeFactor3 (const ParamFudgeFactor3& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamFudgeFactor3::
ParamFudgeFactor3 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamFudgeFactor3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamFudgeFactor3* ParamFudgeFactor3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamFudgeFactor3 (*this, f, c);
}

ParamFudgeFactor3::
~ParamFudgeFactor3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamFudgeFactor3 >
_xsd_ParamFudgeFactor3_type_factory_init (
  "ParamFudgeFactor3",
  "");

// ParamGroup
//

ParamGroup::
ParamGroup ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamGroup::
ParamGroup (const ParamGroup& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamGroup::
ParamGroup (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamGroup::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamGroup* ParamGroup::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamGroup (*this, f, c);
}

ParamGroup::
~ParamGroup ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamGroup >
_xsd_ParamGroup_type_factory_init (
  "ParamGroup",
  "");

// paramHiStop
//

paramHiStop::
paramHiStop (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramHiStop::
paramHiStop (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramHiStop::
paramHiStop (const paramHiStop& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramHiStop::
paramHiStop (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramHiStop::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramHiStop* paramHiStop::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramHiStop (*this, f, c);
}

paramHiStop::
~paramHiStop ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramHiStop >
_xsd_paramHiStop_type_factory_init (
  "paramHiStop",
  "");

// ParamHiStop
//

ParamHiStop::
ParamHiStop ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamHiStop::
ParamHiStop (const ParamHiStop& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamHiStop::
ParamHiStop (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamHiStop::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamHiStop* ParamHiStop::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamHiStop (*this, f, c);
}

ParamHiStop::
~ParamHiStop ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamHiStop >
_xsd_ParamHiStop_type_factory_init (
  "ParamHiStop",
  "");

// ParamHiStop2
//

ParamHiStop2::
ParamHiStop2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamHiStop2::
ParamHiStop2 (const ParamHiStop2& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamHiStop2::
ParamHiStop2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamHiStop2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamHiStop2* ParamHiStop2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamHiStop2 (*this, f, c);
}

ParamHiStop2::
~ParamHiStop2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamHiStop2 >
_xsd_ParamHiStop2_type_factory_init (
  "ParamHiStop2",
  "");

// ParamHiStop3
//

ParamHiStop3::
ParamHiStop3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamHiStop3::
ParamHiStop3 (const ParamHiStop3& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamHiStop3::
ParamHiStop3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamHiStop3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamHiStop3* ParamHiStop3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamHiStop3 (*this, f, c);
}

ParamHiStop3::
~ParamHiStop3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamHiStop3 >
_xsd_ParamHiStop3_type_factory_init (
  "ParamHiStop3",
  "");

// paramLoStop
//

paramLoStop::
paramLoStop (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramLoStop::
paramLoStop (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramLoStop::
paramLoStop (const paramLoStop& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramLoStop::
paramLoStop (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramLoStop::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramLoStop* paramLoStop::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramLoStop (*this, f, c);
}

paramLoStop::
~paramLoStop ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramLoStop >
_xsd_paramLoStop_type_factory_init (
  "paramLoStop",
  "");

// ParamLoStop
//

ParamLoStop::
ParamLoStop ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamLoStop::
ParamLoStop (const ParamLoStop& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamLoStop::
ParamLoStop (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamLoStop::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamLoStop* ParamLoStop::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamLoStop (*this, f, c);
}

ParamLoStop::
~ParamLoStop ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamLoStop >
_xsd_ParamLoStop_type_factory_init (
  "ParamLoStop",
  "");

// ParamLoStop2
//

ParamLoStop2::
ParamLoStop2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamLoStop2::
ParamLoStop2 (const ParamLoStop2& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamLoStop2::
ParamLoStop2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamLoStop2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamLoStop2* ParamLoStop2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamLoStop2 (*this, f, c);
}

ParamLoStop2::
~ParamLoStop2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamLoStop2 >
_xsd_ParamLoStop2_type_factory_init (
  "ParamLoStop2",
  "");

// ParamLoStop3
//

ParamLoStop3::
ParamLoStop3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamLoStop3::
ParamLoStop3 (const ParamLoStop3& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamLoStop3::
ParamLoStop3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamLoStop3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamLoStop3* ParamLoStop3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamLoStop3 (*this, f, c);
}

ParamLoStop3::
~ParamLoStop3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamLoStop3 >
_xsd_ParamLoStop3_type_factory_init (
  "ParamLoStop3",
  "");

// paramStopCFM
//

paramStopCFM::
paramStopCFM (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramStopCFM::
paramStopCFM (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramStopCFM::
paramStopCFM (const paramStopCFM& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramStopCFM::
paramStopCFM (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramStopCFM::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramStopCFM* paramStopCFM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramStopCFM (*this, f, c);
}

paramStopCFM::
~paramStopCFM ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramStopCFM >
_xsd_paramStopCFM_type_factory_init (
  "paramStopCFM",
  "");

// ParamStopCFM
//

ParamStopCFM::
ParamStopCFM ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamStopCFM::
ParamStopCFM (const ParamStopCFM& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamStopCFM::
ParamStopCFM (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamStopCFM::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamStopCFM* ParamStopCFM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamStopCFM (*this, f, c);
}

ParamStopCFM::
~ParamStopCFM ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamStopCFM >
_xsd_ParamStopCFM_type_factory_init (
  "ParamStopCFM",
  "");

// ParamStopCFM2
//

ParamStopCFM2::
ParamStopCFM2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamStopCFM2::
ParamStopCFM2 (const ParamStopCFM2& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamStopCFM2::
ParamStopCFM2 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamStopCFM2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamStopCFM2* ParamStopCFM2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamStopCFM2 (*this, f, c);
}

ParamStopCFM2::
~ParamStopCFM2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamStopCFM2 >
_xsd_ParamStopCFM2_type_factory_init (
  "ParamStopCFM2",
  "");

// ParamStopCFM3
//

ParamStopCFM3::
ParamStopCFM3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamStopCFM3::
ParamStopCFM3 (const ParamStopCFM3& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamStopCFM3::
ParamStopCFM3 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamStopCFM3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamStopCFM3* ParamStopCFM3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamStopCFM3 (*this, f, c);
}

ParamStopCFM3::
~ParamStopCFM3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamStopCFM3 >
_xsd_ParamStopCFM3_type_factory_init (
  "ParamStopCFM3",
  "");

// paramStopERP
//

paramStopERP::
paramStopERP (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramStopERP::
paramStopERP (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramStopERP::
paramStopERP (const paramStopERP& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramStopERP::
paramStopERP (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramStopERP::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramStopERP* paramStopERP::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramStopERP (*this, f, c);
}

paramStopERP::
~paramStopERP ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramStopERP >
_xsd_paramStopERP_type_factory_init (
  "paramStopERP",
  "");

// ParamStopERP
//

ParamStopERP::
ParamStopERP ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamStopERP::
ParamStopERP (const ParamStopERP& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamStopERP::
ParamStopERP (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamStopERP::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamStopERP* ParamStopERP::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamStopERP (*this, f, c);
}

ParamStopERP::
~ParamStopERP ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamStopERP >
_xsd_ParamStopERP_type_factory_init (
  "ParamStopERP",
  "");

// ParamStopERP2
//

ParamStopERP2::
ParamStopERP2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamStopERP2::
ParamStopERP2 (const ParamStopERP2& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamStopERP2::
ParamStopERP2 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamStopERP2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamStopERP2* ParamStopERP2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamStopERP2 (*this, f, c);
}

ParamStopERP2::
~ParamStopERP2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamStopERP2 >
_xsd_ParamStopERP2_type_factory_init (
  "ParamStopERP2",
  "");

// ParamStopERP3
//

ParamStopERP3::
ParamStopERP3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamStopERP3::
ParamStopERP3 (const ParamStopERP3& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamStopERP3::
ParamStopERP3 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamStopERP3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamStopERP3* ParamStopERP3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamStopERP3 (*this, f, c);
}

ParamStopERP3::
~ParamStopERP3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamStopERP3 >
_xsd_ParamStopERP3_type_factory_init (
  "ParamStopERP3",
  "");

// paramSuspensionCFM
//

paramSuspensionCFM::
paramSuspensionCFM (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramSuspensionCFM::
paramSuspensionCFM (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramSuspensionCFM::
paramSuspensionCFM (const paramSuspensionCFM& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramSuspensionCFM::
paramSuspensionCFM (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramSuspensionCFM::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramSuspensionCFM* paramSuspensionCFM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramSuspensionCFM (*this, f, c);
}

paramSuspensionCFM::
~paramSuspensionCFM ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramSuspensionCFM >
_xsd_paramSuspensionCFM_type_factory_init (
  "paramSuspensionCFM",
  "");

// ParamSuspensionCFM
//

ParamSuspensionCFM::
ParamSuspensionCFM ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamSuspensionCFM::
ParamSuspensionCFM (const ParamSuspensionCFM& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamSuspensionCFM::
ParamSuspensionCFM (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamSuspensionCFM::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamSuspensionCFM* ParamSuspensionCFM::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamSuspensionCFM (*this, f, c);
}

ParamSuspensionCFM::
~ParamSuspensionCFM ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamSuspensionCFM >
_xsd_ParamSuspensionCFM_type_factory_init (
  "ParamSuspensionCFM",
  "");

// ParamSuspensionCFM2
//

ParamSuspensionCFM2::
ParamSuspensionCFM2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamSuspensionCFM2::
ParamSuspensionCFM2 (const ParamSuspensionCFM2& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamSuspensionCFM2::
ParamSuspensionCFM2 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamSuspensionCFM2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamSuspensionCFM2* ParamSuspensionCFM2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamSuspensionCFM2 (*this, f, c);
}

ParamSuspensionCFM2::
~ParamSuspensionCFM2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamSuspensionCFM2 >
_xsd_ParamSuspensionCFM2_type_factory_init (
  "ParamSuspensionCFM2",
  "");

// ParamSuspensionCFM3
//

ParamSuspensionCFM3::
ParamSuspensionCFM3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamSuspensionCFM3::
ParamSuspensionCFM3 (const ParamSuspensionCFM3& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamSuspensionCFM3::
ParamSuspensionCFM3 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamSuspensionCFM3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamSuspensionCFM3* ParamSuspensionCFM3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamSuspensionCFM3 (*this, f, c);
}

ParamSuspensionCFM3::
~ParamSuspensionCFM3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamSuspensionCFM3 >
_xsd_ParamSuspensionCFM3_type_factory_init (
  "ParamSuspensionCFM3",
  "");

// paramSuspensionERP
//

paramSuspensionERP::
paramSuspensionERP (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramSuspensionERP::
paramSuspensionERP (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramSuspensionERP::
paramSuspensionERP (const paramSuspensionERP& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramSuspensionERP::
paramSuspensionERP (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramSuspensionERP::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramSuspensionERP* paramSuspensionERP::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramSuspensionERP (*this, f, c);
}

paramSuspensionERP::
~paramSuspensionERP ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramSuspensionERP >
_xsd_paramSuspensionERP_type_factory_init (
  "paramSuspensionERP",
  "");

// ParamSuspensionERP
//

ParamSuspensionERP::
ParamSuspensionERP ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamSuspensionERP::
ParamSuspensionERP (const ParamSuspensionERP& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamSuspensionERP::
ParamSuspensionERP (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamSuspensionERP::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamSuspensionERP* ParamSuspensionERP::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamSuspensionERP (*this, f, c);
}

ParamSuspensionERP::
~ParamSuspensionERP ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamSuspensionERP >
_xsd_ParamSuspensionERP_type_factory_init (
  "ParamSuspensionERP",
  "");

// ParamSuspensionERP2
//

ParamSuspensionERP2::
ParamSuspensionERP2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamSuspensionERP2::
ParamSuspensionERP2 (const ParamSuspensionERP2& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamSuspensionERP2::
ParamSuspensionERP2 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamSuspensionERP2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamSuspensionERP2* ParamSuspensionERP2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamSuspensionERP2 (*this, f, c);
}

ParamSuspensionERP2::
~ParamSuspensionERP2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamSuspensionERP2 >
_xsd_ParamSuspensionERP2_type_factory_init (
  "ParamSuspensionERP2",
  "");

// ParamSuspensionERP3
//

ParamSuspensionERP3::
ParamSuspensionERP3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamSuspensionERP3::
ParamSuspensionERP3 (const ParamSuspensionERP3& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamSuspensionERP3::
ParamSuspensionERP3 (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamSuspensionERP3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamSuspensionERP3* ParamSuspensionERP3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamSuspensionERP3 (*this, f, c);
}

ParamSuspensionERP3::
~ParamSuspensionERP3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamSuspensionERP3 >
_xsd_ParamSuspensionERP3_type_factory_init (
  "ParamSuspensionERP3",
  "");

// paramVel
//

paramVel::
paramVel (const Value_type& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramVel::
paramVel (::std::auto_ptr< Value_type >& Value)
: ::Param (),
  Value_ (Value, ::xml_schema::flags (), this)
{
}

paramVel::
paramVel (const paramVel& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

paramVel::
paramVel (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void paramVel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Value
    //
    {
      ::xsd::cxx::tree::type_factory_map< char >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          "Value",
          "",
          &::xsd::cxx::tree::factory_impl< Value_type >,
          false, false, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Value_.present ())
        {
          ::std::auto_ptr< Value_type > r (
            dynamic_cast< Value_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Value_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Value_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Value",
      "");
  }
}

paramVel* paramVel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramVel (*this, f, c);
}

paramVel::
~paramVel ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, paramVel >
_xsd_paramVel_type_factory_init (
  "paramVel",
  "");

// ParamVel
//

ParamVel::
ParamVel ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamVel::
ParamVel (const ParamVel& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamVel::
ParamVel (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamVel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamVel* ParamVel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamVel (*this, f, c);
}

ParamVel::
~ParamVel ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamVel >
_xsd_ParamVel_type_factory_init (
  "ParamVel",
  "");

// ParamVel2
//

ParamVel2::
ParamVel2 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamVel2::
ParamVel2 (const ParamVel2& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamVel2::
ParamVel2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamVel2::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamVel2* ParamVel2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamVel2 (*this, f, c);
}

ParamVel2::
~ParamVel2 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamVel2 >
_xsd_ParamVel2_type_factory_init (
  "ParamVel2",
  "");

// ParamVel3
//

ParamVel3::
ParamVel3 ()
: ::Param (),
  Value_ (::xml_schema::flags (), this)
{
}

ParamVel3::
ParamVel3 (const ParamVel3& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (x, f, c),
  Value_ (x.Value_, f, this)
{
}

ParamVel3::
ParamVel3 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::Param (e, f | ::xml_schema::flags::base, c),
  Value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void ParamVel3::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ParamVel3* ParamVel3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParamVel3 (*this, f, c);
}

ParamVel3::
~ParamVel3 ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParamVel3 >
_xsd_ParamVel3_type_factory_init (
  "ParamVel3",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Sim > r (
      ::Sim_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Sim",
      "",
      &::xsd::cxx::tree::factory_impl< ::Sim >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Sim > r (
      dynamic_cast< ::Sim* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Sim",
    "");
}

::std::auto_ptr< ::Sim >
Sim_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Sim",
      "",
      &::xsd::cxx::tree::factory_impl< ::Sim >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Sim > r (
      dynamic_cast< ::Sim* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Sim",
    "");
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::World > r (
      ::World_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "World",
      "",
      &::xsd::cxx::tree::factory_impl< ::World >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::World > r (
      dynamic_cast< ::World* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "World",
    "");
}

::std::auto_ptr< ::World >
World_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "World",
      "",
      &::xsd::cxx::tree::factory_impl< ::World >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::World > r (
      dynamic_cast< ::World* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "World",
    "");
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::SimpleSpace > r (
    ::SimpleSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimpleSpace > r (
    ::SimpleSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimpleSpace > r (
    ::SimpleSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SimpleSpace_ (isrc, f, p);
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SimpleSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SimpleSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SimpleSpace_ (isrc, f, p);
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SimpleSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SimpleSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::SimpleSpace > r (
    ::SimpleSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimpleSpace > r (
    ::SimpleSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::SimpleSpace > r (
    ::SimpleSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::SimpleSpace > r (
      ::SimpleSpace_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "SimpleSpace",
      "",
      &::xsd::cxx::tree::factory_impl< ::SimpleSpace >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::SimpleSpace > r (
      dynamic_cast< ::SimpleSpace* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SimpleSpace",
    "");
}

::std::auto_ptr< ::SimpleSpace >
SimpleSpace_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "SimpleSpace",
      "",
      &::xsd::cxx::tree::factory_impl< ::SimpleSpace >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::SimpleSpace > r (
      dynamic_cast< ::SimpleSpace* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SimpleSpace",
    "");
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Body > r (
      ::Body_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Body",
      "",
      &::xsd::cxx::tree::factory_impl< ::Body >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Body > r (
      dynamic_cast< ::Body* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Body",
    "");
}

::std::auto_ptr< ::Body >
Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Body",
      "",
      &::xsd::cxx::tree::factory_impl< ::Body >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Body > r (
      dynamic_cast< ::Body* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Body",
    "");
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::HingeJoint > r (
    ::HingeJoint_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint > r (
    ::HingeJoint_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint > r (
    ::HingeJoint_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::HingeJoint_ (isrc, f, p);
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::HingeJoint_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::HingeJoint_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::HingeJoint_ (isrc, f, p);
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::HingeJoint_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::HingeJoint_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::HingeJoint > r (
    ::HingeJoint_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint > r (
    ::HingeJoint_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint > r (
    ::HingeJoint_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::HingeJoint > r (
      ::HingeJoint_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "HingeJoint",
      "",
      &::xsd::cxx::tree::factory_impl< ::HingeJoint >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::HingeJoint > r (
      dynamic_cast< ::HingeJoint* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "HingeJoint",
    "");
}

::std::auto_ptr< ::HingeJoint >
HingeJoint_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "HingeJoint",
      "",
      &::xsd::cxx::tree::factory_impl< ::HingeJoint >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::HingeJoint > r (
      dynamic_cast< ::HingeJoint* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "HingeJoint",
    "");
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::HingeJoint2 > r (
    ::HingeJoint2_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint2 > r (
    ::HingeJoint2_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint2 > r (
    ::HingeJoint2_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::HingeJoint2_ (isrc, f, p);
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::HingeJoint2_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::HingeJoint2_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::HingeJoint2_ (isrc, f, p);
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::HingeJoint2_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::HingeJoint2_ (isrc, h, f, p);
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::HingeJoint2 > r (
    ::HingeJoint2_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint2 > r (
    ::HingeJoint2_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::HingeJoint2 > r (
    ::HingeJoint2_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::HingeJoint2 > r (
      ::HingeJoint2_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "HingeJoint2",
      "",
      &::xsd::cxx::tree::factory_impl< ::HingeJoint2 >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::HingeJoint2 > r (
      dynamic_cast< ::HingeJoint2* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "HingeJoint2",
    "");
}

::std::auto_ptr< ::HingeJoint2 >
HingeJoint2_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "HingeJoint2",
      "",
      &::xsd::cxx::tree::factory_impl< ::HingeJoint2 >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::HingeJoint2 > r (
      dynamic_cast< ::HingeJoint2* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "HingeJoint2",
    "");
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomCylinder > r (
    ::GeomCylinder_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCylinder > r (
    ::GeomCylinder_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCylinder > r (
    ::GeomCylinder_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomCylinder_ (isrc, f, p);
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomCylinder_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomCylinder_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomCylinder_ (isrc, f, p);
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomCylinder_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomCylinder_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomCylinder > r (
    ::GeomCylinder_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCylinder > r (
    ::GeomCylinder_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCylinder > r (
    ::GeomCylinder_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::GeomCylinder > r (
      ::GeomCylinder_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomCylinder",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomCylinder >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::GeomCylinder > r (
      dynamic_cast< ::GeomCylinder* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomCylinder",
    "");
}

::std::auto_ptr< ::GeomCylinder >
GeomCylinder_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomCylinder",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomCylinder >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::GeomCylinder > r (
      dynamic_cast< ::GeomCylinder* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomCylinder",
    "");
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomCapsule > r (
    ::GeomCapsule_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCapsule > r (
    ::GeomCapsule_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCapsule > r (
    ::GeomCapsule_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomCapsule_ (isrc, f, p);
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomCapsule_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomCapsule_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomCapsule_ (isrc, f, p);
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomCapsule_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomCapsule_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomCapsule > r (
    ::GeomCapsule_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCapsule > r (
    ::GeomCapsule_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomCapsule > r (
    ::GeomCapsule_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::GeomCapsule > r (
      ::GeomCapsule_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomCapsule",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomCapsule >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::GeomCapsule > r (
      dynamic_cast< ::GeomCapsule* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomCapsule",
    "");
}

::std::auto_ptr< ::GeomCapsule >
GeomCapsule_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomCapsule",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomCapsule >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::GeomCapsule > r (
      dynamic_cast< ::GeomCapsule* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomCapsule",
    "");
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomSphere > r (
    ::GeomSphere_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomSphere > r (
    ::GeomSphere_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomSphere > r (
    ::GeomSphere_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomSphere_ (isrc, f, p);
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomSphere_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomSphere_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomSphere_ (isrc, f, p);
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomSphere_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomSphere_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomSphere > r (
    ::GeomSphere_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomSphere > r (
    ::GeomSphere_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomSphere > r (
    ::GeomSphere_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::GeomSphere > r (
      ::GeomSphere_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomSphere",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomSphere >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::GeomSphere > r (
      dynamic_cast< ::GeomSphere* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomSphere",
    "");
}

::std::auto_ptr< ::GeomSphere >
GeomSphere_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomSphere",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomSphere >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::GeomSphere > r (
      dynamic_cast< ::GeomSphere* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomSphere",
    "");
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomPlane > r (
    ::GeomPlane_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomPlane > r (
    ::GeomPlane_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomPlane > r (
    ::GeomPlane_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomPlane_ (isrc, f, p);
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomPlane_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::GeomPlane_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomPlane_ (isrc, f, p);
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomPlane_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::GeomPlane_ (isrc, h, f, p);
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::GeomPlane > r (
    ::GeomPlane_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomPlane > r (
    ::GeomPlane_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::GeomPlane > r (
    ::GeomPlane_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::GeomPlane > r (
      ::GeomPlane_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomPlane",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomPlane >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::GeomPlane > r (
      dynamic_cast< ::GeomPlane* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomPlane",
    "");
}

::std::auto_ptr< ::GeomPlane >
GeomPlane_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "GeomPlane",
      "",
      &::xsd::cxx::tree::factory_impl< ::GeomPlane >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::GeomPlane > r (
      dynamic_cast< ::GeomPlane* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "GeomPlane",
    "");
}

::std::auto_ptr< ::Rotation >
Rotation_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Rotation > r (
    ::Rotation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Rotation >
Rotation_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Rotation > r (
    ::Rotation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Rotation >
Rotation_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Rotation > r (
    ::Rotation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Rotation >
Rotation_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Rotation_ (isrc, f, p);
}

::std::auto_ptr< ::Rotation >
Rotation_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Rotation_ (isrc, h, f, p);
}

::std::auto_ptr< ::Rotation >
Rotation_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Rotation_ (isrc, h, f, p);
}

::std::auto_ptr< ::Rotation >
Rotation_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Rotation_ (isrc, f, p);
}

::std::auto_ptr< ::Rotation >
Rotation_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Rotation_ (isrc, h, f, p);
}

::std::auto_ptr< ::Rotation >
Rotation_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Rotation_ (isrc, h, f, p);
}

::std::auto_ptr< ::Rotation >
Rotation_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Rotation > r (
    ::Rotation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Rotation >
Rotation_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Rotation > r (
    ::Rotation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Rotation >
Rotation_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Rotation > r (
    ::Rotation_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Rotation >
Rotation_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Rotation > r (
      ::Rotation_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Rotation",
      "",
      &::xsd::cxx::tree::factory_impl< ::Rotation >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Rotation > r (
      dynamic_cast< ::Rotation* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Rotation",
    "");
}

::std::auto_ptr< ::Rotation >
Rotation_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Rotation",
      "",
      &::xsd::cxx::tree::factory_impl< ::Rotation >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Rotation > r (
      dynamic_cast< ::Rotation* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Rotation",
    "");
}

::std::auto_ptr< ::Vector >
Vector_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Vector > r (
    ::Vector_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Vector >
Vector_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Vector > r (
    ::Vector_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Vector >
Vector_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Vector > r (
    ::Vector_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Vector >
Vector_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Vector_ (isrc, f, p);
}

::std::auto_ptr< ::Vector >
Vector_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Vector_ (isrc, h, f, p);
}

::std::auto_ptr< ::Vector >
Vector_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Vector_ (isrc, h, f, p);
}

::std::auto_ptr< ::Vector >
Vector_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Vector_ (isrc, f, p);
}

::std::auto_ptr< ::Vector >
Vector_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Vector_ (isrc, h, f, p);
}

::std::auto_ptr< ::Vector >
Vector_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Vector_ (isrc, h, f, p);
}

::std::auto_ptr< ::Vector >
Vector_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Vector > r (
    ::Vector_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Vector >
Vector_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Vector > r (
    ::Vector_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Vector >
Vector_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Vector > r (
    ::Vector_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Vector >
Vector_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Vector > r (
      ::Vector_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Vector",
      "",
      &::xsd::cxx::tree::factory_impl< ::Vector >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Vector > r (
      dynamic_cast< ::Vector* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Vector",
    "");
}

::std::auto_ptr< ::Vector >
Vector_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Vector",
      "",
      &::xsd::cxx::tree::factory_impl< ::Vector >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Vector > r (
      dynamic_cast< ::Vector* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Vector",
    "");
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Quaternion > r (
    ::Quaternion_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Quaternion > r (
    ::Quaternion_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Quaternion > r (
    ::Quaternion_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Quaternion_ (isrc, f, p);
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Quaternion_ (isrc, h, f, p);
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Quaternion_ (isrc, h, f, p);
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Quaternion_ (isrc, f, p);
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Quaternion_ (isrc, h, f, p);
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Quaternion_ (isrc, h, f, p);
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Quaternion > r (
    ::Quaternion_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Quaternion > r (
    ::Quaternion_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Quaternion > r (
    ::Quaternion_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Quaternion > r (
      ::Quaternion_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Quaternion",
      "",
      &::xsd::cxx::tree::factory_impl< ::Quaternion >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::Quaternion > r (
      dynamic_cast< ::Quaternion* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Quaternion",
    "");
}

::std::auto_ptr< ::Quaternion >
Quaternion_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::xsd::cxx::tree::type_factory_map< char >& tfm (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    tfm.create (
      "Quaternion",
      "",
      &::xsd::cxx::tree::factory_impl< ::Quaternion >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::Quaternion > r (
      dynamic_cast< ::Quaternion* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Quaternion",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const RSObject& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Name ())
    {
      const RSObject::Name_type& x (*i.Name ());
      if (typeid (RSObject::Name_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Name",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RSObject >
_xsd_RSObject_type_serializer_init (
  "RSObject",
  "");


void
operator<< (::xercesc::DOMElement& e, const Sim& i)
{
  e << static_cast< const ::RSObject& > (i);

  // World
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::World_const_iterator
         b (i.World ().begin ()), n (i.World ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::World_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "World",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "World",
          "",
          false, false, e, *b);
    }
  }

  // Space
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::Space_const_iterator
         b (i.Space ().begin ()), n (i.Space ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::Space_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Space",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Space",
          "",
          false, false, e, *b);
    }
  }

  // Body
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::Body_const_iterator
         b (i.Body ().begin ()), n (i.Body ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::Body_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Body",
          "",
          false, false, e, *b);
    }
  }

  // Geom
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Sim::Geom_const_iterator
         b (i.Geom ().begin ()), n (i.Geom ().end ());
         b != n; ++b)
    {
      if (typeid (Sim::Geom_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Geom",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Geom",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Sim >
_xsd_Sim_type_serializer_init (
  "Sim",
  "");


void
Sim_ (::std::ostream& o,
      const ::Sim& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Sim_ (::std::ostream& o,
      const ::Sim& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::std::ostream& o,
      const ::Sim& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::xercesc::XMLFormatTarget& t,
      const ::Sim& s,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Sim_ (::xercesc::XMLFormatTarget& t,
      const ::Sim& s,
      ::xml_schema::error_handler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::xercesc::XMLFormatTarget& t,
      const ::Sim& s,
      ::xercesc::DOMErrorHandler& h,
      const ::xml_schema::namespace_infomap& m,
      const ::std::string& e,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Sim_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Sim_ (::xercesc::DOMDocument& d,
      const ::Sim& s,
      ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Sim) == typeid (s))
  {
    if (n.name () == "Sim" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sim",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Sim",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Sim_ (const ::Sim& s,
      const ::xml_schema::namespace_infomap& m,
      ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Sim) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Sim",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Sim",
        "",
        m, s, f));
    d = r;
  }

  ::Sim_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const World& i)
{
  e << static_cast< const ::RSObject& > (i);

  // AutoDisableAngularThreshold
  //
  if (i.AutoDisableAngularThreshold ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableAngularThreshold",
        e));

    s << *i.AutoDisableAngularThreshold ();
  }

  // AutoDisableFlag
  //
  if (i.AutoDisableFlag ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableFlag",
        e));

    s << *i.AutoDisableFlag ();
  }

  // AutoDisableSteps
  //
  if (i.AutoDisableSteps ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableSteps",
        e));

    s << *i.AutoDisableSteps ();
  }

  // AutoDisableTime
  //
  if (i.AutoDisableTime ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AutoDisableTime",
        e));

    s << *i.AutoDisableTime ();
  }

  // CFM
  //
  if (i.CFM ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CFM",
        e));

    s << *i.CFM ();
  }

  // ContactMaxCorrectingVel
  //
  if (i.ContactMaxCorrectingVel ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContactMaxCorrectingVel",
        e));

    s << *i.ContactMaxCorrectingVel ();
  }

  // ContactSurfaceLayer
  //
  if (i.ContactSurfaceLayer ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ContactSurfaceLayer",
        e));

    s << *i.ContactSurfaceLayer ();
  }

  // ERP
  //
  if (i.ERP ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ERP",
        e));

    s << *i.ERP ();
  }

  // Gravity
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Gravity ())
    {
      const World::Gravity_type& x (*i.Gravity ());
      if (typeid (World::Gravity_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Gravity",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Gravity",
          "",
          false, false, e, x);
    }
  }

  // QuickStepNumIterations
  //
  if (i.QuickStepNumIterations ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "QuickStepNumIterations",
        e));

    s << *i.QuickStepNumIterations ();
  }

  // Body
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (World::Body_const_iterator
         b (i.Body ().begin ()), n (i.Body ().end ());
         b != n; ++b)
    {
      if (typeid (World::Body_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Body",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, World >
_xsd_World_type_serializer_init (
  "World",
  "");


void
World_ (::std::ostream& o,
        const ::World& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
World_ (::std::ostream& o,
        const ::World& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::std::ostream& o,
        const ::World& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::xercesc::XMLFormatTarget& t,
        const ::World& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
World_ (::xercesc::XMLFormatTarget& t,
        const ::World& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::xercesc::XMLFormatTarget& t,
        const ::World& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::World_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
World_ (::xercesc::DOMDocument& d,
        const ::World& s,
        ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::World) == typeid (s))
  {
    if (n.name () == "World" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "World",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "World",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
World_ (const ::World& s,
        const ::xml_schema::namespace_infomap& m,
        ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::World) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "World",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "World",
        "",
        m, s, f));
    d = r;
  }

  ::World_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const GeomObject& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Enable
  //
  if (i.Enable ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Enable",
        e));

    s << *i.Enable ();
  }

  // CategoryBits
  //
  if (i.CategoryBits ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CategoryBits",
        e));

    s << *i.CategoryBits ();
  }

  // CollideBits
  //
  if (i.CollideBits ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CollideBits",
        e));

    s << *i.CollideBits ();
  }

  // Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Position ())
    {
      const GeomObject::Position_type& x (*i.Position ());
      if (typeid (GeomObject::Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Position",
          "",
          false, false, e, x);
    }
  }

  // Quaternion
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Quaternion ())
    {
      const GeomObject::Quaternion_type& x (*i.Quaternion ());
      if (typeid (GeomObject::Quaternion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Quaternion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Quaternion",
          "",
          false, false, e, x);
    }
  }

  // Rotation
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Rotation ())
    {
      const GeomObject::Rotation_type& x (*i.Rotation ());
      if (typeid (GeomObject::Rotation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Rotation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Rotation",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomObject >
_xsd_GeomObject_type_serializer_init (
  "GeomObject",
  "");


void
operator<< (::xercesc::DOMElement& e, const SpaceBase& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Geom
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SpaceBase::Geom_const_iterator
         b (i.Geom ().begin ()), n (i.Geom ().end ());
         b != n; ++b)
    {
      if (typeid (SpaceBase::Geom_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Geom",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Geom",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SpaceBase >
_xsd_SpaceBase_type_serializer_init (
  "SpaceBase",
  "");


void
operator<< (::xercesc::DOMElement& e, const SimpleSpace& i)
{
  e << static_cast< const ::SpaceBase& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SimpleSpace >
_xsd_SimpleSpace_type_serializer_init (
  "SimpleSpace",
  "");


void
SimpleSpace_ (::std::ostream& o,
              const ::SimpleSpace& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::SimpleSpace_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
SimpleSpace_ (::std::ostream& o,
              const ::SimpleSpace& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::SimpleSpace_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
SimpleSpace_ (::std::ostream& o,
              const ::SimpleSpace& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::SimpleSpace_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
SimpleSpace_ (::xercesc::XMLFormatTarget& t,
              const ::SimpleSpace& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::SimpleSpace_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
SimpleSpace_ (::xercesc::XMLFormatTarget& t,
              const ::SimpleSpace& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::SimpleSpace_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
SimpleSpace_ (::xercesc::XMLFormatTarget& t,
              const ::SimpleSpace& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::SimpleSpace_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
SimpleSpace_ (::xercesc::DOMDocument& d,
              const ::SimpleSpace& s,
              ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::SimpleSpace) == typeid (s))
  {
    if (n.name () == "SimpleSpace" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SimpleSpace",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "SimpleSpace",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
SimpleSpace_ (const ::SimpleSpace& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::SimpleSpace) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "SimpleSpace",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "SimpleSpace",
        "",
        m, s, f));
    d = r;
  }

  ::SimpleSpace_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Body& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Space
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Space ())
    {
      const Body::Space_type& x (*i.Space ());
      if (typeid (Body::Space_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Space",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Space",
          "",
          false, false, e, x);
    }
  }

  // World
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.World ())
    {
      const Body::World_type& x (*i.World ());
      if (typeid (Body::World_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "World",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "World",
          "",
          false, false, e, x);
    }
  }

  // Enabled
  //
  if (i.Enabled ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Enabled",
        e));

    s << *i.Enabled ();
  }

  // AngularVel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.AngularVel ())
    {
      const Body::AngularVel_type& x (*i.AngularVel ());
      if (typeid (Body::AngularVel_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AngularVel",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AngularVel",
          "",
          false, false, e, x);
    }
  }

  // FiniteRotationAxis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.FiniteRotationAxis ())
    {
      const Body::FiniteRotationAxis_type& x (*i.FiniteRotationAxis ());
      if (typeid (Body::FiniteRotationAxis_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FiniteRotationAxis",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "FiniteRotationAxis",
          "",
          false, false, e, x);
    }
  }

  // FiniteRotationMode
  //
  if (i.FiniteRotationMode ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FiniteRotationMode",
        e));

    s << *i.FiniteRotationMode ();
  }

  // Force
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Force ())
    {
      const Body::Force_type& x (*i.Force ());
      if (typeid (Body::Force_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Force",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Force",
          "",
          false, false, e, x);
    }
  }

  // GravityMode
  //
  if (i.GravityMode ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "GravityMode",
        e));

    s << *i.GravityMode ();
  }

  // LinearVel
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.LinearVel ())
    {
      const Body::LinearVel_type& x (*i.LinearVel ());
      if (typeid (Body::LinearVel_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearVel",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "LinearVel",
          "",
          false, false, e, x);
    }
  }

  // Mass
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Mass ())
    {
      const Body::Mass_type& x (*i.Mass ());
      if (typeid (Body::Mass_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Mass",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Mass",
          "",
          false, false, e, x);
    }
  }

  // Torque
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Torque ())
    {
      const Body::Torque_type& x (*i.Torque ());
      if (typeid (Body::Torque_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Torque",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Torque",
          "",
          false, false, e, x);
    }
  }

  // Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Position ())
    {
      const Body::Position_type& x (*i.Position ());
      if (typeid (Body::Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Position",
          "",
          false, false, e, x);
    }
  }

  // Quaternion
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Quaternion ())
    {
      const Body::Quaternion_type& x (*i.Quaternion ());
      if (typeid (Body::Quaternion_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Quaternion",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Quaternion",
          "",
          false, false, e, x);
    }
  }

  // Rotation
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Rotation ())
    {
      const Body::Rotation_type& x (*i.Rotation ());
      if (typeid (Body::Rotation_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Rotation",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Rotation",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Body >
_xsd_Body_type_serializer_init (
  "Body",
  "");


void
Body_ (::std::ostream& o,
       const ::Body& s,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Body_ (::std::ostream& o,
       const ::Body& s,
       ::xml_schema::error_handler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::std::ostream& o,
       const ::Body& s,
       ::xercesc::DOMErrorHandler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::xercesc::XMLFormatTarget& t,
       const ::Body& s,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Body_ (::xercesc::XMLFormatTarget& t,
       const ::Body& s,
       ::xml_schema::error_handler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::xercesc::XMLFormatTarget& t,
       const ::Body& s,
       ::xercesc::DOMErrorHandler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Body_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Body_ (::xercesc::DOMDocument& d,
       const ::Body& s,
       ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Body) == typeid (s))
  {
    if (n.name () == "Body" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Body",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Body",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Body_ (const ::Body& s,
       const ::xml_schema::namespace_infomap& m,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Body) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Body",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Body",
        "",
        m, s, f));
    d = r;
  }

  ::Body_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Mass& i)
{
  e << static_cast< const ::RSObject& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Mass >
_xsd_Mass_type_serializer_init (
  "Mass",
  "");


void
operator<< (::xercesc::DOMElement& e, const BoxTotalMass& i)
{
  e << static_cast< const ::Mass& > (i);

  // M
  //
  if (i.M ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "M",
        e));

    a << *i.M ();
  }

  // LX
  //
  if (i.LX ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "LX",
        e));

    a << *i.LX ();
  }

  // LY
  //
  if (i.LY ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "LY",
        e));

    a << *i.LY ();
  }

  // LZ
  //
  if (i.LZ ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "LZ",
        e));

    a << *i.LZ ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BoxTotalMass >
_xsd_BoxTotalMass_type_serializer_init (
  "BoxTotalMass",
  "");


void
operator<< (::xercesc::DOMElement& e, const Joint& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Feedback
  //
  if (i.Feedback ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Feedback",
        e));

    s << *i.Feedback ();
  }

  // Body1
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Body1 ())
    {
      const Joint::Body1_type& x (*i.Body1 ());
      if (typeid (Joint::Body1_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body1",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Body1",
          "",
          false, false, e, x);
    }
  }

  // Body2
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Body2 ())
    {
      const Joint::Body2_type& x (*i.Body2 ());
      if (typeid (Joint::Body2_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body2",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Body2",
          "",
          false, false, e, x);
    }
  }

  // Param
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (Joint::Param_const_iterator
         b (i.Param ().begin ()), n (i.Param ().end ());
         b != n; ++b)
    {
      if (typeid (Joint::Param_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Param",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "Param",
          "",
          false, false, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Joint >
_xsd_Joint_type_serializer_init (
  "Joint",
  "");


void
operator<< (::xercesc::DOMElement& e, const HingeJoint& i)
{
  e << static_cast< const ::Joint& > (i);

  // Anchor
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Anchor ())
    {
      const HingeJoint::Anchor_type& x (*i.Anchor ());
      if (typeid (HingeJoint::Anchor_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Anchor",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Anchor",
          "",
          false, false, e, x);
    }
  }

  // Axis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Axis ())
    {
      const HingeJoint::Axis_type& x (*i.Axis ());
      if (typeid (HingeJoint::Axis_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Axis",
          "",
          false, false, e, x);
    }
  }

  // Torque
  //
  if (i.Torque ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Torque",
        e));

    s << *i.Torque ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HingeJoint >
_xsd_HingeJoint_type_serializer_init (
  "HingeJoint",
  "");


void
HingeJoint_ (::std::ostream& o,
             const ::HingeJoint& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
HingeJoint_ (::std::ostream& o,
             const ::HingeJoint& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint_ (::std::ostream& o,
             const ::HingeJoint& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint_ (::xercesc::XMLFormatTarget& t,
             const ::HingeJoint& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
HingeJoint_ (::xercesc::XMLFormatTarget& t,
             const ::HingeJoint& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint_ (::xercesc::XMLFormatTarget& t,
             const ::HingeJoint& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint_ (::xercesc::DOMDocument& d,
             const ::HingeJoint& s,
             ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::HingeJoint) == typeid (s))
  {
    if (n.name () == "HingeJoint" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "HingeJoint",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "HingeJoint",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
HingeJoint_ (const ::HingeJoint& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::HingeJoint) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "HingeJoint",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "HingeJoint",
        "",
        m, s, f));
    d = r;
  }

  ::HingeJoint_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const HingeJoint2& i)
{
  e << static_cast< const ::Joint& > (i);

  // Anchor
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Anchor ())
    {
      const HingeJoint2::Anchor_type& x (*i.Anchor ());
      if (typeid (HingeJoint2::Anchor_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Anchor",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Anchor",
          "",
          false, false, e, x);
    }
  }

  // Axis1
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Axis1 ())
    {
      const HingeJoint2::Axis1_type& x (*i.Axis1 ());
      if (typeid (HingeJoint2::Axis1_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis1",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Axis1",
          "",
          false, false, e, x);
    }
  }

  // Axis2
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Axis2 ())
    {
      const HingeJoint2::Axis2_type& x (*i.Axis2 ());
      if (typeid (HingeJoint2::Axis2_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis2",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Axis2",
          "",
          false, false, e, x);
    }
  }

  // Torque
  //
  if (i.Torque ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Torque",
        e));

    s << *i.Torque ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, HingeJoint2 >
_xsd_HingeJoint2_type_serializer_init (
  "HingeJoint2",
  "");


void
HingeJoint2_ (::std::ostream& o,
              const ::HingeJoint2& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint2_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
HingeJoint2_ (::std::ostream& o,
              const ::HingeJoint2& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint2_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint2_ (::std::ostream& o,
              const ::HingeJoint2& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint2_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint2_ (::xercesc::XMLFormatTarget& t,
              const ::HingeJoint2& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint2_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
HingeJoint2_ (::xercesc::XMLFormatTarget& t,
              const ::HingeJoint2& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint2_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint2_ (::xercesc::XMLFormatTarget& t,
              const ::HingeJoint2& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::HingeJoint2_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
HingeJoint2_ (::xercesc::DOMDocument& d,
              const ::HingeJoint2& s,
              ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::HingeJoint2) == typeid (s))
  {
    if (n.name () == "HingeJoint2" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "HingeJoint2",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "HingeJoint2",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
HingeJoint2_ (const ::HingeJoint2& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::HingeJoint2) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "HingeJoint2",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "HingeJoint2",
        "",
        m, s, f));
    d = r;
  }

  ::HingeJoint2_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const GeomBox& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Lengths
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Lengths ())
    {
      const GeomBox::Lengths_type& x (*i.Lengths ());
      if (typeid (GeomBox::Lengths_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Lengths",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Lengths",
          "",
          false, false, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomBox >
_xsd_GeomBox_type_serializer_init (
  "GeomBox",
  "");


void
operator<< (::xercesc::DOMElement& e, const GeomCylinder& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Length
  //
  if (i.Length ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Length",
        e));

    s << *i.Length ();
  }

  // Radius
  //
  if (i.Radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Radius",
        e));

    s << *i.Radius ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomCylinder >
_xsd_GeomCylinder_type_serializer_init (
  "GeomCylinder",
  "");


void
GeomCylinder_ (::std::ostream& o,
               const ::GeomCylinder& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCylinder_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomCylinder_ (::std::ostream& o,
               const ::GeomCylinder& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCylinder_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCylinder_ (::std::ostream& o,
               const ::GeomCylinder& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCylinder_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCylinder_ (::xercesc::XMLFormatTarget& t,
               const ::GeomCylinder& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCylinder_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomCylinder_ (::xercesc::XMLFormatTarget& t,
               const ::GeomCylinder& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCylinder_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCylinder_ (::xercesc::XMLFormatTarget& t,
               const ::GeomCylinder& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCylinder_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCylinder_ (::xercesc::DOMDocument& d,
               const ::GeomCylinder& s,
               ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::GeomCylinder) == typeid (s))
  {
    if (n.name () == "GeomCylinder" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GeomCylinder",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "GeomCylinder",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
GeomCylinder_ (const ::GeomCylinder& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::GeomCylinder) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GeomCylinder",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "GeomCylinder",
        "",
        m, s, f));
    d = r;
  }

  ::GeomCylinder_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const GeomCapsule& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Length
  //
  if (i.Length ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Length",
        e));

    s << *i.Length ();
  }

  // Radius
  //
  if (i.Radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Radius",
        e));

    s << *i.Radius ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomCapsule >
_xsd_GeomCapsule_type_serializer_init (
  "GeomCapsule",
  "");


void
GeomCapsule_ (::std::ostream& o,
              const ::GeomCapsule& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCapsule_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomCapsule_ (::std::ostream& o,
              const ::GeomCapsule& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCapsule_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCapsule_ (::std::ostream& o,
              const ::GeomCapsule& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCapsule_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCapsule_ (::xercesc::XMLFormatTarget& t,
              const ::GeomCapsule& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCapsule_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomCapsule_ (::xercesc::XMLFormatTarget& t,
              const ::GeomCapsule& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCapsule_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCapsule_ (::xercesc::XMLFormatTarget& t,
              const ::GeomCapsule& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomCapsule_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomCapsule_ (::xercesc::DOMDocument& d,
              const ::GeomCapsule& s,
              ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::GeomCapsule) == typeid (s))
  {
    if (n.name () == "GeomCapsule" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GeomCapsule",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "GeomCapsule",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
GeomCapsule_ (const ::GeomCapsule& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::GeomCapsule) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GeomCapsule",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "GeomCapsule",
        "",
        m, s, f));
    d = r;
  }

  ::GeomCapsule_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const GeomSphere& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Radius
  //
  if (i.Radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Radius",
        e));

    s << *i.Radius ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomSphere >
_xsd_GeomSphere_type_serializer_init (
  "GeomSphere",
  "");


void
GeomSphere_ (::std::ostream& o,
             const ::GeomSphere& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomSphere_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomSphere_ (::std::ostream& o,
             const ::GeomSphere& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomSphere_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomSphere_ (::std::ostream& o,
             const ::GeomSphere& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomSphere_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomSphere_ (::xercesc::XMLFormatTarget& t,
             const ::GeomSphere& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomSphere_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomSphere_ (::xercesc::XMLFormatTarget& t,
             const ::GeomSphere& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomSphere_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomSphere_ (::xercesc::XMLFormatTarget& t,
             const ::GeomSphere& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomSphere_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomSphere_ (::xercesc::DOMDocument& d,
             const ::GeomSphere& s,
             ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::GeomSphere) == typeid (s))
  {
    if (n.name () == "GeomSphere" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GeomSphere",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "GeomSphere",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
GeomSphere_ (const ::GeomSphere& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::GeomSphere) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GeomSphere",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "GeomSphere",
        "",
        m, s, f));
    d = r;
  }

  ::GeomSphere_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const GeomPlane& i)
{
  e << static_cast< const ::GeomObject& > (i);

  // Space
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Space ())
    {
      const GeomPlane::Space_type& x (*i.Space ());
      if (typeid (GeomPlane::Space_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Space",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Space",
          "",
          false, false, e, x);
    }
  }

  // Body
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Body ())
    {
      const GeomPlane::Body_type& x (*i.Body ());
      if (typeid (GeomPlane::Body_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Body",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Body",
          "",
          false, false, e, x);
    }
  }

  // Enabled
  //
  if (i.Enabled ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Enabled",
        e));

    s << *i.Enabled ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GeomPlane >
_xsd_GeomPlane_type_serializer_init (
  "GeomPlane",
  "");


void
GeomPlane_ (::std::ostream& o,
            const ::GeomPlane& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomPlane_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomPlane_ (::std::ostream& o,
            const ::GeomPlane& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomPlane_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomPlane_ (::std::ostream& o,
            const ::GeomPlane& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomPlane_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomPlane_ (::xercesc::XMLFormatTarget& t,
            const ::GeomPlane& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomPlane_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
GeomPlane_ (::xercesc::XMLFormatTarget& t,
            const ::GeomPlane& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomPlane_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomPlane_ (::xercesc::XMLFormatTarget& t,
            const ::GeomPlane& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::GeomPlane_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
GeomPlane_ (::xercesc::DOMDocument& d,
            const ::GeomPlane& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::GeomPlane) == typeid (s))
  {
    if (n.name () == "GeomPlane" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GeomPlane",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "GeomPlane",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
GeomPlane_ (const ::GeomPlane& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::GeomPlane) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GeomPlane",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "GeomPlane",
        "",
        m, s, f));
    d = r;
  }

  ::GeomPlane_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Rotation& i)
{
  e << static_cast< const ::RSObject& > (i);

  // Column1
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const Rotation::Column1_type& x (i.Column1 ());
    if (typeid (Rotation::Column1_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Column1",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Column1",
        "",
        false, false, e, x);
  }

  // Column2
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const Rotation::Column2_type& x (i.Column2 ());
    if (typeid (Rotation::Column2_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Column2",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Column2",
        "",
        false, false, e, x);
  }

  // Column3
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const Rotation::Column3_type& x (i.Column3 ());
    if (typeid (Rotation::Column3_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Column3",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Column3",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Rotation >
_xsd_Rotation_type_serializer_init (
  "Rotation",
  "");


void
Rotation_ (::std::ostream& o,
           const ::Rotation& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Rotation_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Rotation_ (::std::ostream& o,
           const ::Rotation& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Rotation_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Rotation_ (::std::ostream& o,
           const ::Rotation& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Rotation_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Rotation_ (::xercesc::XMLFormatTarget& t,
           const ::Rotation& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Rotation_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Rotation_ (::xercesc::XMLFormatTarget& t,
           const ::Rotation& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Rotation_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Rotation_ (::xercesc::XMLFormatTarget& t,
           const ::Rotation& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Rotation_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Rotation_ (::xercesc::DOMDocument& d,
           const ::Rotation& s,
           ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Rotation) == typeid (s))
  {
    if (n.name () == "Rotation" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Rotation",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Rotation",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Rotation_ (const ::Rotation& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Rotation) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Rotation",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Rotation",
        "",
        m, s, f));
    d = r;
  }

  ::Rotation_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Vector& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  if (i.X ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "X",
        e));

    a << *i.X ();
  }

  // Y
  //
  if (i.Y ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Y",
        e));

    a << *i.Y ();
  }

  // Z
  //
  if (i.Z ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Z",
        e));

    a << *i.Z ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Vector >
_xsd_Vector_type_serializer_init (
  "Vector",
  "");


void
Vector_ (::std::ostream& o,
         const ::Vector& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Vector_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Vector_ (::std::ostream& o,
         const ::Vector& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Vector_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Vector_ (::std::ostream& o,
         const ::Vector& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Vector_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Vector_ (::xercesc::XMLFormatTarget& t,
         const ::Vector& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Vector_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Vector_ (::xercesc::XMLFormatTarget& t,
         const ::Vector& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Vector_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Vector_ (::xercesc::XMLFormatTarget& t,
         const ::Vector& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Vector_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Vector_ (::xercesc::DOMDocument& d,
         const ::Vector& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Vector) == typeid (s))
  {
    if (n.name () == "Vector" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Vector",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Vector",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Vector_ (const ::Vector& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Vector) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Vector",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Vector",
        "",
        m, s, f));
    d = r;
  }

  ::Vector_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Quaternion& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // W
  //
  if (i.W ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "W",
        e));

    a << *i.W ();
  }

  // I
  //
  if (i.I ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "I",
        e));

    a << *i.I ();
  }

  // J
  //
  if (i.J ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "J",
        e));

    a << *i.J ();
  }

  // K
  //
  if (i.K ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "K",
        e));

    a << *i.K ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Quaternion >
_xsd_Quaternion_type_serializer_init (
  "Quaternion",
  "");


void
Quaternion_ (::std::ostream& o,
             const ::Quaternion& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Quaternion_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Quaternion_ (::std::ostream& o,
             const ::Quaternion& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Quaternion_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Quaternion_ (::std::ostream& o,
             const ::Quaternion& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Quaternion_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Quaternion_ (::xercesc::XMLFormatTarget& t,
             const ::Quaternion& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Quaternion_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Quaternion_ (::xercesc::XMLFormatTarget& t,
             const ::Quaternion& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Quaternion_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Quaternion_ (::xercesc::XMLFormatTarget& t,
             const ::Quaternion& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Quaternion_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Quaternion_ (::xercesc::DOMDocument& d,
             const ::Quaternion& s,
             ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::Quaternion) == typeid (s))
  {
    if (n.name () == "Quaternion" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Quaternion",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    tsm.serialize (
      "Quaternion",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Quaternion_ (const ::Quaternion& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::Quaternion) == typeid (s))
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      ::xsd::cxx::xml::dom::serialize< char > (
        "Quaternion",
        "",
        m, f));
    d = r;
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
      tsm.serialize (
        "Quaternion",
        "",
        m, s, f));
    d = r;
  }

  ::Quaternion_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Foo& i)
{
  e << static_cast< const ::RSObject& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Foo >
_xsd_Foo_type_serializer_init (
  "Foo",
  "");


void
operator<< (::xercesc::DOMElement& e, const Param& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMAttr&,const Param&)
{
}

void
operator<< (::xml_schema::list_stream&,
            const Param&)
{
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Param >
_xsd_Param_type_serializer_init (
  "Param",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramBounce& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramBounce::Value_type& x (i.Value ());
    if (typeid (paramBounce::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramBounce >
_xsd_paramBounce_type_serializer_init (
  "paramBounce",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamBounce& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamBounce >
_xsd_ParamBounce_type_serializer_init (
  "ParamBounce",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamBounce2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamBounce2 >
_xsd_ParamBounce2_type_serializer_init (
  "ParamBounce2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamBounce3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamBounce3 >
_xsd_ParamBounce3_type_serializer_init (
  "ParamBounce3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramCFM& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramCFM::Value_type& x (i.Value ());
    if (typeid (paramCFM::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramCFM >
_xsd_paramCFM_type_serializer_init (
  "paramCFM",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamCFM& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamCFM >
_xsd_ParamCFM_type_serializer_init (
  "ParamCFM",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamCFM2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamCFM2 >
_xsd_ParamCFM2_type_serializer_init (
  "ParamCFM2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamCFM3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamCFM3 >
_xsd_ParamCFM3_type_serializer_init (
  "ParamCFM3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramFMax& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramFMax::Value_type& x (i.Value ());
    if (typeid (paramFMax::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramFMax >
_xsd_paramFMax_type_serializer_init (
  "paramFMax",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamFMax& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamFMax >
_xsd_ParamFMax_type_serializer_init (
  "ParamFMax",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamFMax2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamFMax2 >
_xsd_ParamFMax2_type_serializer_init (
  "ParamFMax2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamFMax3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamFMax3 >
_xsd_ParamFMax3_type_serializer_init (
  "ParamFMax3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramFudgeFactor& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramFudgeFactor::Value_type& x (i.Value ());
    if (typeid (paramFudgeFactor::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramFudgeFactor >
_xsd_paramFudgeFactor_type_serializer_init (
  "paramFudgeFactor",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamFudgeFactor& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamFudgeFactor >
_xsd_ParamFudgeFactor_type_serializer_init (
  "ParamFudgeFactor",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamFudgeFactor2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamFudgeFactor2 >
_xsd_ParamFudgeFactor2_type_serializer_init (
  "ParamFudgeFactor2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamFudgeFactor3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamFudgeFactor3 >
_xsd_ParamFudgeFactor3_type_serializer_init (
  "ParamFudgeFactor3",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamGroup& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamGroup >
_xsd_ParamGroup_type_serializer_init (
  "ParamGroup",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramHiStop& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramHiStop::Value_type& x (i.Value ());
    if (typeid (paramHiStop::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramHiStop >
_xsd_paramHiStop_type_serializer_init (
  "paramHiStop",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamHiStop& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamHiStop >
_xsd_ParamHiStop_type_serializer_init (
  "ParamHiStop",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamHiStop2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamHiStop2 >
_xsd_ParamHiStop2_type_serializer_init (
  "ParamHiStop2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamHiStop3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamHiStop3 >
_xsd_ParamHiStop3_type_serializer_init (
  "ParamHiStop3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramLoStop& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramLoStop::Value_type& x (i.Value ());
    if (typeid (paramLoStop::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramLoStop >
_xsd_paramLoStop_type_serializer_init (
  "paramLoStop",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamLoStop& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamLoStop >
_xsd_ParamLoStop_type_serializer_init (
  "ParamLoStop",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamLoStop2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamLoStop2 >
_xsd_ParamLoStop2_type_serializer_init (
  "ParamLoStop2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamLoStop3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamLoStop3 >
_xsd_ParamLoStop3_type_serializer_init (
  "ParamLoStop3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramStopCFM& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramStopCFM::Value_type& x (i.Value ());
    if (typeid (paramStopCFM::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramStopCFM >
_xsd_paramStopCFM_type_serializer_init (
  "paramStopCFM",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamStopCFM& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamStopCFM >
_xsd_ParamStopCFM_type_serializer_init (
  "ParamStopCFM",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamStopCFM2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamStopCFM2 >
_xsd_ParamStopCFM2_type_serializer_init (
  "ParamStopCFM2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamStopCFM3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamStopCFM3 >
_xsd_ParamStopCFM3_type_serializer_init (
  "ParamStopCFM3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramStopERP& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramStopERP::Value_type& x (i.Value ());
    if (typeid (paramStopERP::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramStopERP >
_xsd_paramStopERP_type_serializer_init (
  "paramStopERP",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamStopERP& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamStopERP >
_xsd_ParamStopERP_type_serializer_init (
  "ParamStopERP",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamStopERP2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamStopERP2 >
_xsd_ParamStopERP2_type_serializer_init (
  "ParamStopERP2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamStopERP3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamStopERP3 >
_xsd_ParamStopERP3_type_serializer_init (
  "ParamStopERP3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramSuspensionCFM& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramSuspensionCFM::Value_type& x (i.Value ());
    if (typeid (paramSuspensionCFM::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramSuspensionCFM >
_xsd_paramSuspensionCFM_type_serializer_init (
  "paramSuspensionCFM",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamSuspensionCFM& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamSuspensionCFM >
_xsd_ParamSuspensionCFM_type_serializer_init (
  "ParamSuspensionCFM",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamSuspensionCFM2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamSuspensionCFM2 >
_xsd_ParamSuspensionCFM2_type_serializer_init (
  "ParamSuspensionCFM2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamSuspensionCFM3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamSuspensionCFM3 >
_xsd_ParamSuspensionCFM3_type_serializer_init (
  "ParamSuspensionCFM3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramSuspensionERP& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramSuspensionERP::Value_type& x (i.Value ());
    if (typeid (paramSuspensionERP::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramSuspensionERP >
_xsd_paramSuspensionERP_type_serializer_init (
  "paramSuspensionERP",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamSuspensionERP& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamSuspensionERP >
_xsd_ParamSuspensionERP_type_serializer_init (
  "ParamSuspensionERP",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamSuspensionERP2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamSuspensionERP2 >
_xsd_ParamSuspensionERP2_type_serializer_init (
  "ParamSuspensionERP2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamSuspensionERP3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamSuspensionERP3 >
_xsd_ParamSuspensionERP3_type_serializer_init (
  "ParamSuspensionERP3",
  "");


void
operator<< (::xercesc::DOMElement& e, const paramVel& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const paramVel::Value_type& x (i.Value ());
    if (typeid (paramVel::Value_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Value",
        "",
        false, false, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, paramVel >
_xsd_paramVel_type_serializer_init (
  "paramVel",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamVel& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamVel >
_xsd_ParamVel_type_serializer_init (
  "ParamVel",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamVel2& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamVel2 >
_xsd_ParamVel2_type_serializer_init (
  "ParamVel2",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParamVel3& i)
{
  e << static_cast< const ::Param& > (i);

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << *i.Value ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParamVel3 >
_xsd_ParamVel3_type_serializer_init (
  "ParamVel3",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

