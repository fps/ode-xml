// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef ODE_SCHEMA_HXX
#define ODE_SCHEMA_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream < char > list_stream;
  typedef ::xsd::cxx::tree::as_double < double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal < decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class RSObject;
class Sim;
class World;
class GeomObject;
class SpaceBase;
class SimpleSpace;
class Body;
class Mass;
class BoxTotalMass;
class Joint;
class HingeJoint;
class GeomBox;
class GeomCylinder;
class GeomCapsule;
class GeomSphere;
class GeomPlane;
class Rotation;
class Vector;
class Quaternion;
class Foo;

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class RSObject: public ::xml_schema::type
{
  public:
  // Name
  // 
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Constructors.
  //
  RSObject ();

  RSObject (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  RSObject (const RSObject& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual RSObject*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RSObject ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Name_optional Name_;
};

class Sim: public ::RSObject
{
  public:
  // World
  // 
  typedef ::World World_type;
  typedef ::xsd::cxx::tree::sequence< World_type > World_sequence;
  typedef World_sequence::iterator World_iterator;
  typedef World_sequence::const_iterator World_const_iterator;
  typedef ::xsd::cxx::tree::traits< World_type, char > World_traits;

  const World_sequence&
  World () const;

  World_sequence&
  World ();

  void
  World (const World_sequence& s);

  // Space
  // 
  typedef ::SpaceBase Space_type;
  typedef ::xsd::cxx::tree::sequence< Space_type > Space_sequence;
  typedef Space_sequence::iterator Space_iterator;
  typedef Space_sequence::const_iterator Space_const_iterator;
  typedef ::xsd::cxx::tree::traits< Space_type, char > Space_traits;

  const Space_sequence&
  Space () const;

  Space_sequence&
  Space ();

  void
  Space (const Space_sequence& s);

  // Body
  // 
  typedef ::Body Body_type;
  typedef ::xsd::cxx::tree::sequence< Body_type > Body_sequence;
  typedef Body_sequence::iterator Body_iterator;
  typedef Body_sequence::const_iterator Body_const_iterator;
  typedef ::xsd::cxx::tree::traits< Body_type, char > Body_traits;

  const Body_sequence&
  Body () const;

  Body_sequence&
  Body ();

  void
  Body (const Body_sequence& s);

  // Geom
  // 
  typedef ::GeomObject Geom_type;
  typedef ::xsd::cxx::tree::sequence< Geom_type > Geom_sequence;
  typedef Geom_sequence::iterator Geom_iterator;
  typedef Geom_sequence::const_iterator Geom_const_iterator;
  typedef ::xsd::cxx::tree::traits< Geom_type, char > Geom_traits;

  const Geom_sequence&
  Geom () const;

  Geom_sequence&
  Geom ();

  void
  Geom (const Geom_sequence& s);

  // Constructors.
  //
  Sim ();

  Sim (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  Sim (const Sim& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual Sim*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Sim ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  World_sequence World_;
  Space_sequence Space_;
  Body_sequence Body_;
  Geom_sequence Geom_;
};

class World: public ::RSObject
{
  public:
  // AutoDisableAngularThreshold
  // 
  typedef ::xml_schema::float_ AutoDisableAngularThreshold_type;
  typedef ::xsd::cxx::tree::optional< AutoDisableAngularThreshold_type > AutoDisableAngularThreshold_optional;
  typedef ::xsd::cxx::tree::traits< AutoDisableAngularThreshold_type, char > AutoDisableAngularThreshold_traits;

  const AutoDisableAngularThreshold_optional&
  AutoDisableAngularThreshold () const;

  AutoDisableAngularThreshold_optional&
  AutoDisableAngularThreshold ();

  void
  AutoDisableAngularThreshold (const AutoDisableAngularThreshold_type& x);

  void
  AutoDisableAngularThreshold (const AutoDisableAngularThreshold_optional& x);

  // AutoDisableFlag
  // 
  typedef ::xml_schema::boolean AutoDisableFlag_type;
  typedef ::xsd::cxx::tree::optional< AutoDisableFlag_type > AutoDisableFlag_optional;
  typedef ::xsd::cxx::tree::traits< AutoDisableFlag_type, char > AutoDisableFlag_traits;

  const AutoDisableFlag_optional&
  AutoDisableFlag () const;

  AutoDisableFlag_optional&
  AutoDisableFlag ();

  void
  AutoDisableFlag (const AutoDisableFlag_type& x);

  void
  AutoDisableFlag (const AutoDisableFlag_optional& x);

  // AutoDisableSteps
  // 
  typedef ::xml_schema::boolean AutoDisableSteps_type;
  typedef ::xsd::cxx::tree::optional< AutoDisableSteps_type > AutoDisableSteps_optional;
  typedef ::xsd::cxx::tree::traits< AutoDisableSteps_type, char > AutoDisableSteps_traits;

  const AutoDisableSteps_optional&
  AutoDisableSteps () const;

  AutoDisableSteps_optional&
  AutoDisableSteps ();

  void
  AutoDisableSteps (const AutoDisableSteps_type& x);

  void
  AutoDisableSteps (const AutoDisableSteps_optional& x);

  // AutoDisableTime
  // 
  typedef ::xml_schema::boolean AutoDisableTime_type;
  typedef ::xsd::cxx::tree::optional< AutoDisableTime_type > AutoDisableTime_optional;
  typedef ::xsd::cxx::tree::traits< AutoDisableTime_type, char > AutoDisableTime_traits;

  const AutoDisableTime_optional&
  AutoDisableTime () const;

  AutoDisableTime_optional&
  AutoDisableTime ();

  void
  AutoDisableTime (const AutoDisableTime_type& x);

  void
  AutoDisableTime (const AutoDisableTime_optional& x);

  // CFM
  // 
  typedef ::xml_schema::float_ CFM_type;
  typedef ::xsd::cxx::tree::optional< CFM_type > CFM_optional;
  typedef ::xsd::cxx::tree::traits< CFM_type, char > CFM_traits;

  const CFM_optional&
  CFM () const;

  CFM_optional&
  CFM ();

  void
  CFM (const CFM_type& x);

  void
  CFM (const CFM_optional& x);

  // ContactMaxCorrectingVel
  // 
  typedef ::xml_schema::float_ ContactMaxCorrectingVel_type;
  typedef ::xsd::cxx::tree::optional< ContactMaxCorrectingVel_type > ContactMaxCorrectingVel_optional;
  typedef ::xsd::cxx::tree::traits< ContactMaxCorrectingVel_type, char > ContactMaxCorrectingVel_traits;

  const ContactMaxCorrectingVel_optional&
  ContactMaxCorrectingVel () const;

  ContactMaxCorrectingVel_optional&
  ContactMaxCorrectingVel ();

  void
  ContactMaxCorrectingVel (const ContactMaxCorrectingVel_type& x);

  void
  ContactMaxCorrectingVel (const ContactMaxCorrectingVel_optional& x);

  // ContactSurfaceLayer
  // 
  typedef ::xml_schema::float_ ContactSurfaceLayer_type;
  typedef ::xsd::cxx::tree::optional< ContactSurfaceLayer_type > ContactSurfaceLayer_optional;
  typedef ::xsd::cxx::tree::traits< ContactSurfaceLayer_type, char > ContactSurfaceLayer_traits;

  const ContactSurfaceLayer_optional&
  ContactSurfaceLayer () const;

  ContactSurfaceLayer_optional&
  ContactSurfaceLayer ();

  void
  ContactSurfaceLayer (const ContactSurfaceLayer_type& x);

  void
  ContactSurfaceLayer (const ContactSurfaceLayer_optional& x);

  // ERP
  // 
  typedef ::xml_schema::float_ ERP_type;
  typedef ::xsd::cxx::tree::optional< ERP_type > ERP_optional;
  typedef ::xsd::cxx::tree::traits< ERP_type, char > ERP_traits;

  const ERP_optional&
  ERP () const;

  ERP_optional&
  ERP ();

  void
  ERP (const ERP_type& x);

  void
  ERP (const ERP_optional& x);

  // Gravity
  // 
  typedef ::Vector Gravity_type;
  typedef ::xsd::cxx::tree::optional< Gravity_type > Gravity_optional;
  typedef ::xsd::cxx::tree::traits< Gravity_type, char > Gravity_traits;

  const Gravity_optional&
  Gravity () const;

  Gravity_optional&
  Gravity ();

  void
  Gravity (const Gravity_type& x);

  void
  Gravity (const Gravity_optional& x);

  void
  Gravity (::std::auto_ptr< Gravity_type > p);

  // QuickStepNumIterations
  // 
  typedef ::xml_schema::non_negative_integer QuickStepNumIterations_type;
  typedef ::xsd::cxx::tree::optional< QuickStepNumIterations_type > QuickStepNumIterations_optional;
  typedef ::xsd::cxx::tree::traits< QuickStepNumIterations_type, char > QuickStepNumIterations_traits;

  const QuickStepNumIterations_optional&
  QuickStepNumIterations () const;

  QuickStepNumIterations_optional&
  QuickStepNumIterations ();

  void
  QuickStepNumIterations (const QuickStepNumIterations_type& x);

  void
  QuickStepNumIterations (const QuickStepNumIterations_optional& x);

  // Body
  // 
  typedef ::xml_schema::string Body_type;
  typedef ::xsd::cxx::tree::sequence< Body_type > Body_sequence;
  typedef Body_sequence::iterator Body_iterator;
  typedef Body_sequence::const_iterator Body_const_iterator;
  typedef ::xsd::cxx::tree::traits< Body_type, char > Body_traits;

  const Body_sequence&
  Body () const;

  Body_sequence&
  Body ();

  void
  Body (const Body_sequence& s);

  // Constructors.
  //
  World ();

  World (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  World (const World& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual World*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~World ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AutoDisableAngularThreshold_optional AutoDisableAngularThreshold_;
  AutoDisableFlag_optional AutoDisableFlag_;
  AutoDisableSteps_optional AutoDisableSteps_;
  AutoDisableTime_optional AutoDisableTime_;
  CFM_optional CFM_;
  ContactMaxCorrectingVel_optional ContactMaxCorrectingVel_;
  ContactSurfaceLayer_optional ContactSurfaceLayer_;
  ERP_optional ERP_;
  Gravity_optional Gravity_;
  QuickStepNumIterations_optional QuickStepNumIterations_;
  Body_sequence Body_;
};

class GeomObject: public ::RSObject
{
  public:
  // Enable
  // 
  typedef ::xml_schema::boolean Enable_type;
  typedef ::xsd::cxx::tree::optional< Enable_type > Enable_optional;
  typedef ::xsd::cxx::tree::traits< Enable_type, char > Enable_traits;

  const Enable_optional&
  Enable () const;

  Enable_optional&
  Enable ();

  void
  Enable (const Enable_type& x);

  void
  Enable (const Enable_optional& x);

  // CategoryBits
  // 
  typedef ::xml_schema::non_negative_integer CategoryBits_type;
  typedef ::xsd::cxx::tree::optional< CategoryBits_type > CategoryBits_optional;
  typedef ::xsd::cxx::tree::traits< CategoryBits_type, char > CategoryBits_traits;

  const CategoryBits_optional&
  CategoryBits () const;

  CategoryBits_optional&
  CategoryBits ();

  void
  CategoryBits (const CategoryBits_type& x);

  void
  CategoryBits (const CategoryBits_optional& x);

  // CollideBits
  // 
  typedef ::xml_schema::non_negative_integer CollideBits_type;
  typedef ::xsd::cxx::tree::optional< CollideBits_type > CollideBits_optional;
  typedef ::xsd::cxx::tree::traits< CollideBits_type, char > CollideBits_traits;

  const CollideBits_optional&
  CollideBits () const;

  CollideBits_optional&
  CollideBits ();

  void
  CollideBits (const CollideBits_type& x);

  void
  CollideBits (const CollideBits_optional& x);

  // Position
  // 
  typedef ::Vector Position_type;
  typedef ::xsd::cxx::tree::optional< Position_type > Position_optional;
  typedef ::xsd::cxx::tree::traits< Position_type, char > Position_traits;

  const Position_optional&
  Position () const;

  Position_optional&
  Position ();

  void
  Position (const Position_type& x);

  void
  Position (const Position_optional& x);

  void
  Position (::std::auto_ptr< Position_type > p);

  // Quaternion
  // 
  typedef ::Quaternion Quaternion_type;
  typedef ::xsd::cxx::tree::optional< Quaternion_type > Quaternion_optional;
  typedef ::xsd::cxx::tree::traits< Quaternion_type, char > Quaternion_traits;

  const Quaternion_optional&
  Quaternion () const;

  Quaternion_optional&
  Quaternion ();

  void
  Quaternion (const Quaternion_type& x);

  void
  Quaternion (const Quaternion_optional& x);

  void
  Quaternion (::std::auto_ptr< Quaternion_type > p);

  // Rotation
  // 
  typedef ::Rotation Rotation_type;
  typedef ::xsd::cxx::tree::optional< Rotation_type > Rotation_optional;
  typedef ::xsd::cxx::tree::traits< Rotation_type, char > Rotation_traits;

  const Rotation_optional&
  Rotation () const;

  Rotation_optional&
  Rotation ();

  void
  Rotation (const Rotation_type& x);

  void
  Rotation (const Rotation_optional& x);

  void
  Rotation (::std::auto_ptr< Rotation_type > p);

  // Constructors.
  //
  GeomObject ();

  GeomObject (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  GeomObject (const GeomObject& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual GeomObject*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~GeomObject ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Enable_optional Enable_;
  CategoryBits_optional CategoryBits_;
  CollideBits_optional CollideBits_;
  Position_optional Position_;
  Quaternion_optional Quaternion_;
  Rotation_optional Rotation_;
};

class SpaceBase: public ::GeomObject
{
  public:
  // Geom
  // 
  typedef ::GeomObject Geom_type;
  typedef ::xsd::cxx::tree::sequence< Geom_type > Geom_sequence;
  typedef Geom_sequence::iterator Geom_iterator;
  typedef Geom_sequence::const_iterator Geom_const_iterator;
  typedef ::xsd::cxx::tree::traits< Geom_type, char > Geom_traits;

  const Geom_sequence&
  Geom () const;

  Geom_sequence&
  Geom ();

  void
  Geom (const Geom_sequence& s);

  // Constructors.
  //
  SpaceBase ();

  SpaceBase (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  SpaceBase (const SpaceBase& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual SpaceBase*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~SpaceBase ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Geom_sequence Geom_;
};

class SimpleSpace: public ::SpaceBase
{
  public:
  // Constructors.
  //
  SimpleSpace ();

  SimpleSpace (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  SimpleSpace (const SimpleSpace& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual SimpleSpace*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~SimpleSpace ();
};

class Body: public ::RSObject
{
  public:
  // Space
  // 
  typedef ::xml_schema::string Space_type;
  typedef ::xsd::cxx::tree::optional< Space_type > Space_optional;
  typedef ::xsd::cxx::tree::traits< Space_type, char > Space_traits;

  const Space_optional&
  Space () const;

  Space_optional&
  Space ();

  void
  Space (const Space_type& x);

  void
  Space (const Space_optional& x);

  void
  Space (::std::auto_ptr< Space_type > p);

  // World
  // 
  typedef ::xml_schema::string World_type;
  typedef ::xsd::cxx::tree::optional< World_type > World_optional;
  typedef ::xsd::cxx::tree::traits< World_type, char > World_traits;

  const World_optional&
  World () const;

  World_optional&
  World ();

  void
  World (const World_type& x);

  void
  World (const World_optional& x);

  void
  World (::std::auto_ptr< World_type > p);

  // Enabled
  // 
  typedef ::xml_schema::boolean Enabled_type;
  typedef ::xsd::cxx::tree::optional< Enabled_type > Enabled_optional;
  typedef ::xsd::cxx::tree::traits< Enabled_type, char > Enabled_traits;

  const Enabled_optional&
  Enabled () const;

  Enabled_optional&
  Enabled ();

  void
  Enabled (const Enabled_type& x);

  void
  Enabled (const Enabled_optional& x);

  // AngularVel
  // 
  typedef ::Vector AngularVel_type;
  typedef ::xsd::cxx::tree::optional< AngularVel_type > AngularVel_optional;
  typedef ::xsd::cxx::tree::traits< AngularVel_type, char > AngularVel_traits;

  const AngularVel_optional&
  AngularVel () const;

  AngularVel_optional&
  AngularVel ();

  void
  AngularVel (const AngularVel_type& x);

  void
  AngularVel (const AngularVel_optional& x);

  void
  AngularVel (::std::auto_ptr< AngularVel_type > p);

  // FiniteRotationAxis
  // 
  typedef ::Vector FiniteRotationAxis_type;
  typedef ::xsd::cxx::tree::optional< FiniteRotationAxis_type > FiniteRotationAxis_optional;
  typedef ::xsd::cxx::tree::traits< FiniteRotationAxis_type, char > FiniteRotationAxis_traits;

  const FiniteRotationAxis_optional&
  FiniteRotationAxis () const;

  FiniteRotationAxis_optional&
  FiniteRotationAxis ();

  void
  FiniteRotationAxis (const FiniteRotationAxis_type& x);

  void
  FiniteRotationAxis (const FiniteRotationAxis_optional& x);

  void
  FiniteRotationAxis (::std::auto_ptr< FiniteRotationAxis_type > p);

  // FiniteRotationMode
  // 
  typedef ::xml_schema::non_negative_integer FiniteRotationMode_type;
  typedef ::xsd::cxx::tree::optional< FiniteRotationMode_type > FiniteRotationMode_optional;
  typedef ::xsd::cxx::tree::traits< FiniteRotationMode_type, char > FiniteRotationMode_traits;

  const FiniteRotationMode_optional&
  FiniteRotationMode () const;

  FiniteRotationMode_optional&
  FiniteRotationMode ();

  void
  FiniteRotationMode (const FiniteRotationMode_type& x);

  void
  FiniteRotationMode (const FiniteRotationMode_optional& x);

  // Force
  // 
  typedef ::Vector Force_type;
  typedef ::xsd::cxx::tree::optional< Force_type > Force_optional;
  typedef ::xsd::cxx::tree::traits< Force_type, char > Force_traits;

  const Force_optional&
  Force () const;

  Force_optional&
  Force ();

  void
  Force (const Force_type& x);

  void
  Force (const Force_optional& x);

  void
  Force (::std::auto_ptr< Force_type > p);

  // GravityMode
  // 
  typedef ::xml_schema::boolean GravityMode_type;
  typedef ::xsd::cxx::tree::optional< GravityMode_type > GravityMode_optional;
  typedef ::xsd::cxx::tree::traits< GravityMode_type, char > GravityMode_traits;

  const GravityMode_optional&
  GravityMode () const;

  GravityMode_optional&
  GravityMode ();

  void
  GravityMode (const GravityMode_type& x);

  void
  GravityMode (const GravityMode_optional& x);

  // LinearVel
  // 
  typedef ::Vector LinearVel_type;
  typedef ::xsd::cxx::tree::optional< LinearVel_type > LinearVel_optional;
  typedef ::xsd::cxx::tree::traits< LinearVel_type, char > LinearVel_traits;

  const LinearVel_optional&
  LinearVel () const;

  LinearVel_optional&
  LinearVel ();

  void
  LinearVel (const LinearVel_type& x);

  void
  LinearVel (const LinearVel_optional& x);

  void
  LinearVel (::std::auto_ptr< LinearVel_type > p);

  // Mass
  // 
  typedef ::Mass Mass_type;
  typedef ::xsd::cxx::tree::optional< Mass_type > Mass_optional;
  typedef ::xsd::cxx::tree::traits< Mass_type, char > Mass_traits;

  const Mass_optional&
  Mass () const;

  Mass_optional&
  Mass ();

  void
  Mass (const Mass_type& x);

  void
  Mass (const Mass_optional& x);

  void
  Mass (::std::auto_ptr< Mass_type > p);

  // Torque
  // 
  typedef ::Vector Torque_type;
  typedef ::xsd::cxx::tree::optional< Torque_type > Torque_optional;
  typedef ::xsd::cxx::tree::traits< Torque_type, char > Torque_traits;

  const Torque_optional&
  Torque () const;

  Torque_optional&
  Torque ();

  void
  Torque (const Torque_type& x);

  void
  Torque (const Torque_optional& x);

  void
  Torque (::std::auto_ptr< Torque_type > p);

  // Position
  // 
  typedef ::Vector Position_type;
  typedef ::xsd::cxx::tree::optional< Position_type > Position_optional;
  typedef ::xsd::cxx::tree::traits< Position_type, char > Position_traits;

  const Position_optional&
  Position () const;

  Position_optional&
  Position ();

  void
  Position (const Position_type& x);

  void
  Position (const Position_optional& x);

  void
  Position (::std::auto_ptr< Position_type > p);

  // Quaternion
  // 
  typedef ::Quaternion Quaternion_type;
  typedef ::xsd::cxx::tree::optional< Quaternion_type > Quaternion_optional;
  typedef ::xsd::cxx::tree::traits< Quaternion_type, char > Quaternion_traits;

  const Quaternion_optional&
  Quaternion () const;

  Quaternion_optional&
  Quaternion ();

  void
  Quaternion (const Quaternion_type& x);

  void
  Quaternion (const Quaternion_optional& x);

  void
  Quaternion (::std::auto_ptr< Quaternion_type > p);

  // Rotation
  // 
  typedef ::Rotation Rotation_type;
  typedef ::xsd::cxx::tree::optional< Rotation_type > Rotation_optional;
  typedef ::xsd::cxx::tree::traits< Rotation_type, char > Rotation_traits;

  const Rotation_optional&
  Rotation () const;

  Rotation_optional&
  Rotation ();

  void
  Rotation (const Rotation_type& x);

  void
  Rotation (const Rotation_optional& x);

  void
  Rotation (::std::auto_ptr< Rotation_type > p);

  // Constructors.
  //
  Body ();

  Body (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Body (const Body& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Body*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Body ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Space_optional Space_;
  World_optional World_;
  Enabled_optional Enabled_;
  AngularVel_optional AngularVel_;
  FiniteRotationAxis_optional FiniteRotationAxis_;
  FiniteRotationMode_optional FiniteRotationMode_;
  Force_optional Force_;
  GravityMode_optional GravityMode_;
  LinearVel_optional LinearVel_;
  Mass_optional Mass_;
  Torque_optional Torque_;
  Position_optional Position_;
  Quaternion_optional Quaternion_;
  Rotation_optional Rotation_;
};

class Mass: public ::RSObject
{
  public:
  // Constructors.
  //
  Mass ();

  Mass (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  Mass (const Mass& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  virtual Mass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Mass ();
};

class BoxTotalMass: public ::Mass
{
  public:
  // M
  // 
  typedef ::xml_schema::float_ M_type;
  typedef ::xsd::cxx::tree::optional< M_type > M_optional;
  typedef ::xsd::cxx::tree::traits< M_type, char > M_traits;

  const M_optional&
  M () const;

  M_optional&
  M ();

  void
  M (const M_type& x);

  void
  M (const M_optional& x);

  // LX
  // 
  typedef ::xml_schema::float_ LX_type;
  typedef ::xsd::cxx::tree::optional< LX_type > LX_optional;
  typedef ::xsd::cxx::tree::traits< LX_type, char > LX_traits;

  const LX_optional&
  LX () const;

  LX_optional&
  LX ();

  void
  LX (const LX_type& x);

  void
  LX (const LX_optional& x);

  // LY
  // 
  typedef ::xml_schema::float_ LY_type;
  typedef ::xsd::cxx::tree::optional< LY_type > LY_optional;
  typedef ::xsd::cxx::tree::traits< LY_type, char > LY_traits;

  const LY_optional&
  LY () const;

  LY_optional&
  LY ();

  void
  LY (const LY_type& x);

  void
  LY (const LY_optional& x);

  // LZ
  // 
  typedef ::xml_schema::float_ LZ_type;
  typedef ::xsd::cxx::tree::optional< LZ_type > LZ_optional;
  typedef ::xsd::cxx::tree::traits< LZ_type, char > LZ_traits;

  const LZ_optional&
  LZ () const;

  LZ_optional&
  LZ ();

  void
  LZ (const LZ_type& x);

  void
  LZ (const LZ_optional& x);

  // Constructors.
  //
  BoxTotalMass ();

  BoxTotalMass (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  BoxTotalMass (const BoxTotalMass& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual BoxTotalMass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~BoxTotalMass ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  M_optional M_;
  LX_optional LX_;
  LY_optional LY_;
  LZ_optional LZ_;
};

class Joint: public ::RSObject
{
  public:
  // Feedback
  // 
  typedef ::xml_schema::boolean Feedback_type;
  typedef ::xsd::cxx::tree::optional< Feedback_type > Feedback_optional;
  typedef ::xsd::cxx::tree::traits< Feedback_type, char > Feedback_traits;

  const Feedback_optional&
  Feedback () const;

  Feedback_optional&
  Feedback ();

  void
  Feedback (const Feedback_type& x);

  void
  Feedback (const Feedback_optional& x);

  // Body1
  // 
  typedef ::xml_schema::string Body1_type;
  typedef ::xsd::cxx::tree::optional< Body1_type > Body1_optional;
  typedef ::xsd::cxx::tree::traits< Body1_type, char > Body1_traits;

  const Body1_optional&
  Body1 () const;

  Body1_optional&
  Body1 ();

  void
  Body1 (const Body1_type& x);

  void
  Body1 (const Body1_optional& x);

  void
  Body1 (::std::auto_ptr< Body1_type > p);

  // Body2
  // 
  typedef ::xml_schema::string Body2_type;
  typedef ::xsd::cxx::tree::optional< Body2_type > Body2_optional;
  typedef ::xsd::cxx::tree::traits< Body2_type, char > Body2_traits;

  const Body2_optional&
  Body2 () const;

  Body2_optional&
  Body2 ();

  void
  Body2 (const Body2_type& x);

  void
  Body2 (const Body2_optional& x);

  void
  Body2 (::std::auto_ptr< Body2_type > p);

  // Constructors.
  //
  Joint ();

  Joint (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  Joint (const Joint& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  virtual Joint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Joint ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Feedback_optional Feedback_;
  Body1_optional Body1_;
  Body2_optional Body2_;
};

class HingeJoint: public ::Joint
{
  public:
  // Anchor
  // 
  typedef ::Vector Anchor_type;
  typedef ::xsd::cxx::tree::optional< Anchor_type > Anchor_optional;
  typedef ::xsd::cxx::tree::traits< Anchor_type, char > Anchor_traits;

  const Anchor_optional&
  Anchor () const;

  Anchor_optional&
  Anchor ();

  void
  Anchor (const Anchor_type& x);

  void
  Anchor (const Anchor_optional& x);

  void
  Anchor (::std::auto_ptr< Anchor_type > p);

  // Axis
  // 
  typedef ::Vector Axis_type;
  typedef ::xsd::cxx::tree::optional< Axis_type > Axis_optional;
  typedef ::xsd::cxx::tree::traits< Axis_type, char > Axis_traits;

  const Axis_optional&
  Axis () const;

  Axis_optional&
  Axis ();

  void
  Axis (const Axis_type& x);

  void
  Axis (const Axis_optional& x);

  void
  Axis (::std::auto_ptr< Axis_type > p);

  // Torque
  // 
  typedef ::xml_schema::float_ Torque_type;
  typedef ::xsd::cxx::tree::optional< Torque_type > Torque_optional;
  typedef ::xsd::cxx::tree::traits< Torque_type, char > Torque_traits;

  const Torque_optional&
  Torque () const;

  Torque_optional&
  Torque ();

  void
  Torque (const Torque_type& x);

  void
  Torque (const Torque_optional& x);

  // Constructors.
  //
  HingeJoint ();

  HingeJoint (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  HingeJoint (const HingeJoint& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual HingeJoint*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~HingeJoint ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Anchor_optional Anchor_;
  Axis_optional Axis_;
  Torque_optional Torque_;
};

class GeomBox: public ::GeomObject
{
  public:
  // Lengths
  // 
  typedef ::Vector Lengths_type;
  typedef ::xsd::cxx::tree::optional< Lengths_type > Lengths_optional;
  typedef ::xsd::cxx::tree::traits< Lengths_type, char > Lengths_traits;

  const Lengths_optional&
  Lengths () const;

  Lengths_optional&
  Lengths ();

  void
  Lengths (const Lengths_type& x);

  void
  Lengths (const Lengths_optional& x);

  void
  Lengths (::std::auto_ptr< Lengths_type > p);

  // Constructors.
  //
  GeomBox ();

  GeomBox (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  GeomBox (const GeomBox& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual GeomBox*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~GeomBox ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Lengths_optional Lengths_;
};

class GeomCylinder: public ::GeomObject
{
  public:
  // Length
  // 
  typedef ::xml_schema::float_ Length_type;
  typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
  typedef ::xsd::cxx::tree::traits< Length_type, char > Length_traits;

  const Length_optional&
  Length () const;

  Length_optional&
  Length ();

  void
  Length (const Length_type& x);

  void
  Length (const Length_optional& x);

  // Radius
  // 
  typedef ::xml_schema::float_ Radius_type;
  typedef ::xsd::cxx::tree::optional< Radius_type > Radius_optional;
  typedef ::xsd::cxx::tree::traits< Radius_type, char > Radius_traits;

  const Radius_optional&
  Radius () const;

  Radius_optional&
  Radius ();

  void
  Radius (const Radius_type& x);

  void
  Radius (const Radius_optional& x);

  // Constructors.
  //
  GeomCylinder ();

  GeomCylinder (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  GeomCylinder (const GeomCylinder& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual GeomCylinder*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~GeomCylinder ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Length_optional Length_;
  Radius_optional Radius_;
};

class GeomCapsule: public ::GeomObject
{
  public:
  // Length
  // 
  typedef ::xml_schema::float_ Length_type;
  typedef ::xsd::cxx::tree::optional< Length_type > Length_optional;
  typedef ::xsd::cxx::tree::traits< Length_type, char > Length_traits;

  const Length_optional&
  Length () const;

  Length_optional&
  Length ();

  void
  Length (const Length_type& x);

  void
  Length (const Length_optional& x);

  // Radius
  // 
  typedef ::xml_schema::float_ Radius_type;
  typedef ::xsd::cxx::tree::optional< Radius_type > Radius_optional;
  typedef ::xsd::cxx::tree::traits< Radius_type, char > Radius_traits;

  const Radius_optional&
  Radius () const;

  Radius_optional&
  Radius ();

  void
  Radius (const Radius_type& x);

  void
  Radius (const Radius_optional& x);

  // Constructors.
  //
  GeomCapsule ();

  GeomCapsule (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  GeomCapsule (const GeomCapsule& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual GeomCapsule*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~GeomCapsule ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Length_optional Length_;
  Radius_optional Radius_;
};

class GeomSphere: public ::GeomObject
{
  public:
  // Radius
  // 
  typedef ::xml_schema::float_ Radius_type;
  typedef ::xsd::cxx::tree::optional< Radius_type > Radius_optional;
  typedef ::xsd::cxx::tree::traits< Radius_type, char > Radius_traits;

  const Radius_optional&
  Radius () const;

  Radius_optional&
  Radius ();

  void
  Radius (const Radius_type& x);

  void
  Radius (const Radius_optional& x);

  // Constructors.
  //
  GeomSphere ();

  GeomSphere (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  GeomSphere (const GeomSphere& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual GeomSphere*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~GeomSphere ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Radius_optional Radius_;
};

class GeomPlane: public ::GeomObject
{
  public:
  // Space
  // 
  typedef ::xml_schema::string Space_type;
  typedef ::xsd::cxx::tree::optional< Space_type > Space_optional;
  typedef ::xsd::cxx::tree::traits< Space_type, char > Space_traits;

  const Space_optional&
  Space () const;

  Space_optional&
  Space ();

  void
  Space (const Space_type& x);

  void
  Space (const Space_optional& x);

  void
  Space (::std::auto_ptr< Space_type > p);

  // Body
  // 
  typedef ::xml_schema::string Body_type;
  typedef ::xsd::cxx::tree::optional< Body_type > Body_optional;
  typedef ::xsd::cxx::tree::traits< Body_type, char > Body_traits;

  const Body_optional&
  Body () const;

  Body_optional&
  Body ();

  void
  Body (const Body_type& x);

  void
  Body (const Body_optional& x);

  void
  Body (::std::auto_ptr< Body_type > p);

  // Enabled
  // 
  typedef ::xml_schema::boolean Enabled_type;
  typedef ::xsd::cxx::tree::optional< Enabled_type > Enabled_optional;
  typedef ::xsd::cxx::tree::traits< Enabled_type, char > Enabled_traits;

  const Enabled_optional&
  Enabled () const;

  Enabled_optional&
  Enabled ();

  void
  Enabled (const Enabled_type& x);

  void
  Enabled (const Enabled_optional& x);

  // Constructors.
  //
  GeomPlane ();

  GeomPlane (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  GeomPlane (const GeomPlane& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual GeomPlane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~GeomPlane ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Space_optional Space_;
  Body_optional Body_;
  Enabled_optional Enabled_;
};

class Rotation: public ::RSObject
{
  public:
  // Column1
  // 
  typedef ::Vector Column1_type;
  typedef ::xsd::cxx::tree::traits< Column1_type, char > Column1_traits;

  const Column1_type&
  Column1 () const;

  Column1_type&
  Column1 ();

  void
  Column1 (const Column1_type& x);

  void
  Column1 (::std::auto_ptr< Column1_type > p);

  // Column2
  // 
  typedef ::Vector Column2_type;
  typedef ::xsd::cxx::tree::traits< Column2_type, char > Column2_traits;

  const Column2_type&
  Column2 () const;

  Column2_type&
  Column2 ();

  void
  Column2 (const Column2_type& x);

  void
  Column2 (::std::auto_ptr< Column2_type > p);

  // Column3
  // 
  typedef ::Vector Column3_type;
  typedef ::xsd::cxx::tree::traits< Column3_type, char > Column3_traits;

  const Column3_type&
  Column3 () const;

  Column3_type&
  Column3 ();

  void
  Column3 (const Column3_type& x);

  void
  Column3 (::std::auto_ptr< Column3_type > p);

  // Constructors.
  //
  Rotation (const Column1_type&,
            const Column2_type&,
            const Column3_type&);

  Rotation (::std::auto_ptr< Column1_type >&,
            ::std::auto_ptr< Column2_type >&,
            ::std::auto_ptr< Column3_type >&);

  Rotation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Rotation (const Rotation& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Rotation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Rotation ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Column1_type > Column1_;
  ::xsd::cxx::tree::one< Column2_type > Column2_;
  ::xsd::cxx::tree::one< Column3_type > Column3_;
};

class Vector: public ::xml_schema::type
{
  public:
  // X
  // 
  typedef ::xml_schema::float_ X_type;
  typedef ::xsd::cxx::tree::optional< X_type > X_optional;
  typedef ::xsd::cxx::tree::traits< X_type, char > X_traits;

  const X_optional&
  X () const;

  X_optional&
  X ();

  void
  X (const X_type& x);

  void
  X (const X_optional& x);

  // Y
  // 
  typedef ::xml_schema::float_ Y_type;
  typedef ::xsd::cxx::tree::optional< Y_type > Y_optional;
  typedef ::xsd::cxx::tree::traits< Y_type, char > Y_traits;

  const Y_optional&
  Y () const;

  Y_optional&
  Y ();

  void
  Y (const Y_type& x);

  void
  Y (const Y_optional& x);

  // Z
  // 
  typedef ::xml_schema::float_ Z_type;
  typedef ::xsd::cxx::tree::optional< Z_type > Z_optional;
  typedef ::xsd::cxx::tree::traits< Z_type, char > Z_traits;

  const Z_optional&
  Z () const;

  Z_optional&
  Z ();

  void
  Z (const Z_type& x);

  void
  Z (const Z_optional& x);

  // Constructors.
  //
  Vector ();

  Vector (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  Vector (const Vector& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  virtual Vector*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Vector ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  X_optional X_;
  Y_optional Y_;
  Z_optional Z_;
};

class Quaternion: public ::xml_schema::type
{
  public:
  // W
  // 
  typedef ::xml_schema::float_ W_type;
  typedef ::xsd::cxx::tree::optional< W_type > W_optional;
  typedef ::xsd::cxx::tree::traits< W_type, char > W_traits;

  const W_optional&
  W () const;

  W_optional&
  W ();

  void
  W (const W_type& x);

  void
  W (const W_optional& x);

  // I
  // 
  typedef ::xml_schema::float_ I_type;
  typedef ::xsd::cxx::tree::optional< I_type > I_optional;
  typedef ::xsd::cxx::tree::traits< I_type, char > I_traits;

  const I_optional&
  I () const;

  I_optional&
  I ();

  void
  I (const I_type& x);

  void
  I (const I_optional& x);

  // J
  // 
  typedef ::xml_schema::float_ J_type;
  typedef ::xsd::cxx::tree::optional< J_type > J_optional;
  typedef ::xsd::cxx::tree::traits< J_type, char > J_traits;

  const J_optional&
  J () const;

  J_optional&
  J ();

  void
  J (const J_type& x);

  void
  J (const J_optional& x);

  // K
  // 
  typedef ::xml_schema::float_ K_type;
  typedef ::xsd::cxx::tree::optional< K_type > K_optional;
  typedef ::xsd::cxx::tree::traits< K_type, char > K_traits;

  const K_optional&
  K () const;

  K_optional&
  K ();

  void
  K (const K_type& x);

  void
  K (const K_optional& x);

  // Constructors.
  //
  Quaternion ();

  Quaternion (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  Quaternion (const Quaternion& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual Quaternion*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Quaternion ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  W_optional W_;
  I_optional I_;
  J_optional J_;
  K_optional K_;
};

class Foo: public ::RSObject
{
  public:
  // Constructors.
  //
  Foo ();

  Foo (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  Foo (const Foo& x,
       ::xml_schema::flags f = 0,
       ::xml_schema::container* c = 0);

  virtual Foo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~Foo ();
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& uri,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& uri,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& uri,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& id,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& id,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& is,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& is,
      ::xml_schema::error_handler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& is,
      ::xercesc::DOMErrorHandler& eh,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::Sim >
Sim_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Sim >
Sim_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f = 0,
      const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse a URI or a local file.
//

::std::auto_ptr< ::World >
World_ (const ::std::string& uri,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (const ::std::string& uri,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (const ::std::string& uri,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& id,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::World >
World_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::World >
World_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse a URI or a local file.
//

::std::auto_ptr< ::Body >
Body_ (const ::std::string& uri,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (const ::std::string& uri,
       ::xml_schema::error_handler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (const ::std::string& uri,
       ::xercesc::DOMErrorHandler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::error_handler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& id,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& id,
       ::xml_schema::error_handler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& id,
       ::xercesc::DOMErrorHandler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& is,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& is,
       ::xml_schema::error_handler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& is,
       ::xercesc::DOMErrorHandler& eh,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::Body >
Body_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::Body >
Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f = 0,
       const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const RSObject&);

void
operator<< (::xercesc::DOMElement&, const Sim&);

// Serialize to std::ostream.
//

void
Sim_ (::std::ostream& os,
      const ::Sim& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
Sim_ (::std::ostream& os,
      const ::Sim& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
Sim_ (::std::ostream& os,
      const ::Sim& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
Sim_ (::xercesc::XMLFormatTarget& ft,
      const ::Sim& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
Sim_ (::xercesc::XMLFormatTarget& ft,
      const ::Sim& x, 
      ::xml_schema::error_handler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

void
Sim_ (::xercesc::XMLFormatTarget& ft,
      const ::Sim& x, 
      ::xercesc::DOMErrorHandler& eh,
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      const ::std::string& e = "UTF-8",
      ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
Sim_ (::xercesc::DOMDocument& d,
      const ::Sim& x,
      ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Sim_ (const ::Sim& x, 
      const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
      ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const World&);

// Serialize to std::ostream.
//

void
World_ (::std::ostream& os,
        const ::World& x, 
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::flags f = 0);

void
World_ (::std::ostream& os,
        const ::World& x, 
        ::xml_schema::error_handler& eh,
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::flags f = 0);

void
World_ (::std::ostream& os,
        const ::World& x, 
        ::xercesc::DOMErrorHandler& eh,
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
World_ (::xercesc::XMLFormatTarget& ft,
        const ::World& x, 
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::flags f = 0);

void
World_ (::xercesc::XMLFormatTarget& ft,
        const ::World& x, 
        ::xml_schema::error_handler& eh,
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::flags f = 0);

void
World_ (::xercesc::XMLFormatTarget& ft,
        const ::World& x, 
        ::xercesc::DOMErrorHandler& eh,
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        const ::std::string& e = "UTF-8",
        ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
World_ (::xercesc::DOMDocument& d,
        const ::World& x,
        ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
World_ (const ::World& x, 
        const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
        ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const GeomObject&);

void
operator<< (::xercesc::DOMElement&, const SpaceBase&);

void
operator<< (::xercesc::DOMElement&, const SimpleSpace&);

void
operator<< (::xercesc::DOMElement&, const Body&);

// Serialize to std::ostream.
//

void
Body_ (::std::ostream& os,
       const ::Body& x, 
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       const ::std::string& e = "UTF-8",
       ::xml_schema::flags f = 0);

void
Body_ (::std::ostream& os,
       const ::Body& x, 
       ::xml_schema::error_handler& eh,
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       const ::std::string& e = "UTF-8",
       ::xml_schema::flags f = 0);

void
Body_ (::std::ostream& os,
       const ::Body& x, 
       ::xercesc::DOMErrorHandler& eh,
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       const ::std::string& e = "UTF-8",
       ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
Body_ (::xercesc::XMLFormatTarget& ft,
       const ::Body& x, 
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       const ::std::string& e = "UTF-8",
       ::xml_schema::flags f = 0);

void
Body_ (::xercesc::XMLFormatTarget& ft,
       const ::Body& x, 
       ::xml_schema::error_handler& eh,
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       const ::std::string& e = "UTF-8",
       ::xml_schema::flags f = 0);

void
Body_ (::xercesc::XMLFormatTarget& ft,
       const ::Body& x, 
       ::xercesc::DOMErrorHandler& eh,
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       const ::std::string& e = "UTF-8",
       ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
Body_ (::xercesc::DOMDocument& d,
       const ::Body& x,
       ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Body_ (const ::Body& x, 
       const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
       ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const Mass&);

void
operator<< (::xercesc::DOMElement&, const BoxTotalMass&);

void
operator<< (::xercesc::DOMElement&, const Joint&);

void
operator<< (::xercesc::DOMElement&, const HingeJoint&);

void
operator<< (::xercesc::DOMElement&, const GeomBox&);

void
operator<< (::xercesc::DOMElement&, const GeomCylinder&);

void
operator<< (::xercesc::DOMElement&, const GeomCapsule&);

void
operator<< (::xercesc::DOMElement&, const GeomSphere&);

void
operator<< (::xercesc::DOMElement&, const GeomPlane&);

void
operator<< (::xercesc::DOMElement&, const Rotation&);

void
operator<< (::xercesc::DOMElement&, const Vector&);

void
operator<< (::xercesc::DOMElement&, const Quaternion&);

void
operator<< (::xercesc::DOMElement&, const Foo&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // ODE_SCHEMA_HXX
