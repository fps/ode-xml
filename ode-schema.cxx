// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ode-schema.hxx"

// RSObject
// 

const RSObject::Name_optional& RSObject::
Name () const
{
  return this->Name_;
}

RSObject::Name_optional& RSObject::
Name ()
{
  return this->Name_;
}

void RSObject::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void RSObject::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void RSObject::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// Sim
// 

const Sim::World_sequence& Sim::
World () const
{
  return this->World_;
}

Sim::World_sequence& Sim::
World ()
{
  return this->World_;
}

void Sim::
World (const World_sequence& s)
{
  this->World_ = s;
}

const Sim::Space_sequence& Sim::
Space () const
{
  return this->Space_;
}

Sim::Space_sequence& Sim::
Space ()
{
  return this->Space_;
}

void Sim::
Space (const Space_sequence& s)
{
  this->Space_ = s;
}

const Sim::Body_sequence& Sim::
Body () const
{
  return this->Body_;
}

Sim::Body_sequence& Sim::
Body ()
{
  return this->Body_;
}

void Sim::
Body (const Body_sequence& s)
{
  this->Body_ = s;
}

const Sim::Geom_sequence& Sim::
Geom () const
{
  return this->Geom_;
}

Sim::Geom_sequence& Sim::
Geom ()
{
  return this->Geom_;
}

void Sim::
Geom (const Geom_sequence& s)
{
  this->Geom_ = s;
}


// World
// 

const World::AutoDisableAngularThreshold_optional& World::
AutoDisableAngularThreshold () const
{
  return this->AutoDisableAngularThreshold_;
}

World::AutoDisableAngularThreshold_optional& World::
AutoDisableAngularThreshold ()
{
  return this->AutoDisableAngularThreshold_;
}

void World::
AutoDisableAngularThreshold (const AutoDisableAngularThreshold_type& x)
{
  this->AutoDisableAngularThreshold_.set (x);
}

void World::
AutoDisableAngularThreshold (const AutoDisableAngularThreshold_optional& x)
{
  this->AutoDisableAngularThreshold_ = x;
}

const World::AutoDisableFlag_optional& World::
AutoDisableFlag () const
{
  return this->AutoDisableFlag_;
}

World::AutoDisableFlag_optional& World::
AutoDisableFlag ()
{
  return this->AutoDisableFlag_;
}

void World::
AutoDisableFlag (const AutoDisableFlag_type& x)
{
  this->AutoDisableFlag_.set (x);
}

void World::
AutoDisableFlag (const AutoDisableFlag_optional& x)
{
  this->AutoDisableFlag_ = x;
}

const World::AutoDisableSteps_optional& World::
AutoDisableSteps () const
{
  return this->AutoDisableSteps_;
}

World::AutoDisableSteps_optional& World::
AutoDisableSteps ()
{
  return this->AutoDisableSteps_;
}

void World::
AutoDisableSteps (const AutoDisableSteps_type& x)
{
  this->AutoDisableSteps_.set (x);
}

void World::
AutoDisableSteps (const AutoDisableSteps_optional& x)
{
  this->AutoDisableSteps_ = x;
}

const World::AutoDisableTime_optional& World::
AutoDisableTime () const
{
  return this->AutoDisableTime_;
}

World::AutoDisableTime_optional& World::
AutoDisableTime ()
{
  return this->AutoDisableTime_;
}

void World::
AutoDisableTime (const AutoDisableTime_type& x)
{
  this->AutoDisableTime_.set (x);
}

void World::
AutoDisableTime (const AutoDisableTime_optional& x)
{
  this->AutoDisableTime_ = x;
}

const World::CFM_optional& World::
CFM () const
{
  return this->CFM_;
}

World::CFM_optional& World::
CFM ()
{
  return this->CFM_;
}

void World::
CFM (const CFM_type& x)
{
  this->CFM_.set (x);
}

void World::
CFM (const CFM_optional& x)
{
  this->CFM_ = x;
}

const World::ContactMaxCorrectingVel_optional& World::
ContactMaxCorrectingVel () const
{
  return this->ContactMaxCorrectingVel_;
}

World::ContactMaxCorrectingVel_optional& World::
ContactMaxCorrectingVel ()
{
  return this->ContactMaxCorrectingVel_;
}

void World::
ContactMaxCorrectingVel (const ContactMaxCorrectingVel_type& x)
{
  this->ContactMaxCorrectingVel_.set (x);
}

void World::
ContactMaxCorrectingVel (const ContactMaxCorrectingVel_optional& x)
{
  this->ContactMaxCorrectingVel_ = x;
}

const World::ContactSurfaceLayer_optional& World::
ContactSurfaceLayer () const
{
  return this->ContactSurfaceLayer_;
}

World::ContactSurfaceLayer_optional& World::
ContactSurfaceLayer ()
{
  return this->ContactSurfaceLayer_;
}

void World::
ContactSurfaceLayer (const ContactSurfaceLayer_type& x)
{
  this->ContactSurfaceLayer_.set (x);
}

void World::
ContactSurfaceLayer (const ContactSurfaceLayer_optional& x)
{
  this->ContactSurfaceLayer_ = x;
}

const World::ERP_optional& World::
ERP () const
{
  return this->ERP_;
}

World::ERP_optional& World::
ERP ()
{
  return this->ERP_;
}

void World::
ERP (const ERP_type& x)
{
  this->ERP_.set (x);
}

void World::
ERP (const ERP_optional& x)
{
  this->ERP_ = x;
}

const World::Gravity_optional& World::
Gravity () const
{
  return this->Gravity_;
}

World::Gravity_optional& World::
Gravity ()
{
  return this->Gravity_;
}

void World::
Gravity (const Gravity_type& x)
{
  this->Gravity_.set (x);
}

void World::
Gravity (const Gravity_optional& x)
{
  this->Gravity_ = x;
}

void World::
Gravity (::std::auto_ptr< Gravity_type > x)
{
  this->Gravity_.set (x);
}

const World::QuickStepNumIterations_optional& World::
QuickStepNumIterations () const
{
  return this->QuickStepNumIterations_;
}

World::QuickStepNumIterations_optional& World::
QuickStepNumIterations ()
{
  return this->QuickStepNumIterations_;
}

void World::
QuickStepNumIterations (const QuickStepNumIterations_type& x)
{
  this->QuickStepNumIterations_.set (x);
}

void World::
QuickStepNumIterations (const QuickStepNumIterations_optional& x)
{
  this->QuickStepNumIterations_ = x;
}

const World::Body_sequence& World::
Body () const
{
  return this->Body_;
}

World::Body_sequence& World::
Body ()
{
  return this->Body_;
}

void World::
Body (const Body_sequence& s)
{
  this->Body_ = s;
}


// GeomObject
// 

const GeomObject::Enable_optional& GeomObject::
Enable () const
{
  return this->Enable_;
}

GeomObject::Enable_optional& GeomObject::
Enable ()
{
  return this->Enable_;
}

void GeomObject::
Enable (const Enable_type& x)
{
  this->Enable_.set (x);
}

void GeomObject::
Enable (const Enable_optional& x)
{
  this->Enable_ = x;
}

const GeomObject::CategoryBits_optional& GeomObject::
CategoryBits () const
{
  return this->CategoryBits_;
}

GeomObject::CategoryBits_optional& GeomObject::
CategoryBits ()
{
  return this->CategoryBits_;
}

void GeomObject::
CategoryBits (const CategoryBits_type& x)
{
  this->CategoryBits_.set (x);
}

void GeomObject::
CategoryBits (const CategoryBits_optional& x)
{
  this->CategoryBits_ = x;
}

const GeomObject::CollideBits_optional& GeomObject::
CollideBits () const
{
  return this->CollideBits_;
}

GeomObject::CollideBits_optional& GeomObject::
CollideBits ()
{
  return this->CollideBits_;
}

void GeomObject::
CollideBits (const CollideBits_type& x)
{
  this->CollideBits_.set (x);
}

void GeomObject::
CollideBits (const CollideBits_optional& x)
{
  this->CollideBits_ = x;
}

const GeomObject::Position_optional& GeomObject::
Position () const
{
  return this->Position_;
}

GeomObject::Position_optional& GeomObject::
Position ()
{
  return this->Position_;
}

void GeomObject::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void GeomObject::
Position (const Position_optional& x)
{
  this->Position_ = x;
}

void GeomObject::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const GeomObject::Quaternion_optional& GeomObject::
Quaternion () const
{
  return this->Quaternion_;
}

GeomObject::Quaternion_optional& GeomObject::
Quaternion ()
{
  return this->Quaternion_;
}

void GeomObject::
Quaternion (const Quaternion_type& x)
{
  this->Quaternion_.set (x);
}

void GeomObject::
Quaternion (const Quaternion_optional& x)
{
  this->Quaternion_ = x;
}

void GeomObject::
Quaternion (::std::auto_ptr< Quaternion_type > x)
{
  this->Quaternion_.set (x);
}

const GeomObject::Rotation_optional& GeomObject::
Rotation () const
{
  return this->Rotation_;
}

GeomObject::Rotation_optional& GeomObject::
Rotation ()
{
  return this->Rotation_;
}

void GeomObject::
Rotation (const Rotation_type& x)
{
  this->Rotation_.set (x);
}

void GeomObject::
Rotation (const Rotation_optional& x)
{
  this->Rotation_ = x;
}

void GeomObject::
Rotation (::std::auto_ptr< Rotation_type > x)
{
  this->Rotation_.set (x);
}


// SpaceBase
// 

const SpaceBase::Geom_sequence& SpaceBase::
Geom () const
{
  return this->Geom_;
}

SpaceBase::Geom_sequence& SpaceBase::
Geom ()
{
  return this->Geom_;
}

void SpaceBase::
Geom (const Geom_sequence& s)
{
  this->Geom_ = s;
}


// SimpleSpace
// 


// Body
// 

const Body::Space_optional& Body::
Space () const
{
  return this->Space_;
}

Body::Space_optional& Body::
Space ()
{
  return this->Space_;
}

void Body::
Space (const Space_type& x)
{
  this->Space_.set (x);
}

void Body::
Space (const Space_optional& x)
{
  this->Space_ = x;
}

void Body::
Space (::std::auto_ptr< Space_type > x)
{
  this->Space_.set (x);
}

const Body::World_optional& Body::
World () const
{
  return this->World_;
}

Body::World_optional& Body::
World ()
{
  return this->World_;
}

void Body::
World (const World_type& x)
{
  this->World_.set (x);
}

void Body::
World (const World_optional& x)
{
  this->World_ = x;
}

void Body::
World (::std::auto_ptr< World_type > x)
{
  this->World_.set (x);
}

const Body::Enabled_optional& Body::
Enabled () const
{
  return this->Enabled_;
}

Body::Enabled_optional& Body::
Enabled ()
{
  return this->Enabled_;
}

void Body::
Enabled (const Enabled_type& x)
{
  this->Enabled_.set (x);
}

void Body::
Enabled (const Enabled_optional& x)
{
  this->Enabled_ = x;
}

const Body::AngularVel_optional& Body::
AngularVel () const
{
  return this->AngularVel_;
}

Body::AngularVel_optional& Body::
AngularVel ()
{
  return this->AngularVel_;
}

void Body::
AngularVel (const AngularVel_type& x)
{
  this->AngularVel_.set (x);
}

void Body::
AngularVel (const AngularVel_optional& x)
{
  this->AngularVel_ = x;
}

void Body::
AngularVel (::std::auto_ptr< AngularVel_type > x)
{
  this->AngularVel_.set (x);
}

const Body::FiniteRotationAxis_optional& Body::
FiniteRotationAxis () const
{
  return this->FiniteRotationAxis_;
}

Body::FiniteRotationAxis_optional& Body::
FiniteRotationAxis ()
{
  return this->FiniteRotationAxis_;
}

void Body::
FiniteRotationAxis (const FiniteRotationAxis_type& x)
{
  this->FiniteRotationAxis_.set (x);
}

void Body::
FiniteRotationAxis (const FiniteRotationAxis_optional& x)
{
  this->FiniteRotationAxis_ = x;
}

void Body::
FiniteRotationAxis (::std::auto_ptr< FiniteRotationAxis_type > x)
{
  this->FiniteRotationAxis_.set (x);
}

const Body::FiniteRotationMode_optional& Body::
FiniteRotationMode () const
{
  return this->FiniteRotationMode_;
}

Body::FiniteRotationMode_optional& Body::
FiniteRotationMode ()
{
  return this->FiniteRotationMode_;
}

void Body::
FiniteRotationMode (const FiniteRotationMode_type& x)
{
  this->FiniteRotationMode_.set (x);
}

void Body::
FiniteRotationMode (const FiniteRotationMode_optional& x)
{
  this->FiniteRotationMode_ = x;
}

const Body::Force_optional& Body::
Force () const
{
  return this->Force_;
}

Body::Force_optional& Body::
Force ()
{
  return this->Force_;
}

void Body::
Force (const Force_type& x)
{
  this->Force_.set (x);
}

void Body::
Force (const Force_optional& x)
{
  this->Force_ = x;
}

void Body::
Force (::std::auto_ptr< Force_type > x)
{
  this->Force_.set (x);
}

const Body::GravityMode_optional& Body::
GravityMode () const
{
  return this->GravityMode_;
}

Body::GravityMode_optional& Body::
GravityMode ()
{
  return this->GravityMode_;
}

void Body::
GravityMode (const GravityMode_type& x)
{
  this->GravityMode_.set (x);
}

void Body::
GravityMode (const GravityMode_optional& x)
{
  this->GravityMode_ = x;
}

const Body::LinearVel_optional& Body::
LinearVel () const
{
  return this->LinearVel_;
}

Body::LinearVel_optional& Body::
LinearVel ()
{
  return this->LinearVel_;
}

void Body::
LinearVel (const LinearVel_type& x)
{
  this->LinearVel_.set (x);
}

void Body::
LinearVel (const LinearVel_optional& x)
{
  this->LinearVel_ = x;
}

void Body::
LinearVel (::std::auto_ptr< LinearVel_type > x)
{
  this->LinearVel_.set (x);
}

const Body::Mass_optional& Body::
Mass () const
{
  return this->Mass_;
}

Body::Mass_optional& Body::
Mass ()
{
  return this->Mass_;
}

void Body::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}

void Body::
Mass (const Mass_optional& x)
{
  this->Mass_ = x;
}

void Body::
Mass (::std::auto_ptr< Mass_type > x)
{
  this->Mass_.set (x);
}

const Body::Torque_optional& Body::
Torque () const
{
  return this->Torque_;
}

Body::Torque_optional& Body::
Torque ()
{
  return this->Torque_;
}

void Body::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void Body::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}

void Body::
Torque (::std::auto_ptr< Torque_type > x)
{
  this->Torque_.set (x);
}

const Body::Position_optional& Body::
Position () const
{
  return this->Position_;
}

Body::Position_optional& Body::
Position ()
{
  return this->Position_;
}

void Body::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void Body::
Position (const Position_optional& x)
{
  this->Position_ = x;
}

void Body::
Position (::std::auto_ptr< Position_type > x)
{
  this->Position_.set (x);
}

const Body::Quaternion_optional& Body::
Quaternion () const
{
  return this->Quaternion_;
}

Body::Quaternion_optional& Body::
Quaternion ()
{
  return this->Quaternion_;
}

void Body::
Quaternion (const Quaternion_type& x)
{
  this->Quaternion_.set (x);
}

void Body::
Quaternion (const Quaternion_optional& x)
{
  this->Quaternion_ = x;
}

void Body::
Quaternion (::std::auto_ptr< Quaternion_type > x)
{
  this->Quaternion_.set (x);
}

const Body::Rotation_optional& Body::
Rotation () const
{
  return this->Rotation_;
}

Body::Rotation_optional& Body::
Rotation ()
{
  return this->Rotation_;
}

void Body::
Rotation (const Rotation_type& x)
{
  this->Rotation_.set (x);
}

void Body::
Rotation (const Rotation_optional& x)
{
  this->Rotation_ = x;
}

void Body::
Rotation (::std::auto_ptr< Rotation_type > x)
{
  this->Rotation_.set (x);
}


// Mass
// 


// BoxTotalMass
// 

const BoxTotalMass::TotalMass_type& BoxTotalMass::
TotalMass () const
{
  return this->TotalMass_.get ();
}

BoxTotalMass::TotalMass_type& BoxTotalMass::
TotalMass ()
{
  return this->TotalMass_.get ();
}

void BoxTotalMass::
TotalMass (const TotalMass_type& x)
{
  this->TotalMass_.set (x);
}

const BoxTotalMass::LX_type& BoxTotalMass::
LX () const
{
  return this->LX_.get ();
}

BoxTotalMass::LX_type& BoxTotalMass::
LX ()
{
  return this->LX_.get ();
}

void BoxTotalMass::
LX (const LX_type& x)
{
  this->LX_.set (x);
}

const BoxTotalMass::LY_type& BoxTotalMass::
LY () const
{
  return this->LY_.get ();
}

BoxTotalMass::LY_type& BoxTotalMass::
LY ()
{
  return this->LY_.get ();
}

void BoxTotalMass::
LY (const LY_type& x)
{
  this->LY_.set (x);
}

const BoxTotalMass::LZ_type& BoxTotalMass::
LZ () const
{
  return this->LZ_.get ();
}

BoxTotalMass::LZ_type& BoxTotalMass::
LZ ()
{
  return this->LZ_.get ();
}

void BoxTotalMass::
LZ (const LZ_type& x)
{
  this->LZ_.set (x);
}


// Joint
// 

const Joint::Feedback_optional& Joint::
Feedback () const
{
  return this->Feedback_;
}

Joint::Feedback_optional& Joint::
Feedback ()
{
  return this->Feedback_;
}

void Joint::
Feedback (const Feedback_type& x)
{
  this->Feedback_.set (x);
}

void Joint::
Feedback (const Feedback_optional& x)
{
  this->Feedback_ = x;
}

const Joint::Body1_optional& Joint::
Body1 () const
{
  return this->Body1_;
}

Joint::Body1_optional& Joint::
Body1 ()
{
  return this->Body1_;
}

void Joint::
Body1 (const Body1_type& x)
{
  this->Body1_.set (x);
}

void Joint::
Body1 (const Body1_optional& x)
{
  this->Body1_ = x;
}

void Joint::
Body1 (::std::auto_ptr< Body1_type > x)
{
  this->Body1_.set (x);
}

const Joint::Body2_optional& Joint::
Body2 () const
{
  return this->Body2_;
}

Joint::Body2_optional& Joint::
Body2 ()
{
  return this->Body2_;
}

void Joint::
Body2 (const Body2_type& x)
{
  this->Body2_.set (x);
}

void Joint::
Body2 (const Body2_optional& x)
{
  this->Body2_ = x;
}

void Joint::
Body2 (::std::auto_ptr< Body2_type > x)
{
  this->Body2_.set (x);
}


// HingeJoint
// 

const HingeJoint::Anchor_optional& HingeJoint::
Anchor () const
{
  return this->Anchor_;
}

HingeJoint::Anchor_optional& HingeJoint::
Anchor ()
{
  return this->Anchor_;
}

void HingeJoint::
Anchor (const Anchor_type& x)
{
  this->Anchor_.set (x);
}

void HingeJoint::
Anchor (const Anchor_optional& x)
{
  this->Anchor_ = x;
}

void HingeJoint::
Anchor (::std::auto_ptr< Anchor_type > x)
{
  this->Anchor_.set (x);
}

const HingeJoint::Axis_optional& HingeJoint::
Axis () const
{
  return this->Axis_;
}

HingeJoint::Axis_optional& HingeJoint::
Axis ()
{
  return this->Axis_;
}

void HingeJoint::
Axis (const Axis_type& x)
{
  this->Axis_.set (x);
}

void HingeJoint::
Axis (const Axis_optional& x)
{
  this->Axis_ = x;
}

void HingeJoint::
Axis (::std::auto_ptr< Axis_type > x)
{
  this->Axis_.set (x);
}

const HingeJoint::Torque_optional& HingeJoint::
Torque () const
{
  return this->Torque_;
}

HingeJoint::Torque_optional& HingeJoint::
Torque ()
{
  return this->Torque_;
}

void HingeJoint::
Torque (const Torque_type& x)
{
  this->Torque_.set (x);
}

void HingeJoint::
Torque (const Torque_optional& x)
{
  this->Torque_ = x;
}


// GeomBox
// 

const GeomBox::Lengths_optional& GeomBox::
Lengths () const
{
  return this->Lengths_;
}

GeomBox::Lengths_optional& GeomBox::
Lengths ()
{
  return this->Lengths_;
}

void GeomBox::
Lengths (const Lengths_type& x)
{
  this->Lengths_.set (x);
}

void GeomBox::
Lengths (const Lengths_optional& x)
{
  this->Lengths_ = x;
}

void GeomBox::
Lengths (::std::auto_ptr< Lengths_type > x)
{
  this->Lengths_.set (x);
}


// GeomCylinder
// 

const GeomCylinder::Length_optional& GeomCylinder::
Length () const
{
  return this->Length_;
}

GeomCylinder::Length_optional& GeomCylinder::
Length ()
{
  return this->Length_;
}

void GeomCylinder::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void GeomCylinder::
Length (const Length_optional& x)
{
  this->Length_ = x;
}

const GeomCylinder::Radius_optional& GeomCylinder::
Radius () const
{
  return this->Radius_;
}

GeomCylinder::Radius_optional& GeomCylinder::
Radius ()
{
  return this->Radius_;
}

void GeomCylinder::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomCylinder::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomCapsule
// 

const GeomCapsule::Length_optional& GeomCapsule::
Length () const
{
  return this->Length_;
}

GeomCapsule::Length_optional& GeomCapsule::
Length ()
{
  return this->Length_;
}

void GeomCapsule::
Length (const Length_type& x)
{
  this->Length_.set (x);
}

void GeomCapsule::
Length (const Length_optional& x)
{
  this->Length_ = x;
}

const GeomCapsule::Radius_optional& GeomCapsule::
Radius () const
{
  return this->Radius_;
}

GeomCapsule::Radius_optional& GeomCapsule::
Radius ()
{
  return this->Radius_;
}

void GeomCapsule::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomCapsule::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomSphere
// 

const GeomSphere::Radius_optional& GeomSphere::
Radius () const
{
  return this->Radius_;
}

GeomSphere::Radius_optional& GeomSphere::
Radius ()
{
  return this->Radius_;
}

void GeomSphere::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

void GeomSphere::
Radius (const Radius_optional& x)
{
  this->Radius_ = x;
}


// GeomPlane
// 

const GeomPlane::Space_optional& GeomPlane::
Space () const
{
  return this->Space_;
}

GeomPlane::Space_optional& GeomPlane::
Space ()
{
  return this->Space_;
}

void GeomPlane::
Space (const Space_type& x)
{
  this->Space_.set (x);
}

void GeomPlane::
Space (const Space_optional& x)
{
  this->Space_ = x;
}

void GeomPlane::
Space (::std::auto_ptr< Space_type > x)
{
  this->Space_.set (x);
}

const GeomPlane::Body_optional& GeomPlane::
Body () const
{
  return this->Body_;
}

GeomPlane::Body_optional& GeomPlane::
Body ()
{
  return this->Body_;
}

void GeomPlane::
Body (const Body_type& x)
{
  this->Body_.set (x);
}

void GeomPlane::
Body (const Body_optional& x)
{
  this->Body_ = x;
}

void GeomPlane::
Body (::std::auto_ptr< Body_type > x)
{
  this->Body_.set (x);
}

const GeomPlane::Enabled_optional& GeomPlane::
Enabled () const
{
  return this->Enabled_;
}

GeomPlane::Enabled_optional& GeomPlane::
Enabled ()
{
  return this->Enabled_;
}

void GeomPlane::
Enabled (const Enabled_type& x)
{
  this->Enabled_.set (x);
}

void GeomPlane::
Enabled (const Enabled_optional& x)
{
  this->Enabled_ = x;
}


// Rotation
// 

const Rotation::Column1_type& Rotation::
Column1 () const
{
  return this->Column1_.get ();
}

Rotation::Column1_type& Rotation::
Column1 ()
{
  return this->Column1_.get ();
}

void Rotation::
Column1 (const Column1_type& x)
{
  this->Column1_.set (x);
}

void Rotation::
Column1 (::std::auto_ptr< Column1_type > x)
{
  this->Column1_.set (x);
}

const Rotation::Column2_type& Rotation::
Column2 () const
{
  return this->Column2_.get ();
}

Rotation::Column2_type& Rotation::
Column2 ()
{
  return this->Column2_.get ();
}

void Rotation::
Column2 (const Column2_type& x)
{
  this->Column2_.set (x);
}

void Rotation::
Column2 (::std::auto_ptr< Column2_type > x)
{
  this->Column2_.set (x);
}

const Rotation::Column3_type& Rotation::
Column3 () const
{
  return this->Column3_.get ();
}

Rotation::Column3_type& Rotation::
Column3 ()
{
  return this->Column3_.get ();
}

void Rotation::
Column3 (const Column3_type& x)
{
  this->Column3_.set (x);
}

void Rotation::
Column3 (::std::auto_ptr< Column3_type > x)
{
  this->Column3_.set (x);
}


// Vector
// 

const Vector::X_optional& Vector::
X () const
{
  return this->X_;
}

Vector::X_optional& Vector::
X ()
{
  return this->X_;
}

void Vector::
X (const X_type& x)
{
  this->X_.set (x);
}

void Vector::
X (const X_optional& x)
{
  this->X_ = x;
}

const Vector::Y_optional& Vector::
Y () const
{
  return this->Y_;
}

Vector::Y_optional& Vector::
Y ()
{
  return this->Y_;
}

void Vector::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void Vector::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

const Vector::Z_optional& Vector::
Z () const
{
  return this->Z_;
}

Vector::Z_optional& Vector::
Z ()
{
  return this->Z_;
}

void Vector::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void Vector::
Z (const Z_optional& x)
{
  this->Z_ = x;
}


// Quaternion
// 

const Quaternion::W_optional& Quaternion::
W () const
{
  return this->W_;
}

Quaternion::W_optional& Quaternion::
W ()
{
  return this->W_;
}

void Quaternion::
W (const W_type& x)
{
  this->W_.set (x);
}

void Quaternion::
W (const W_optional& x)
{
  this->W_ = x;
}

const Quaternion::I_optional& Quaternion::
I () const
{
  return this->I_;
}

Quaternion::I_optional& Quaternion::
I ()
{
  return this->I_;
}

void Quaternion::
I (const I_type& x)
{
  this->I_.set (x);
}

void Quaternion::
I (const I_optional& x)
{
  this->I_ = x;
}

const Quaternion::J_optional& Quaternion::
J () const
{
  return this->J_;
}

Quaternion::J_optional& Quaternion::
J ()
{
  return this->J_;
}

void Quaternion::
J (const J_type& x)
{
  this->J_.set (x);
}

void Quaternion::
J (const J_optional& x)
{
  this->J_ = x;
}

const Quaternion::K_optional& Quaternion::
K () const
{
  return this->K_;
}

Quaternion::K_optional& Quaternion::
K ()
{
  return this->K_;
}

void Quaternion::
K (const K_type& x)
{
  this->K_.set (x);
}

void Quaternion::
K (const K_optional& x)
{
  this->K_ = x;
}


// Foo
// 


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// RSObject
//

RSObject::
RSObject ()
: ::xml_schema::type (),
  Name_ (::xml_schema::flags (), this)
{
}

RSObject::
RSObject (const RSObject& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

RSObject::
RSObject (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RSObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Name_type > r (
        Name_traits::create (i, f, this));

      if (!this->Name_)
      {
        this->Name_.set (r);
        continue;
      }
    }

    break;
  }
}

RSObject* RSObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RSObject (*this, f, c);
}

RSObject::
~RSObject ()
{
}

// Sim
//

Sim::
Sim ()
: ::RSObject (),
  World_ (::xml_schema::flags (), this),
  Space_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this),
  Geom_ (::xml_schema::flags (), this)
{
}

Sim::
Sim (const Sim& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (x, f, c),
  World_ (x.World_, f, this),
  Space_ (x.Space_, f, this),
  Body_ (x.Body_, f, this),
  Geom_ (x.Geom_, f, this)
{
}

Sim::
Sim (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  World_ (f, this),
  Space_ (f, this),
  Body_ (f, this),
  Geom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Sim::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // World
    //
    if (n.name () == "World" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< World_type > r (
        World_traits::create (i, f, this));

      this->World_.push_back (r);
      continue;
    }

    // Space
    //
    if (n.name () == "Space" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Space_type > r (
        Space_traits::create (i, f, this));

      this->Space_.push_back (r);
      continue;
    }

    // Body
    //
    if (n.name () == "Body" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Body_type > r (
        Body_traits::create (i, f, this));

      this->Body_.push_back (r);
      continue;
    }

    // Geom
    //
    if (n.name () == "Geom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Geom_type > r (
        Geom_traits::create (i, f, this));

      this->Geom_.push_back (r);
      continue;
    }

    break;
  }
}

Sim* Sim::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Sim (*this, f, c);
}

Sim::
~Sim ()
{
}

// World
//

World::
World ()
: ::RSObject (),
  AutoDisableAngularThreshold_ (::xml_schema::flags (), this),
  AutoDisableFlag_ (::xml_schema::flags (), this),
  AutoDisableSteps_ (::xml_schema::flags (), this),
  AutoDisableTime_ (::xml_schema::flags (), this),
  CFM_ (::xml_schema::flags (), this),
  ContactMaxCorrectingVel_ (::xml_schema::flags (), this),
  ContactSurfaceLayer_ (::xml_schema::flags (), this),
  ERP_ (::xml_schema::flags (), this),
  Gravity_ (::xml_schema::flags (), this),
  QuickStepNumIterations_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this)
{
}

World::
World (const World& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (x, f, c),
  AutoDisableAngularThreshold_ (x.AutoDisableAngularThreshold_, f, this),
  AutoDisableFlag_ (x.AutoDisableFlag_, f, this),
  AutoDisableSteps_ (x.AutoDisableSteps_, f, this),
  AutoDisableTime_ (x.AutoDisableTime_, f, this),
  CFM_ (x.CFM_, f, this),
  ContactMaxCorrectingVel_ (x.ContactMaxCorrectingVel_, f, this),
  ContactSurfaceLayer_ (x.ContactSurfaceLayer_, f, this),
  ERP_ (x.ERP_, f, this),
  Gravity_ (x.Gravity_, f, this),
  QuickStepNumIterations_ (x.QuickStepNumIterations_, f, this),
  Body_ (x.Body_, f, this)
{
}

World::
World (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  AutoDisableAngularThreshold_ (f, this),
  AutoDisableFlag_ (f, this),
  AutoDisableSteps_ (f, this),
  AutoDisableTime_ (f, this),
  CFM_ (f, this),
  ContactMaxCorrectingVel_ (f, this),
  ContactSurfaceLayer_ (f, this),
  ERP_ (f, this),
  Gravity_ (f, this),
  QuickStepNumIterations_ (f, this),
  Body_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void World::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AutoDisableAngularThreshold
    //
    if (n.name () == "AutoDisableAngularThreshold" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableAngularThreshold_)
      {
        this->AutoDisableAngularThreshold_.set (AutoDisableAngularThreshold_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableFlag
    //
    if (n.name () == "AutoDisableFlag" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableFlag_)
      {
        this->AutoDisableFlag_.set (AutoDisableFlag_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableSteps
    //
    if (n.name () == "AutoDisableSteps" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableSteps_)
      {
        this->AutoDisableSteps_.set (AutoDisableSteps_traits::create (i, f, this));
        continue;
      }
    }

    // AutoDisableTime
    //
    if (n.name () == "AutoDisableTime" && n.namespace_ ().empty ())
    {
      if (!this->AutoDisableTime_)
      {
        this->AutoDisableTime_.set (AutoDisableTime_traits::create (i, f, this));
        continue;
      }
    }

    // CFM
    //
    if (n.name () == "CFM" && n.namespace_ ().empty ())
    {
      if (!this->CFM_)
      {
        this->CFM_.set (CFM_traits::create (i, f, this));
        continue;
      }
    }

    // ContactMaxCorrectingVel
    //
    if (n.name () == "ContactMaxCorrectingVel" && n.namespace_ ().empty ())
    {
      if (!this->ContactMaxCorrectingVel_)
      {
        this->ContactMaxCorrectingVel_.set (ContactMaxCorrectingVel_traits::create (i, f, this));
        continue;
      }
    }

    // ContactSurfaceLayer
    //
    if (n.name () == "ContactSurfaceLayer" && n.namespace_ ().empty ())
    {
      if (!this->ContactSurfaceLayer_)
      {
        this->ContactSurfaceLayer_.set (ContactSurfaceLayer_traits::create (i, f, this));
        continue;
      }
    }

    // ERP
    //
    if (n.name () == "ERP" && n.namespace_ ().empty ())
    {
      if (!this->ERP_)
      {
        this->ERP_.set (ERP_traits::create (i, f, this));
        continue;
      }
    }

    // Gravity
    //
    if (n.name () == "Gravity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Gravity_type > r (
        Gravity_traits::create (i, f, this));

      if (!this->Gravity_)
      {
        this->Gravity_.set (r);
        continue;
      }
    }

    // QuickStepNumIterations
    //
    if (n.name () == "QuickStepNumIterations" && n.namespace_ ().empty ())
    {
      if (!this->QuickStepNumIterations_)
      {
        this->QuickStepNumIterations_.set (QuickStepNumIterations_traits::create (i, f, this));
        continue;
      }
    }

    // Body
    //
    if (n.name () == "Body" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Body_type > r (
        Body_traits::create (i, f, this));

      this->Body_.push_back (r);
      continue;
    }

    break;
  }
}

World* World::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class World (*this, f, c);
}

World::
~World ()
{
}

// GeomObject
//

GeomObject::
GeomObject ()
: ::RSObject (),
  Enable_ (::xml_schema::flags (), this),
  CategoryBits_ (::xml_schema::flags (), this),
  CollideBits_ (::xml_schema::flags (), this),
  Position_ (::xml_schema::flags (), this),
  Quaternion_ (::xml_schema::flags (), this),
  Rotation_ (::xml_schema::flags (), this)
{
}

GeomObject::
GeomObject (const GeomObject& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Enable_ (x.Enable_, f, this),
  CategoryBits_ (x.CategoryBits_, f, this),
  CollideBits_ (x.CollideBits_, f, this),
  Position_ (x.Position_, f, this),
  Quaternion_ (x.Quaternion_, f, this),
  Rotation_ (x.Rotation_, f, this)
{
}

GeomObject::
GeomObject (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Enable_ (f, this),
  CategoryBits_ (f, this),
  CollideBits_ (f, this),
  Position_ (f, this),
  Quaternion_ (f, this),
  Rotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Enable
    //
    if (n.name () == "Enable" && n.namespace_ ().empty ())
    {
      if (!this->Enable_)
      {
        this->Enable_.set (Enable_traits::create (i, f, this));
        continue;
      }
    }

    // CategoryBits
    //
    if (n.name () == "CategoryBits" && n.namespace_ ().empty ())
    {
      if (!this->CategoryBits_)
      {
        this->CategoryBits_.set (CategoryBits_traits::create (i, f, this));
        continue;
      }
    }

    // CollideBits
    //
    if (n.name () == "CollideBits" && n.namespace_ ().empty ())
    {
      if (!this->CollideBits_)
      {
        this->CollideBits_.set (CollideBits_traits::create (i, f, this));
        continue;
      }
    }

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!this->Position_)
      {
        this->Position_.set (r);
        continue;
      }
    }

    // Quaternion
    //
    if (n.name () == "Quaternion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Quaternion_type > r (
        Quaternion_traits::create (i, f, this));

      if (!this->Quaternion_)
      {
        this->Quaternion_.set (r);
        continue;
      }
    }

    // Rotation
    //
    if (n.name () == "Rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Rotation_type > r (
        Rotation_traits::create (i, f, this));

      if (!this->Rotation_)
      {
        this->Rotation_.set (r);
        continue;
      }
    }

    break;
  }
}

GeomObject* GeomObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomObject (*this, f, c);
}

GeomObject::
~GeomObject ()
{
}

// SpaceBase
//

SpaceBase::
SpaceBase ()
: ::GeomObject (),
  Geom_ (::xml_schema::flags (), this)
{
}

SpaceBase::
SpaceBase (const SpaceBase& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Geom_ (x.Geom_, f, this)
{
}

SpaceBase::
SpaceBase (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Geom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void SpaceBase::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Geom
    //
    if (n.name () == "Geom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Geom_type > r (
        Geom_traits::create (i, f, this));

      this->Geom_.push_back (r);
      continue;
    }

    break;
  }
}

SpaceBase* SpaceBase::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SpaceBase (*this, f, c);
}

SpaceBase::
~SpaceBase ()
{
}

// SimpleSpace
//

SimpleSpace::
SimpleSpace ()
: ::SpaceBase ()
{
}

SimpleSpace::
SimpleSpace (const SimpleSpace& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SpaceBase (x, f, c)
{
}

SimpleSpace::
SimpleSpace (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SpaceBase (e, f, c)
{
}

SimpleSpace* SimpleSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SimpleSpace (*this, f, c);
}

SimpleSpace::
~SimpleSpace ()
{
}

// Body
//

Body::
Body ()
: ::RSObject (),
  Space_ (::xml_schema::flags (), this),
  World_ (::xml_schema::flags (), this),
  Enabled_ (::xml_schema::flags (), this),
  AngularVel_ (::xml_schema::flags (), this),
  FiniteRotationAxis_ (::xml_schema::flags (), this),
  FiniteRotationMode_ (::xml_schema::flags (), this),
  Force_ (::xml_schema::flags (), this),
  GravityMode_ (::xml_schema::flags (), this),
  LinearVel_ (::xml_schema::flags (), this),
  Mass_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this),
  Position_ (::xml_schema::flags (), this),
  Quaternion_ (::xml_schema::flags (), this),
  Rotation_ (::xml_schema::flags (), this)
{
}

Body::
Body (const Body& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Space_ (x.Space_, f, this),
  World_ (x.World_, f, this),
  Enabled_ (x.Enabled_, f, this),
  AngularVel_ (x.AngularVel_, f, this),
  FiniteRotationAxis_ (x.FiniteRotationAxis_, f, this),
  FiniteRotationMode_ (x.FiniteRotationMode_, f, this),
  Force_ (x.Force_, f, this),
  GravityMode_ (x.GravityMode_, f, this),
  LinearVel_ (x.LinearVel_, f, this),
  Mass_ (x.Mass_, f, this),
  Torque_ (x.Torque_, f, this),
  Position_ (x.Position_, f, this),
  Quaternion_ (x.Quaternion_, f, this),
  Rotation_ (x.Rotation_, f, this)
{
}

Body::
Body (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Space_ (f, this),
  World_ (f, this),
  Enabled_ (f, this),
  AngularVel_ (f, this),
  FiniteRotationAxis_ (f, this),
  FiniteRotationMode_ (f, this),
  Force_ (f, this),
  GravityMode_ (f, this),
  LinearVel_ (f, this),
  Mass_ (f, this),
  Torque_ (f, this),
  Position_ (f, this),
  Quaternion_ (f, this),
  Rotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Space
    //
    if (n.name () == "Space" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Space_type > r (
        Space_traits::create (i, f, this));

      if (!this->Space_)
      {
        this->Space_.set (r);
        continue;
      }
    }

    // World
    //
    if (n.name () == "World" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< World_type > r (
        World_traits::create (i, f, this));

      if (!this->World_)
      {
        this->World_.set (r);
        continue;
      }
    }

    // Enabled
    //
    if (n.name () == "Enabled" && n.namespace_ ().empty ())
    {
      if (!this->Enabled_)
      {
        this->Enabled_.set (Enabled_traits::create (i, f, this));
        continue;
      }
    }

    // AngularVel
    //
    if (n.name () == "AngularVel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AngularVel_type > r (
        AngularVel_traits::create (i, f, this));

      if (!this->AngularVel_)
      {
        this->AngularVel_.set (r);
        continue;
      }
    }

    // FiniteRotationAxis
    //
    if (n.name () == "FiniteRotationAxis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FiniteRotationAxis_type > r (
        FiniteRotationAxis_traits::create (i, f, this));

      if (!this->FiniteRotationAxis_)
      {
        this->FiniteRotationAxis_.set (r);
        continue;
      }
    }

    // FiniteRotationMode
    //
    if (n.name () == "FiniteRotationMode" && n.namespace_ ().empty ())
    {
      if (!this->FiniteRotationMode_)
      {
        this->FiniteRotationMode_.set (FiniteRotationMode_traits::create (i, f, this));
        continue;
      }
    }

    // Force
    //
    if (n.name () == "Force" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Force_type > r (
        Force_traits::create (i, f, this));

      if (!this->Force_)
      {
        this->Force_.set (r);
        continue;
      }
    }

    // GravityMode
    //
    if (n.name () == "GravityMode" && n.namespace_ ().empty ())
    {
      if (!this->GravityMode_)
      {
        this->GravityMode_.set (GravityMode_traits::create (i, f, this));
        continue;
      }
    }

    // LinearVel
    //
    if (n.name () == "LinearVel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LinearVel_type > r (
        LinearVel_traits::create (i, f, this));

      if (!this->LinearVel_)
      {
        this->LinearVel_.set (r);
        continue;
      }
    }

    // Mass
    //
    if (n.name () == "Mass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Mass_type > r (
        Mass_traits::create (i, f, this));

      if (!this->Mass_)
      {
        this->Mass_.set (r);
        continue;
      }
    }

    // Torque
    //
    if (n.name () == "Torque" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Torque_type > r (
        Torque_traits::create (i, f, this));

      if (!this->Torque_)
      {
        this->Torque_.set (r);
        continue;
      }
    }

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!this->Position_)
      {
        this->Position_.set (r);
        continue;
      }
    }

    // Quaternion
    //
    if (n.name () == "Quaternion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Quaternion_type > r (
        Quaternion_traits::create (i, f, this));

      if (!this->Quaternion_)
      {
        this->Quaternion_.set (r);
        continue;
      }
    }

    // Rotation
    //
    if (n.name () == "Rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Rotation_type > r (
        Rotation_traits::create (i, f, this));

      if (!this->Rotation_)
      {
        this->Rotation_.set (r);
        continue;
      }
    }

    break;
  }
}

Body* Body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Body (*this, f, c);
}

Body::
~Body ()
{
}

// Mass
//

Mass::
Mass ()
: ::RSObject ()
{
}

Mass::
Mass (const Mass& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (x, f, c)
{
}

Mass::
Mass (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::RSObject (e, f, c)
{
}

Mass* Mass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Mass (*this, f, c);
}

Mass::
~Mass ()
{
}

// BoxTotalMass
//

BoxTotalMass::
BoxTotalMass (const TotalMass_type& TotalMass,
              const LX_type& LX,
              const LY_type& LY,
              const LZ_type& LZ)
: ::Mass (),
  TotalMass_ (TotalMass, ::xml_schema::flags (), this),
  LX_ (LX, ::xml_schema::flags (), this),
  LY_ (LY, ::xml_schema::flags (), this),
  LZ_ (LZ, ::xml_schema::flags (), this)
{
}

BoxTotalMass::
BoxTotalMass (const BoxTotalMass& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Mass (x, f, c),
  TotalMass_ (x.TotalMass_, f, this),
  LX_ (x.LX_, f, this),
  LY_ (x.LY_, f, this),
  LZ_ (x.LZ_, f, this)
{
}

BoxTotalMass::
BoxTotalMass (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::Mass (e, f | ::xml_schema::flags::base, c),
  TotalMass_ (f, this),
  LX_ (f, this),
  LY_ (f, this),
  LZ_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void BoxTotalMass::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Mass::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TotalMass
    //
    if (n.name () == "TotalMass" && n.namespace_ ().empty ())
    {
      if (!TotalMass_.present ())
      {
        this->TotalMass_.set (TotalMass_traits::create (i, f, this));
        continue;
      }
    }

    // LX
    //
    if (n.name () == "LX" && n.namespace_ ().empty ())
    {
      if (!LX_.present ())
      {
        this->LX_.set (LX_traits::create (i, f, this));
        continue;
      }
    }

    // LY
    //
    if (n.name () == "LY" && n.namespace_ ().empty ())
    {
      if (!LY_.present ())
      {
        this->LY_.set (LY_traits::create (i, f, this));
        continue;
      }
    }

    // LZ
    //
    if (n.name () == "LZ" && n.namespace_ ().empty ())
    {
      if (!LZ_.present ())
      {
        this->LZ_.set (LZ_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!TotalMass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TotalMass",
      "");
  }

  if (!LX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LX",
      "");
  }

  if (!LY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LY",
      "");
  }

  if (!LZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LZ",
      "");
  }
}

BoxTotalMass* BoxTotalMass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BoxTotalMass (*this, f, c);
}

BoxTotalMass::
~BoxTotalMass ()
{
}

// Joint
//

Joint::
Joint ()
: ::RSObject (),
  Feedback_ (::xml_schema::flags (), this),
  Body1_ (::xml_schema::flags (), this),
  Body2_ (::xml_schema::flags (), this)
{
}

Joint::
Joint (const Joint& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Feedback_ (x.Feedback_, f, this),
  Body1_ (x.Body1_, f, this),
  Body2_ (x.Body2_, f, this)
{
}

Joint::
Joint (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Feedback_ (f, this),
  Body1_ (f, this),
  Body2_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Joint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Feedback
    //
    if (n.name () == "Feedback" && n.namespace_ ().empty ())
    {
      if (!this->Feedback_)
      {
        this->Feedback_.set (Feedback_traits::create (i, f, this));
        continue;
      }
    }

    // Body1
    //
    if (n.name () == "Body1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Body1_type > r (
        Body1_traits::create (i, f, this));

      if (!this->Body1_)
      {
        this->Body1_.set (r);
        continue;
      }
    }

    // Body2
    //
    if (n.name () == "Body2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Body2_type > r (
        Body2_traits::create (i, f, this));

      if (!this->Body2_)
      {
        this->Body2_.set (r);
        continue;
      }
    }

    break;
  }
}

Joint* Joint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Joint (*this, f, c);
}

Joint::
~Joint ()
{
}

// HingeJoint
//

HingeJoint::
HingeJoint ()
: ::Joint (),
  Anchor_ (::xml_schema::flags (), this),
  Axis_ (::xml_schema::flags (), this),
  Torque_ (::xml_schema::flags (), this)
{
}

HingeJoint::
HingeJoint (const HingeJoint& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Joint (x, f, c),
  Anchor_ (x.Anchor_, f, this),
  Axis_ (x.Axis_, f, this),
  Torque_ (x.Torque_, f, this)
{
}

HingeJoint::
HingeJoint (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::Joint (e, f | ::xml_schema::flags::base, c),
  Anchor_ (f, this),
  Axis_ (f, this),
  Torque_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void HingeJoint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::Joint::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      if (!this->Anchor_)
      {
        this->Anchor_.set (r);
        continue;
      }
    }

    // Axis
    //
    if (n.name () == "Axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Axis_type > r (
        Axis_traits::create (i, f, this));

      if (!this->Axis_)
      {
        this->Axis_.set (r);
        continue;
      }
    }

    // Torque
    //
    if (n.name () == "Torque" && n.namespace_ ().empty ())
    {
      if (!this->Torque_)
      {
        this->Torque_.set (Torque_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

HingeJoint* HingeJoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HingeJoint (*this, f, c);
}

HingeJoint::
~HingeJoint ()
{
}

// GeomBox
//

GeomBox::
GeomBox ()
: ::GeomObject (),
  Lengths_ (::xml_schema::flags (), this)
{
}

GeomBox::
GeomBox (const GeomBox& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Lengths_ (x.Lengths_, f, this)
{
}

GeomBox::
GeomBox (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Lengths_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomBox::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Lengths
    //
    if (n.name () == "Lengths" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Lengths_type > r (
        Lengths_traits::create (i, f, this));

      if (!this->Lengths_)
      {
        this->Lengths_.set (r);
        continue;
      }
    }

    break;
  }
}

GeomBox* GeomBox::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomBox (*this, f, c);
}

GeomBox::
~GeomBox ()
{
}

// GeomCylinder
//

GeomCylinder::
GeomCylinder ()
: ::GeomObject (),
  Length_ (::xml_schema::flags (), this),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomCylinder::
GeomCylinder (const GeomCylinder& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Length_ (x.Length_, f, this),
  Radius_ (x.Radius_, f, this)
{
}

GeomCylinder::
GeomCylinder (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Length_ (f, this),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomCylinder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Length
    //
    if (n.name () == "Length" && n.namespace_ ().empty ())
    {
      if (!this->Length_)
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }
    }

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomCylinder* GeomCylinder::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomCylinder (*this, f, c);
}

GeomCylinder::
~GeomCylinder ()
{
}

// GeomCapsule
//

GeomCapsule::
GeomCapsule ()
: ::GeomObject (),
  Length_ (::xml_schema::flags (), this),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomCapsule::
GeomCapsule (const GeomCapsule& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Length_ (x.Length_, f, this),
  Radius_ (x.Radius_, f, this)
{
}

GeomCapsule::
GeomCapsule (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Length_ (f, this),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomCapsule::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Length
    //
    if (n.name () == "Length" && n.namespace_ ().empty ())
    {
      if (!this->Length_)
      {
        this->Length_.set (Length_traits::create (i, f, this));
        continue;
      }
    }

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomCapsule* GeomCapsule::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomCapsule (*this, f, c);
}

GeomCapsule::
~GeomCapsule ()
{
}

// GeomSphere
//

GeomSphere::
GeomSphere ()
: ::GeomObject (),
  Radius_ (::xml_schema::flags (), this)
{
}

GeomSphere::
GeomSphere (const GeomSphere& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Radius_ (x.Radius_, f, this)
{
}

GeomSphere::
GeomSphere (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomSphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Radius
    //
    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      if (!this->Radius_)
      {
        this->Radius_.set (Radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomSphere* GeomSphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomSphere (*this, f, c);
}

GeomSphere::
~GeomSphere ()
{
}

// GeomPlane
//

GeomPlane::
GeomPlane ()
: ::GeomObject (),
  Space_ (::xml_schema::flags (), this),
  Body_ (::xml_schema::flags (), this),
  Enabled_ (::xml_schema::flags (), this)
{
}

GeomPlane::
GeomPlane (const GeomPlane& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (x, f, c),
  Space_ (x.Space_, f, this),
  Body_ (x.Body_, f, this),
  Enabled_ (x.Enabled_, f, this)
{
}

GeomPlane::
GeomPlane (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::GeomObject (e, f | ::xml_schema::flags::base, c),
  Space_ (f, this),
  Body_ (f, this),
  Enabled_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GeomPlane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GeomObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Space
    //
    if (n.name () == "Space" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Space_type > r (
        Space_traits::create (i, f, this));

      if (!this->Space_)
      {
        this->Space_.set (r);
        continue;
      }
    }

    // Body
    //
    if (n.name () == "Body" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Body_type > r (
        Body_traits::create (i, f, this));

      if (!this->Body_)
      {
        this->Body_.set (r);
        continue;
      }
    }

    // Enabled
    //
    if (n.name () == "Enabled" && n.namespace_ ().empty ())
    {
      if (!this->Enabled_)
      {
        this->Enabled_.set (Enabled_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

GeomPlane* GeomPlane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GeomPlane (*this, f, c);
}

GeomPlane::
~GeomPlane ()
{
}

// Rotation
//

Rotation::
Rotation (const Column1_type& Column1,
          const Column2_type& Column2,
          const Column3_type& Column3)
: ::RSObject (),
  Column1_ (Column1, ::xml_schema::flags (), this),
  Column2_ (Column2, ::xml_schema::flags (), this),
  Column3_ (Column3, ::xml_schema::flags (), this)
{
}

Rotation::
Rotation (::std::auto_ptr< Column1_type >& Column1,
          ::std::auto_ptr< Column2_type >& Column2,
          ::std::auto_ptr< Column3_type >& Column3)
: ::RSObject (),
  Column1_ (Column1, ::xml_schema::flags (), this),
  Column2_ (Column2, ::xml_schema::flags (), this),
  Column3_ (Column3, ::xml_schema::flags (), this)
{
}

Rotation::
Rotation (const Rotation& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::RSObject (x, f, c),
  Column1_ (x.Column1_, f, this),
  Column2_ (x.Column2_, f, this),
  Column3_ (x.Column3_, f, this)
{
}

Rotation::
Rotation (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::RSObject (e, f | ::xml_schema::flags::base, c),
  Column1_ (f, this),
  Column2_ (f, this),
  Column3_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Rotation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RSObject::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Column1
    //
    if (n.name () == "Column1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Column1_type > r (
        Column1_traits::create (i, f, this));

      if (!Column1_.present ())
      {
        this->Column1_.set (r);
        continue;
      }
    }

    // Column2
    //
    if (n.name () == "Column2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Column2_type > r (
        Column2_traits::create (i, f, this));

      if (!Column2_.present ())
      {
        this->Column2_.set (r);
        continue;
      }
    }

    // Column3
    //
    if (n.name () == "Column3" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Column3_type > r (
        Column3_traits::create (i, f, this));

      if (!Column3_.present ())
      {
        this->Column3_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Column1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column1",
      "");
  }

  if (!Column2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column2",
      "");
  }

  if (!Column3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Column3",
      "");
  }
}

Rotation* Rotation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Rotation (*this, f, c);
}

Rotation::
~Rotation ()
{
}

// Vector
//

Vector::
Vector ()
: ::xml_schema::type (),
  X_ (::xml_schema::flags (), this),
  Y_ (::xml_schema::flags (), this),
  Z_ (::xml_schema::flags (), this)
{
}

Vector::
Vector (const Vector& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

Vector::
Vector (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (f, this),
  Y_ (f, this),
  Z_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }
  }
}

Vector* Vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Vector (*this, f, c);
}

Vector::
~Vector ()
{
}

// Quaternion
//

Quaternion::
Quaternion ()
: ::xml_schema::type (),
  W_ (::xml_schema::flags (), this),
  I_ (::xml_schema::flags (), this),
  J_ (::xml_schema::flags (), this),
  K_ (::xml_schema::flags (), this)
{
}

Quaternion::
Quaternion (const Quaternion& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  W_ (x.W_, f, this),
  I_ (x.I_, f, this),
  J_ (x.J_, f, this),
  K_ (x.K_, f, this)
{
}

Quaternion::
Quaternion (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  W_ (f, this),
  I_ (f, this),
  J_ (f, this),
  K_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void Quaternion::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "W" && n.namespace_ ().empty ())
    {
      this->W_.set (W_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "I" && n.namespace_ ().empty ())
    {
      this->I_.set (I_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "J" && n.namespace_ ().empty ())
    {
      this->J_.set (J_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "K" && n.namespace_ ().empty ())
    {
      this->K_.set (K_traits::create (i, f, this));
      continue;
    }
  }
}

Quaternion* Quaternion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Quaternion (*this, f, c);
}

Quaternion::
~Quaternion ()
{
}

// Foo
//

Foo::
Foo ()
: ::RSObject ()
{
}

Foo::
Foo (const Foo& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (x, f, c)
{
}

Foo::
Foo (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::RSObject (e, f, c)
{
}

Foo* Foo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Foo (*this, f, c);
}

Foo::
~Foo ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Sim_ (isrc, h, f, p);
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Sim > r (
    ::Sim_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Sim >
Sim_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Sim > r (
      ::Sim_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Sim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Sim > r (
      ::xsd::cxx::tree::traits< ::Sim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Sim",
    "");
}

::std::auto_ptr< ::Sim >
Sim_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Sim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Sim > r (
      ::xsd::cxx::tree::traits< ::Sim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Sim",
    "");
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::World_ (isrc, h, f, p);
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::World > r (
    ::World_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::World >
World_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::World > r (
      ::World_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "World" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::World > r (
      ::xsd::cxx::tree::traits< ::World, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "World",
    "");
}

::std::auto_ptr< ::World >
World_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "World" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::World > r (
      ::xsd::cxx::tree::traits< ::World, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "World",
    "");
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Body_ (isrc, h, f, p);
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Body > r (
    ::Body_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Body >
Body_ (const ::xercesc::DOMDocument& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Body > r (
      ::Body_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Body" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Body > r (
      ::xsd::cxx::tree::traits< ::Body, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Body",
    "");
}

::std::auto_ptr< ::Body >
Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Body" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Body > r (
      ::xsd::cxx::tree::traits< ::Body, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Body",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

